Index: todo.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Todo List\n\n* 完了したタスクはリストから削除する\n\n## 未着手\n* /Users/ogawaatsuki/project/keruta/keruta-api/src/main/kotlin/net/kigawa/keruta/api/template/controller/TemplateController.kt\n  250 // TODO: 実際のCoderサーバーとの連携を実装\n  /Users/ogawaatsuki/project/keruta/keruta-api/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionEventListener.kt\n  166 // TODO: Consider implementing background cleanup task for failed workspaces\n* ~~TaskEntityのマッピングエラー修正完了 (2025-07-31)~~\n### 中優先度\n\n* **管理パネル機能拡張**\n    * ~~Kubernetes設定管理画面の実装~~ （削除済み）\n    * エージェント管理画面の実装\n    * セッション管理UIの改善（リアルタイム状態更新）\n    * ワークスペース管理UIの改善（ログ表示、リソース情報）\n* **コード品質向上**\n    * テストカバレッジの向上（keruta-executor、keruta-agent）\n    * Goエージェントのテスト強化\n\n### 低優先度（将来の改善）\n\n* **高度なワークスペース管理**\n    * ワークスペースのファイル管理API\n    * ワークスペース内リアルタイムログストリーミング\n    * ワークスペースのスナップショット機能\n* **監視とアラート**\n    * FAILEDワークスペースの自動クリーンアップタスク\n    * ワークスペース状態同期の監視・アラート機能\n    * Coder API通信の冗長化・ヘルスチェック\n    * セッション-ワークスペース関係の詳細ログ・デバッグ機能\n* **パフォーマンス最適化**\n    * データベースインデックスの最適化\n    * キャッシュ機能の導入（Redis等）\n    * 非同期処理の強化\n\n## ドキュメント更新状況\n\n### ⚠\uFE0F 部分更新必要\n\n* keruta-doc/ - 独立リポジトリに移行中のため、最新情報の同期が必要\n\n## アーキテクチャ改善履歴\n\n### 2025-07-30\n\n- モジュール構成の簡素化：6モジュール → 5モジュール（infra:core統合）\n- Kubernetes機能の完全削除\n- セキュリティ強化（ステータス変更制限）\n- ドメインモデルのクリーンアップ（メタデータ削除）\n- 依存関係の整理とビルド最適化\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/todo.md b/todo.md
--- a/todo.md	(revision 7e0737fd2c614b531299bbec51268e1021aa1bc7)
+++ b/todo.md	(date 1753978463517)
@@ -3,11 +3,12 @@
 * 完了したタスクはリストから削除する
 
 ## 未着手
+
 * /Users/ogawaatsuki/project/keruta/keruta-api/src/main/kotlin/net/kigawa/keruta/api/template/controller/TemplateController.kt
   250 // TODO: 実際のCoderサーバーとの連携を実装
   /Users/ogawaatsuki/project/keruta/keruta-api/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionEventListener.kt
   166 // TODO: Consider implementing background cleanup task for failed workspaces
-* ~~TaskEntityのマッピングエラー修正完了 (2025-07-31)~~
+
 ### 中優先度
 
 * **管理パネル機能拡張**
Index: keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/v1/HealthControllerTest.kt
===================================================================
diff --git a/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/v1/HealthControllerTest.kt b/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/v1/HealthControllerTest.kt
deleted file mode 100644
--- a/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/v1/HealthControllerTest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,27 +0,0 @@
-package net.kigawa.keruta.api.v1
-
-import org.junit.jupiter.api.Test
-import org.springframework.beans.factory.annotation.Autowired
-import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
-import org.springframework.security.test.context.support.WithMockUser
-import org.springframework.test.web.servlet.MockMvc
-import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get
-import org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath
-import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
-
-@WebMvcTest(HealthController::class)
-class HealthControllerTest {
-
-    @Autowired
-    private lateinit var mockMvc: MockMvc
-
-    @Test
-    @WithMockUser
-    fun `health endpoint should return status UP`() {
-        mockMvc.perform(get("/api/v1/health"))
-            .andExpect(status().isOk)
-            .andExpect(jsonPath("$.status").value("UP"))
-            .andExpect(jsonPath("$.message").value("Keruta API is running"))
-            .andExpect(jsonPath("$.timestamp").exists())
-    }
-}
Index: keruta-api/buildSrc/src/main/kotlin/EmptyPlugin.kt
===================================================================
diff --git a/keruta-api/buildSrc/src/main/kotlin/EmptyPlugin.kt b/keruta-api/buildSrc/src/main/kotlin/EmptyPlugin.kt
deleted file mode 100644
--- a/keruta-api/buildSrc/src/main/kotlin/EmptyPlugin.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,9 +0,0 @@
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-
-class EmptyPlugin : Plugin<Project> {
-    override fun apply(target: Project) {
-        // This is an empty plugin that does nothing
-        // It's only here to satisfy Gradle's plugin descriptor requirements
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/TaskRepository.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/TaskRepository.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/TaskRepository.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/TaskRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,26 +0,0 @@
-package net.kigawa.keruta.core.usecase.repository
-
-import net.kigawa.keruta.core.domain.model.Task
-import net.kigawa.keruta.core.domain.model.TaskStatus
-
-/**
- * Repository interface for Task operations.
- */
-interface TaskRepository {
-    suspend fun findAll(): List<Task>
-    suspend fun findById(id: String): Task?
-    suspend fun findBySessionId(sessionId: String): List<Task>
-    suspend fun findByWorkspaceId(workspaceId: String): List<Task>
-    suspend fun findByStatus(status: TaskStatus): List<Task>
-    suspend fun findBySessionIdAndStatus(sessionId: String, status: TaskStatus): List<Task>
-    suspend fun findPendingTasksForSession(sessionId: String): List<Task>
-    suspend fun findByNameContaining(name: String): List<Task>
-    suspend fun findByTag(tag: String): List<Task>
-    suspend fun findByParentTaskId(parentTaskId: String): List<Task>
-    suspend fun save(task: Task): Task
-    suspend fun deleteById(id: String): Boolean
-    suspend fun deleteBySessionId(sessionId: String): Boolean
-    suspend fun updateStatus(id: String, status: TaskStatus): Task?
-    suspend fun updateStatusAndMessage(id: String, status: TaskStatus, errorMessage: String?, errorCode: String?): Task?
-    suspend fun incrementRetryCount(id: String): Task?
-}
Index: keruta-api/buildSrc/build.gradle.kts
===================================================================
diff --git a/keruta-api/buildSrc/build.gradle.kts b/keruta-api/buildSrc/build.gradle.kts
deleted file mode 100644
--- a/keruta-api/buildSrc/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,23 +0,0 @@
-plugins {
-    `kotlin-dsl`
-}
-
-repositories {
-    mavenCentral()
-}
-
-// Suppress the warning about missing plugin descriptors
-// since we're only using buildSrc for dependency management
-gradlePlugin {
-    plugins {
-        register("empty") {
-            id = "empty"
-            implementationClass = "EmptyPlugin"
-        }
-    }
-}
-
-java {
-    sourceCompatibility = JavaVersion.VERSION_21
-    targetCompatibility = JavaVersion.VERSION_21
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/KerutaApplication.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/KerutaApplication.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/KerutaApplication.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/KerutaApplication.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,15 +0,0 @@
-package net.kigawa.keruta.api
-
-import org.springframework.boot.autoconfigure.SpringBootApplication
-import org.springframework.boot.context.properties.ConfigurationPropertiesScan
-import org.springframework.boot.runApplication
-import org.springframework.scheduling.annotation.EnableScheduling
-
-@SpringBootApplication(scanBasePackages = ["net.kigawa.keruta"])
-@EnableScheduling
-@ConfigurationPropertiesScan(basePackages = ["net.kigawa.keruta"])
-class KerutaApplication
-
-fun main(args: Array<String>) {
-    runApplication<KerutaApplication>(*args)
-}
Index: keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Task.kt
===================================================================
diff --git a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Task.kt b/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Task.kt
deleted file mode 100644
--- a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Task.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,56 +0,0 @@
-package net.kigawa.keruta.core.domain.model
-
-import java.time.LocalDateTime
-
-/**
- * Represents a task in the system.
- * Tasks are units of work that can be executed within sessions.
- */
-data class Task(
-    val id: String,
-    val name: String,
-    val description: String? = null,
-    val script: String,
-    val status: TaskStatus = TaskStatus.PENDING,
-    val sessionId: String,
-    val workspaceId: String? = null,
-    val priority: Int = 0,
-    val parameters: Map<String, String> = emptyMap(),
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val startedAt: LocalDateTime? = null,
-    val completedAt: LocalDateTime? = null,
-    val errorMessage: String? = null,
-    val errorCode: String? = null,
-    val retryCount: Int = 0,
-    val maxRetries: Int = 3,
-    val parentTaskId: String? = null,
-    val dependsOn: List<String> = emptyList(),
-    val artifacts: List<String> = emptyList(),
-    val logs: List<String> = emptyList(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-)
-
-/**
- * Represents the status of a task.
- */
-enum class TaskStatus {
-    PENDING,
-    IN_PROGRESS,
-    COMPLETED,
-    FAILED,
-    CANCELLED,
-    WAITING_FOR_INPUT,
-    RETRYING,
-}
-
-/**
- * Represents the priority levels for tasks.
- */
-enum class TaskPriority(val value: Int) {
-    LOW(0),
-    NORMAL(1),
-    HIGH(2),
-    URGENT(3),
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/RequestLoggingConfig.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/RequestLoggingConfig.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/RequestLoggingConfig.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/RequestLoggingConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,33 +0,0 @@
-package net.kigawa.keruta.infra.security.config
-
-import org.springframework.context.annotation.Bean
-import org.springframework.context.annotation.Configuration
-import org.springframework.web.filter.CommonsRequestLoggingFilter
-
-/**
- * Configuration for request logging.
- * This configures the CommonsRequestLoggingFilter to log request details.
- */
-@Configuration
-class RequestLoggingConfig {
-
-    /**
-     * Creates a CommonsRequestLoggingFilter bean.
-     * This filter logs request details, including headers, parameters, and payload.
-     *
-     * @return The configured CommonsRequestLoggingFilter
-     */
-    @Bean
-    fun commonsRequestLoggingFilter(): CommonsRequestLoggingFilter {
-        val filter = CommonsRequestLoggingFilter()
-        filter.setIncludeQueryString(true)
-        filter.setIncludePayload(true)
-        filter.setMaxPayloadLength(10000)
-        filter.setIncludeHeaders(true)
-        filter.setBeforeMessagePrefix("Request [")
-        filter.setBeforeMessageSuffix("]")
-        filter.setAfterMessagePrefix("Response [")
-        filter.setAfterMessageSuffix("]")
-        return filter
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionWorkspaceStatusSyncService.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionWorkspaceStatusSyncService.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionWorkspaceStatusSyncService.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionWorkspaceStatusSyncService.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,191 +0,0 @@
-package net.kigawa.keruta.core.usecase.session
-
-import kotlinx.coroutines.runBlocking
-import net.kigawa.keruta.core.domain.model.SessionStatus
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.core.usecase.repository.SessionRepository
-import net.kigawa.keruta.core.usecase.workspace.WorkspaceService
-import org.slf4j.LoggerFactory
-import org.springframework.scheduling.annotation.Scheduled
-import org.springframework.stereotype.Service
-import java.time.LocalDateTime
-
-/**
- * Service responsible for synchronizing session status based on workspace states.
- * This service handles the automatic updating of session status when workspace states change.
- */
-@Service
-open class SessionWorkspaceStatusSyncService(
-    open val sessionRepository: SessionRepository,
-    open val workspaceService: WorkspaceService,
-) {
-    open val logger = LoggerFactory.getLogger(SessionWorkspaceStatusSyncService::class.java)
-
-    /**
-     * Handles workspace status change and updates corresponding session status.
-     */
-    open suspend fun handleWorkspaceStatusChange(workspace: Workspace, oldStatus: WorkspaceStatus) {
-        logger.info(
-            "Synchronizing session status for workspace change: workspaceId={} sessionId={} oldStatus={} newStatus={}",
-            workspace.id,
-            workspace.sessionId,
-            oldStatus,
-            workspace.status,
-        )
-
-        try {
-            val session = sessionRepository.findById(workspace.sessionId)
-            if (session == null) {
-                logger.warn(
-                    "Session not found for workspace: sessionId={} workspaceId={}",
-                    workspace.sessionId,
-                    workspace.id,
-                )
-                return
-            }
-
-            val newSessionStatus = determineSessionStatusFromWorkspaces(workspace.sessionId)
-
-            if (newSessionStatus != null && newSessionStatus != session.status) {
-                val updatedSession = session.copy(
-                    status = newSessionStatus,
-                    updatedAt = LocalDateTime.now(),
-                )
-
-                sessionRepository.save(updatedSession)
-
-                logger.info(
-                    "Updated session status based on workspace: sessionId={} oldStatus={} newStatus={}",
-                    workspace.sessionId,
-                    session.status,
-                    newSessionStatus,
-                )
-            }
-        } catch (e: Exception) {
-            logger.error(
-                "Failed to sync session status for workspace change: workspaceId={} sessionId={}",
-                workspace.id,
-                workspace.sessionId,
-                e,
-            )
-        }
-    }
-
-    /**
-     * Periodically synchronizes session statuses with their workspace states.
-     * Runs every 5 minutes to ensure consistency.
-     */
-    @Scheduled(fixedRate = 300000) // 5 minutes
-    open fun periodicSessionStatusSync() = runBlocking {
-        logger.debug("Starting periodic session status synchronization")
-
-        try {
-            val sessions = sessionRepository.findAll()
-
-            for (session in sessions) {
-                try {
-                    val expectedStatus = determineSessionStatusFromWorkspaces(session.id)
-
-                    if (expectedStatus != null && expectedStatus != session.status) {
-                        val updatedSession = session.copy(
-                            status = expectedStatus,
-                            updatedAt = LocalDateTime.now(),
-                        )
-
-                        sessionRepository.save(updatedSession)
-
-                        logger.info(
-                            "Synchronized session status during periodic sync: sessionId={} oldStatus={} newStatus={}",
-                            session.id,
-                            session.status,
-                            expectedStatus,
-                        )
-                    }
-                } catch (e: Exception) {
-                    logger.error("Failed to sync status for session: sessionId={}", session.id, e)
-                }
-            }
-
-            logger.debug("Completed periodic session status synchronization")
-        } catch (e: Exception) {
-            logger.error("Failed to perform periodic session status synchronization", e)
-        }
-    }
-
-    /**
-     * Determines the appropriate session status based on the single workspace in the session.
-     * Since each session has exactly one workspace, the mapping is straightforward.
-     */
-    private suspend fun determineSessionStatusFromWorkspaces(sessionId: String): SessionStatus? {
-        val workspaces = workspaceService.getWorkspacesBySessionId(sessionId)
-
-        if (workspaces.isEmpty()) {
-            // No workspace, keep current session status
-            return null
-        }
-
-        if (workspaces.size > 1) {
-            logger.warn(
-                "Multiple workspaces found for session (expected 1): sessionId={} count={}",
-                sessionId,
-                workspaces.size,
-            )
-        }
-
-        // Use the first (and should be only) workspace
-        val workspace = workspaces.first()
-
-        return when (workspace.status) {
-            WorkspaceStatus.RUNNING -> SessionStatus.ACTIVE
-            WorkspaceStatus.STARTING -> SessionStatus.ACTIVE
-            WorkspaceStatus.STOPPING -> SessionStatus.ACTIVE // Transitional state
-            WorkspaceStatus.STOPPED -> SessionStatus.INACTIVE
-            WorkspaceStatus.FAILED -> SessionStatus.INACTIVE
-            WorkspaceStatus.DELETED -> SessionStatus.ARCHIVED
-            WorkspaceStatus.DELETING -> SessionStatus.ARCHIVED // Transitional to deleted
-            WorkspaceStatus.PENDING -> null // Keep current status during initialization
-            WorkspaceStatus.CANCELED -> SessionStatus.INACTIVE
-        }
-    }
-
-    /**
-     * Forces a synchronization of a specific session's status with its workspaces.
-     */
-    suspend fun forceSyncSessionStatus(sessionId: String): Boolean {
-        logger.info("Forcing session status synchronization: sessionId={}", sessionId)
-
-        try {
-            val session = sessionRepository.findById(sessionId)
-            if (session == null) {
-                logger.warn("Session not found for forced sync: sessionId={}", sessionId)
-                return false
-            }
-
-            val expectedStatus = determineSessionStatusFromWorkspaces(sessionId)
-
-            if (expectedStatus != null && expectedStatus != session.status) {
-                val updatedSession = session.copy(
-                    status = expectedStatus,
-                    updatedAt = LocalDateTime.now(),
-                )
-
-                sessionRepository.save(updatedSession)
-
-                logger.info(
-                    "Forced session status sync completed: sessionId={} oldStatus={} newStatus={}",
-                    sessionId,
-                    session.status,
-                    expectedStatus,
-                )
-                return true
-            }
-
-            logger.debug("No session status change needed for forced sync: sessionId={}", sessionId)
-            return true
-        } catch (e: Exception) {
-            logger.error("Failed to force sync session status: sessionId={}", sessionId, e)
-            return false
-        }
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/WorkspaceTemplateRepositoryImpl.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/WorkspaceTemplateRepositoryImpl.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/WorkspaceTemplateRepositoryImpl.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/WorkspaceTemplateRepositoryImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,105 +0,0 @@
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplate
-import net.kigawa.keruta.core.usecase.repository.WorkspaceTemplateRepository
-import net.kigawa.keruta.infra.persistence.entity.WorkspaceTemplateEntity
-import org.springframework.stereotype.Component
-
-/**
- * Implementation of WorkspaceTemplateRepository using MongoDB.
- */
-@Component
-class WorkspaceTemplateRepositoryImpl(
-    private val mongoWorkspaceTemplateRepository: MongoWorkspaceTemplateRepository,
-) : WorkspaceTemplateRepository {
-
-    override suspend fun findById(id: String): WorkspaceTemplate? {
-        return mongoWorkspaceTemplateRepository.findById(id).orElse(null)?.toDomain()
-    }
-
-    override suspend fun findByName(name: String): WorkspaceTemplate? {
-        return mongoWorkspaceTemplateRepository.findByName(name)?.toDomain()
-    }
-
-    override suspend fun findAll(): List<WorkspaceTemplate> {
-        return mongoWorkspaceTemplateRepository.findAll().map { it.toDomain() }
-    }
-
-    override suspend fun findDefaultTemplate(): WorkspaceTemplate? {
-        return mongoWorkspaceTemplateRepository.findFirstByIsDefaultTrue()?.toDomain()
-    }
-
-    override suspend fun save(template: WorkspaceTemplate): WorkspaceTemplate {
-        val entity = WorkspaceTemplateEntity.fromDomain(template)
-        val savedEntity = mongoWorkspaceTemplateRepository.save(entity)
-        return savedEntity.toDomain()
-    }
-
-    override suspend fun update(template: WorkspaceTemplate): WorkspaceTemplate {
-        val entity = WorkspaceTemplateEntity.fromDomain(template)
-        val updatedEntity = mongoWorkspaceTemplateRepository.save(entity)
-        return updatedEntity.toDomain()
-    }
-
-    override suspend fun delete(id: String): Boolean {
-        return if (mongoWorkspaceTemplateRepository.existsById(id)) {
-            mongoWorkspaceTemplateRepository.deleteById(id)
-            true
-        } else {
-            false
-        }
-    }
-
-    override suspend fun existsByName(name: String): Boolean {
-        return mongoWorkspaceTemplateRepository.existsByName(name)
-    }
-
-    /**
-     * Finds templates by name pattern.
-     */
-    suspend fun findByNameContainingIgnoreCase(name: String): List<WorkspaceTemplate> {
-        return mongoWorkspaceTemplateRepository.findByNameContainingIgnoreCase(name).map { it.toDomain() }
-    }
-
-    /**
-     * Finds templates by version.
-     */
-    suspend fun findByVersion(version: String): List<WorkspaceTemplate> {
-        return mongoWorkspaceTemplateRepository.findByVersion(version).map { it.toDomain() }
-    }
-
-    /**
-     * Finds template by name and version.
-     */
-    suspend fun findByNameAndVersion(name: String, version: String): WorkspaceTemplate? {
-        return mongoWorkspaceTemplateRepository.findByNameAndVersion(name, version)?.toDomain()
-    }
-
-    /**
-     * Gets all default templates (for debugging/cleanup purposes).
-     */
-    suspend fun findAllDefaultTemplates(): List<WorkspaceTemplate> {
-        return mongoWorkspaceTemplateRepository.findDefaultTemplates().map { it.toDomain() }
-    }
-
-    /**
-     * Fixes duplicate default templates by keeping only the first one as default.
-     */
-    suspend fun fixDuplicateDefaultTemplates(): Int {
-        val defaultTemplates = mongoWorkspaceTemplateRepository.findDefaultTemplates()
-
-        if (defaultTemplates.size <= 1) {
-            return 0 // No duplicates
-        }
-
-        // Keep the first one as default, mark others as non-default
-        val templatesToUpdate = defaultTemplates.drop(1)
-
-        templatesToUpdate.forEach { template ->
-            val updatedTemplate = template.copy(isDefault = false)
-            mongoWorkspaceTemplateRepository.save(updatedTemplate)
-        }
-
-        return templatesToUpdate.size
-    }
-}
Index: keruta-api/infra/app/src/test/test2.iml
===================================================================
diff --git a/keruta-api/infra/app/src/test/test2.iml b/keruta-api/infra/app/src/test/test2.iml
deleted file mode 100644
--- a/keruta-api/infra/app/src/test/test2.iml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/kotlin" isTestSource="true" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: keruta-api/api/build.gradle.kts
===================================================================
diff --git a/keruta-api/api/build.gradle.kts b/keruta-api/api/build.gradle.kts
deleted file mode 100644
--- a/keruta-api/api/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,41 +0,0 @@
-plugins {
-    kotlin("jvm")
-    kotlin("plugin.spring")
-    id("org.springframework.boot")
-}
-
-dependencies {
-    implementation(project(":core:domain"))
-    implementation(project(":core:usecase"))
-    implementation(project(":infra:persistence"))
-    implementation(project(":infra:security"))
-    implementation(project(":infra:app"))
-    implementation(project(":infra:core"))
-
-    implementation(Dependencies.kotlinStdlib)
-    implementation(Dependencies.kotlinReflect)
-    implementation(Dependencies.springBootStarter)
-    implementation(Dependencies.springBootStarterWeb)
-    // WebSocket functionality has been removed
-    // implementation(Dependencies.springBootStarterWebsocket)
-    implementation(Dependencies.springBootStarterSecurity)
-    // WebSocket functionality has been removed
-    // implementation("jakarta.websocket:jakarta.websocket-api:2.1.0")
-
-    // Swagger/OpenAPI
-    implementation(Dependencies.springdocOpenApi)
-
-    // MongoDB
-    implementation(Dependencies.springBootStarterData)
-    implementation(Dependencies.mongodbDriver)
-
-    testImplementation(Dependencies.springBootStarterTest) {
-        exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
-    }
-    testImplementation("org.junit.jupiter:junit-jupiter:${Versions.junit}")
-    testImplementation("org.springframework.security:spring-security-test")
-    testImplementation(Dependencies.testcontainersJunit)
-    testImplementation(Dependencies.testcontainersCore)
-    testImplementation(Dependencies.testcontainersMongodb)
-    testImplementation(Dependencies.testcontainersPostgresql)
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/TaskEntity.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/TaskEntity.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/TaskEntity.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/TaskEntity.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,93 +0,0 @@
-package net.kigawa.keruta.infra.persistence.entity
-
-import net.kigawa.keruta.core.domain.model.Task
-import net.kigawa.keruta.core.domain.model.TaskStatus
-import org.springframework.data.annotation.Id
-import org.springframework.data.mongodb.core.mapping.Document
-import java.time.LocalDateTime
-
-@Document(collection = "tasks")
-data class TaskEntity(
-    @Id
-    val id: String,
-    val name: String,
-    val description: String? = null,
-    val script: String,
-    val status: String,
-    val sessionId: String,
-    val workspaceId: String? = null,
-    val priority: Int = 0,
-    val parameters: Map<String, String> = emptyMap(),
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val startedAt: LocalDateTime? = null,
-    val completedAt: LocalDateTime? = null,
-    val errorMessage: String? = null,
-    val errorCode: String? = null,
-    val retryCount: Int = 0,
-    val maxRetries: Int = 3,
-    val parentTaskId: String? = null,
-    val dependsOn: List<String> = emptyList(),
-    val artifacts: List<String> = emptyList(),
-    val logs: List<String> = emptyList(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-) {
-    fun toDomain(): Task {
-        return Task(
-            id = id,
-            name = name,
-            description = description,
-            script = script,
-            status = TaskStatus.valueOf(status),
-            sessionId = sessionId,
-            workspaceId = workspaceId,
-            priority = priority,
-            parameters = parameters,
-            tags = tags,
-            metadata = metadata,
-            startedAt = startedAt,
-            completedAt = completedAt,
-            errorMessage = errorMessage,
-            errorCode = errorCode,
-            retryCount = retryCount,
-            maxRetries = maxRetries,
-            parentTaskId = parentTaskId,
-            dependsOn = dependsOn,
-            artifacts = artifacts,
-            logs = logs,
-            createdAt = createdAt,
-            updatedAt = updatedAt,
-        )
-    }
-
-    companion object {
-        fun fromDomain(task: Task): TaskEntity {
-            return TaskEntity(
-                id = task.id,
-                name = task.name,
-                description = task.description,
-                script = task.script,
-                status = task.status.name,
-                sessionId = task.sessionId,
-                workspaceId = task.workspaceId,
-                priority = task.priority,
-                parameters = task.parameters,
-                tags = task.tags,
-                metadata = task.metadata,
-                startedAt = task.startedAt,
-                completedAt = task.completedAt,
-                errorMessage = task.errorMessage,
-                errorCode = task.errorCode,
-                retryCount = task.retryCount,
-                maxRetries = task.maxRetries,
-                parentTaskId = task.parentTaskId,
-                dependsOn = task.dependsOn,
-                artifacts = task.artifacts,
-                logs = task.logs,
-                createdAt = task.createdAt,
-                updatedAt = task.updatedAt,
-            )
-        }
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoSessionRepository.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoSessionRepository.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoSessionRepository.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoSessionRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,35 +0,0 @@
-/**
- * Spring Data MongoDB repository for SessionEntity.
- */
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.infra.persistence.entity.SessionEntity
-import org.springframework.data.mongodb.repository.MongoRepository
-import org.springframework.stereotype.Repository
-
-@Repository
-interface MongoSessionRepository : MongoRepository<SessionEntity, String> {
-    /**
-     * Finds sessions by status.
-     *
-     * @param status The status to filter by
-     * @return List of sessions with the specified status
-     */
-    fun findByStatus(status: String): List<SessionEntity>
-
-    /**
-     * Finds sessions by name containing the specified string.
-     *
-     * @param name The name pattern to search for
-     * @return List of sessions with names containing the specified string
-     */
-    fun findByNameContainingIgnoreCase(name: String): List<SessionEntity>
-
-    /**
-     * Finds sessions that contain the specified tag.
-     *
-     * @param tag The tag to filter by
-     * @return List of sessions with the specified tag
-     */
-    fun findByTagsContaining(tag: String): List<SessionEntity>
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/coder/dto/CoderTemplateResponse.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/coder/dto/CoderTemplateResponse.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/coder/dto/CoderTemplateResponse.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/coder/dto/CoderTemplateResponse.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,58 +0,0 @@
-package net.kigawa.keruta.api.coder.dto
-
-import com.fasterxml.jackson.annotation.JsonProperty
-import net.kigawa.keruta.core.domain.model.CoderTemplate
-import java.time.LocalDateTime
-
-/**
- * Response DTO for Coder templates.
- */
-data class CoderTemplateResponse(
-    val id: String,
-    val name: String,
-    @JsonProperty("display_name")
-    val displayName: String,
-    val description: String,
-    val icon: String,
-    @JsonProperty("default_ttl_ms")
-    val defaultTtlMs: Long,
-    @JsonProperty("max_ttl_ms")
-    val maxTtlMs: Long,
-    @JsonProperty("min_autostart_interval_ms")
-    val minAutostartIntervalMs: Long,
-    @JsonProperty("created_by_name")
-    val createdByName: String,
-    @JsonProperty("updated_at")
-    val updatedAt: LocalDateTime,
-    @JsonProperty("organization_id")
-    val organizationId: String,
-    val provisioner: String,
-    @JsonProperty("active_version_id")
-    val activeVersionId: String,
-    @JsonProperty("workspace_count")
-    val workspaceCount: Int,
-    @JsonProperty("deprecated")
-    val deprecated: Boolean = false,
-) {
-    companion object {
-        fun fromDomain(template: CoderTemplate): CoderTemplateResponse {
-            return CoderTemplateResponse(
-                id = template.id,
-                name = template.name,
-                displayName = template.displayName,
-                description = template.description,
-                icon = template.icon,
-                defaultTtlMs = template.defaultTtlMs,
-                maxTtlMs = template.maxTtlMs,
-                minAutostartIntervalMs = template.minAutostartIntervalMs,
-                createdByName = template.createdByName,
-                updatedAt = template.updatedAt,
-                organizationId = template.organizationId,
-                provisioner = template.provisioner,
-                activeVersionId = template.activeVersionId,
-                workspaceCount = template.workspaceCount,
-                deprecated = template.deprecated,
-            )
-        }
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionTemplateConfigRequest.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionTemplateConfigRequest.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionTemplateConfigRequest.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionTemplateConfigRequest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,28 +0,0 @@
-package net.kigawa.keruta.api.session.dto
-
-import net.kigawa.keruta.core.domain.model.SessionTemplateConfig
-
-/**
- * Request DTO for session template configuration.
- */
-data class SessionTemplateConfigRequest(
-    val templateId: String? = null,
-    val templateName: String? = null,
-    val repositoryUrl: String? = null,
-    val repositoryRef: String = "main",
-    val templatePath: String = ".",
-    val preferredKeywords: List<String> = emptyList(),
-    val parameters: Map<String, String> = emptyMap(),
-) {
-    fun toDomain(): SessionTemplateConfig {
-        return SessionTemplateConfig(
-            templateId = templateId,
-            templateName = templateName,
-            repositoryUrl = repositoryUrl,
-            repositoryRef = repositoryRef,
-            templatePath = templatePath,
-            preferredKeywords = preferredKeywords,
-            parameters = parameters,
-        )
-    }
-}
Index: keruta-api/core/usecase/build.gradle.kts
===================================================================
diff --git a/keruta-api/core/usecase/build.gradle.kts b/keruta-api/core/usecase/build.gradle.kts
deleted file mode 100644
--- a/keruta-api/core/usecase/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,17 +0,0 @@
-plugins {
-    kotlin("jvm")
-}
-
-dependencies {
-    implementation(project(":core:domain"))
-
-    implementation(Dependencies.kotlinStdlib)
-    implementation(Dependencies.kotlinReflect)
-    implementation(Dependencies.springBootStarter)
-
-    // Coroutines
-    implementation(Dependencies.kotlinxCoroutinesCore)
-    implementation(Dependencies.kotlinxCoroutinesReactor)
-
-    testImplementation(Dependencies.springBootStarterTest)
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/CreateTaskRequest.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/CreateTaskRequest.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/CreateTaskRequest.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/CreateTaskRequest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,39 +0,0 @@
-package net.kigawa.keruta.api.task.dto
-
-import net.kigawa.keruta.core.domain.model.Task
-import net.kigawa.keruta.core.domain.model.TaskStatus
-import java.util.*
-
-data class CreateTaskRequest(
-    val name: String,
-    val description: String? = null,
-    val script: String,
-    val sessionId: String,
-    val workspaceId: String? = null,
-    val priority: Int = 0,
-    val parameters: Map<String, String> = emptyMap(),
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val maxRetries: Int = 3,
-    val parentTaskId: String? = null,
-    val dependsOn: List<String> = emptyList(),
-) {
-    fun toDomain(): Task {
-        return Task(
-            id = UUID.randomUUID().toString(),
-            name = name,
-            description = description,
-            script = script,
-            status = TaskStatus.PENDING,
-            sessionId = sessionId,
-            workspaceId = workspaceId,
-            priority = priority,
-            parameters = parameters,
-            tags = tags,
-            metadata = metadata,
-            maxRetries = maxRetries,
-            parentTaskId = parentTaskId,
-            dependsOn = dependsOn,
-        )
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceService.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceService.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceService.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceService.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,54 +0,0 @@
-package net.kigawa.keruta.core.usecase.workspace
-
-import net.kigawa.keruta.core.domain.model.CoderTemplate
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplate
-
-/**
- * Service interface for workspace operations.
- */
-interface WorkspaceService {
-    suspend fun createWorkspace(request: CreateWorkspaceRequest): Workspace
-    suspend fun getWorkspaceById(id: String): Workspace?
-    suspend fun getAllWorkspaces(): List<Workspace>
-    suspend fun getWorkspacesBySessionId(sessionId: String): List<Workspace>
-    suspend fun updateWorkspaceStatus(id: String, status: WorkspaceStatus): Workspace?
-    suspend fun startWorkspace(id: String): Workspace?
-    suspend fun stopWorkspace(id: String): Workspace?
-    suspend fun deleteWorkspace(id: String): Boolean
-    suspend fun deleteWorkspacesBySessionId(sessionId: String): Boolean
-    suspend fun getWorkspaceTemplates(): List<WorkspaceTemplate>
-    suspend fun getWorkspaceTemplate(id: String): WorkspaceTemplate?
-    suspend fun getDefaultWorkspaceTemplate(): WorkspaceTemplate?
-    suspend fun createWorkspaceTemplate(template: WorkspaceTemplate): WorkspaceTemplate
-    suspend fun updateWorkspaceTemplate(template: WorkspaceTemplate): WorkspaceTemplate
-    suspend fun deleteWorkspaceTemplate(id: String): Boolean
-    suspend fun getCoderTemplates(): List<CoderTemplate>
-    suspend fun getCoderTemplate(id: String): CoderTemplate?
-}
-
-/**
- * Request object for creating a workspace.
- */
-data class CreateWorkspaceRequest(
-    val name: String,
-    val sessionId: String,
-    val templateId: String? = null,
-    val templateVersionId: String? = null,
-    val autoStartSchedule: String? = null,
-    val ttlMs: Long? = null,
-    val automaticUpdates: Boolean = true,
-    val richParameterValues: Map<String, String> = emptyMap(),
-)
-
-/**
- * Request object for updating a workspace.
- */
-data class UpdateWorkspaceRequest(
-    val name: String? = null,
-    val autoStartSchedule: String? = null,
-    val ttlMs: Long? = null,
-    val automaticUpdates: Boolean? = null,
-    val richParameterValues: Map<String, String>? = null,
-)
Index: keruta-api/infra/security/build.gradle.kts
===================================================================
diff --git a/keruta-api/infra/security/build.gradle.kts b/keruta-api/infra/security/build.gradle.kts
deleted file mode 100644
--- a/keruta-api/infra/security/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,26 +0,0 @@
-plugins {
-    kotlin("jvm")
-    kotlin("plugin.spring")
-}
-
-dependencies {
-    implementation(project(":core:domain"))
-    implementation(project(":core:usecase"))
-
-    implementation(Dependencies.kotlinStdlib)
-    implementation(Dependencies.kotlinReflect)
-    implementation(Dependencies.springBootStarter)
-    implementation(Dependencies.springBootStarterSecurity)
-    implementation(Dependencies.springBootStarterOauth2Client)
-    implementation(Dependencies.jakartaServletApi)
-    implementation(Dependencies.jjwtApi)
-    implementation(Dependencies.jjwtImpl)
-    implementation(Dependencies.jjwtJackson)
-    implementation(Dependencies.jacksonDatatypeJsr310)
-    implementation(Dependencies.jacksonModuleKotlin)
-    implementation(Dependencies.springdocOpenApi)
-    implementation(Dependencies.keycloakSpringBootAdapter)
-    implementation(Dependencies.keycloakSpringSecurityAdapter)
-
-    testImplementation(Dependencies.springBootStarterTest)
-}
Index: keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Workspace.kt
===================================================================
diff --git a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Workspace.kt b/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Workspace.kt
deleted file mode 100644
--- a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Workspace.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,122 +0,0 @@
-package net.kigawa.keruta.core.domain.model
-
-import java.time.LocalDateTime
-
-/**
- * Represents a Coder-style workspace in the system.
- * Workspaces are development environments that are created per session.
- */
-data class Workspace(
-    val id: String,
-    val name: String,
-    val sessionId: String,
-    val templateId: String? = null,
-    val templateVersionId: String? = null,
-    val status: WorkspaceStatus = WorkspaceStatus.PENDING,
-    val autoStartSchedule: String? = null,
-    val ttlMs: Long? = null,
-    val automaticUpdates: Boolean = true,
-    val richParameterValues: Map<String, String> = emptyMap(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-    val startedAt: LocalDateTime? = null,
-    val stoppedAt: LocalDateTime? = null,
-    val lastUsedAt: LocalDateTime? = null,
-    val deletedAt: LocalDateTime? = null,
-    val buildInfo: WorkspaceBuildInfo? = null,
-    val resourceInfo: WorkspaceResourceInfo? = null,
-    val metadata: Map<String, String> = emptyMap(),
-)
-
-/**
- * Represents the status of a workspace.
- */
-enum class WorkspaceStatus {
-    PENDING,
-    STARTING,
-    RUNNING,
-    STOPPING,
-    STOPPED,
-    DELETING,
-    DELETED,
-    FAILED,
-    CANCELED,
-}
-
-/**
- * Represents build information for a workspace.
- */
-data class WorkspaceBuildInfo(
-    val buildId: String,
-    val buildNumber: Int,
-    val buildStatus: WorkspaceBuildStatus,
-    val buildReason: String? = null,
-    val buildStartedAt: LocalDateTime? = null,
-    val buildCompletedAt: LocalDateTime? = null,
-    val buildLog: String? = null,
-)
-
-/**
- * Represents the status of a workspace build.
- */
-enum class WorkspaceBuildStatus {
-    PENDING,
-    RUNNING,
-    SUCCEEDED,
-    FAILED,
-    CANCELED,
-}
-
-/**
- * Represents resource information for a workspace.
- */
-data class WorkspaceResourceInfo(
-    val cpuCores: Int? = null,
-    val memoryMb: Long? = null,
-    val diskGb: Long? = null,
-    val kubernetesNamespace: String? = null,
-    val persistentVolumeClaimName: String? = null,
-    val podName: String? = null,
-    val serviceName: String? = null,
-    val ingressUrl: String? = null,
-)
-
-/**
- * Represents template information for workspace creation.
- */
-data class WorkspaceTemplate(
-    val id: String,
-    val name: String,
-    val description: String? = null,
-    val version: String,
-    val icon: String? = null,
-    val isDefault: Boolean = false,
-    val parameters: List<WorkspaceTemplateParameter> = emptyList(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-)
-
-/**
- * Represents a template parameter for workspace creation.
- */
-data class WorkspaceTemplateParameter(
-    val name: String,
-    val displayName: String,
-    val description: String? = null,
-    val type: WorkspaceParameterType,
-    val required: Boolean = false,
-    val defaultValue: String? = null,
-    val options: List<String> = emptyList(),
-    val validationRegex: String? = null,
-    val mutable: Boolean = true,
-)
-
-/**
- * Represents the type of a workspace parameter.
- */
-enum class WorkspaceParameterType {
-    STRING,
-    NUMBER,
-    BOOLEAN,
-    LIST,
-}
Index: keruta-api/infra/app/src/main/resources/application.properties
===================================================================
diff --git a/keruta-api/infra/app/src/main/resources/application.properties b/keruta-api/infra/app/src/main/resources/application.properties
deleted file mode 100644
--- a/keruta-api/infra/app/src/main/resources/application.properties	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,75 +0,0 @@
-# Application
-spring.application.name=keruta
-server.port=8080
-
-# Server Thread Pool Configuration
-server.tomcat.threads.max=200
-server.tomcat.threads.min-spare=20
-server.tomcat.max-connections=10000
-server.tomcat.accept-count=100
-
-# MongoDB
-spring.data.mongodb.host=${SPRING_DATA_MONGODB_HOST:localhost}
-spring.data.mongodb.port=${SPRING_DATA_MONGODB_PORT:27017}
-spring.data.mongodb.database=${SPRING_DATA_MONGODB_DATABASE:keruta}
-spring.data.mongodb.username=${SPRING_DATA_MONGODB_USERNAME:admin}
-spring.data.mongodb.password=${SPRING_DATA_MONGODB_PASSWORD:password}
-spring.data.mongodb.authentication-database=${SPRING_DATA_MONGODB_AUTHENTICATION_DATABASE:admin}
-spring.data.mongodb.auto-index-creation=true
-
-# Logging
-# Set the logging pattern to include more information
-logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [${spring.application.name}] [%X{requestId}] [%X{userId}] [%t] [%c{1}:%L] - %m%n
-logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [${spring.application.name}] [%X{requestId}] [%X{userId}] [%t] [%c{1}:%L] - %m%n
-
-# Set log levels for different components
-logging.level.org.springframework.data.mongodb=INFO
-logging.level.net.kigawa.keruta=INFO
-
-# Security-related components logging
-logging.level.org.springframework.security=INFO
-logging.level.net.kigawa.keruta.infra.security=INFO
-logging.level.org.keycloak=INFO
-
-# HTTP requests and responses logging
-logging.level.org.springframework.web=INFO
-logging.level.org.springframework.web.filter.CommonsRequestLoggingFilter=INFO
-
-# Security - JWT Configuration
-jwt.secret=${JWT_SECRET:your-secret-key-here-should-be-very-long-and-secure}
-jwt.expiration=${JWT_EXPIRATION:86400000}
-jwt.refresh-expiration=${JWT_REFRESH_EXPIRATION:604800000}
-
-# User Authentication
-auth.admin.username=${AUTH_ADMIN_USERNAME:admin}
-auth.admin.password=${AUTH_ADMIN_PASSWORD:password}
-auth.api.username=${AUTH_API_USERNAME:keruta-api}
-auth.api.password=${AUTH_API_PASSWORD:api-password}
-
-# Token-based Authentication
-auth.token.header=Authorization
-auth.token.prefix=Bearer
-auth.token.audience=keruta-api
-auth.token.issuer=keruta-auth
-
-# WebSocket Authentication
-websocket.token.required=true
-websocket.token.param=token
-
-# Swagger/OpenAPI
-springdoc.api-docs.path=/api-docs
-springdoc.swagger-ui.path=/swagger-ui.html
-springdoc.swagger-ui.operationsSorter=method
-springdoc.swagger-ui.tagsSorter=alpha
-springdoc.swagger-ui.doc-expansion=none
-springdoc.swagger-ui.display-request-duration=true
-springdoc.swagger-ui.groups-order=asc
-springdoc.swagger-ui.disable-swagger-default-url=true
-springdoc.swagger-ui.csrf.enabled=true
-springdoc.info.title=Keruta API
-springdoc.info.description=API for managing sessions, workspaces, and documents
-springdoc.info.version=1.0
-springdoc.info.contact.name=Kigawa
-springdoc.info.contact.url=https://github.com/kigawa-net/keruta
-springdoc.info.license.name=MIT
-springdoc.info.license.url=https://opensource.org/licenses/MIT
Index: keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Session.kt
===================================================================
diff --git a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Session.kt b/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Session.kt
deleted file mode 100644
--- a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Session.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,42 +0,0 @@
-package net.kigawa.keruta.core.domain.model
-
-import java.time.LocalDateTime
-
-/**
- * Represents a session in the system.
- * Sessions are used to group related tasks together.
- */
-data class Session(
-    val id: String,
-    val name: String,
-    val description: String? = null,
-    val status: SessionStatus = SessionStatus.ACTIVE,
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val templateConfig: SessionTemplateConfig? = null,
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-)
-
-/**
- * Represents the status of a session.
- */
-enum class SessionStatus {
-    ACTIVE,
-    INACTIVE,
-    COMPLETED,
-    ARCHIVED,
-}
-
-/**
- * Configuration for Coder template used in this session.
- */
-data class SessionTemplateConfig(
-    val templateId: String? = null,
-    val templateName: String? = null,
-    val repositoryUrl: String? = null,
-    val repositoryRef: String = "main",
-    val templatePath: String = ".",
-    val preferredKeywords: List<String> = emptyList(),
-    val parameters: Map<String, String> = emptyMap(),
-)
Index: keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Document.kt
===================================================================
diff --git a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Document.kt b/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Document.kt
deleted file mode 100644
--- a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Document.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,22 +0,0 @@
-/**
- * Represents a document in the system.
- *
- * @property id The unique identifier of the document
- * @property title The title of the document
- * @property content The content of the document
- * @property tags List of tags associated with the document
- * @property createdAt The timestamp when the document was created
- * @property updatedAt The timestamp when the document was last updated
- */
-package net.kigawa.keruta.core.domain.model
-
-import java.time.LocalDateTime
-
-data class Document(
-    val id: String? = null,
-    val title: String,
-    val content: String,
-    val tags: List<String> = emptyList(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-)
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/dto/WorkspaceResponse.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/dto/WorkspaceResponse.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/dto/WorkspaceResponse.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/dto/WorkspaceResponse.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,173 +0,0 @@
-package net.kigawa.keruta.api.workspace.dto
-
-import net.kigawa.keruta.core.domain.model.*
-import java.time.LocalDateTime
-
-/**
- * Response DTO for workspace operations.
- */
-data class WorkspaceResponse(
-    val id: String,
-    val name: String,
-    val sessionId: String,
-    val templateId: String?,
-    val templateVersionId: String?,
-    val status: WorkspaceStatus,
-    val autoStartSchedule: String?,
-    val ttlMs: Long?,
-    val automaticUpdates: Boolean,
-    val richParameterValues: Map<String, String>,
-    val createdAt: LocalDateTime,
-    val updatedAt: LocalDateTime,
-    val startedAt: LocalDateTime?,
-    val stoppedAt: LocalDateTime?,
-    val lastUsedAt: LocalDateTime?,
-    val deletedAt: LocalDateTime?,
-    val buildInfo: WorkspaceBuildInfoResponse?,
-    val resourceInfo: WorkspaceResourceInfoResponse?,
-    val metadata: Map<String, String>,
-) {
-    companion object {
-        fun fromDomain(workspace: Workspace): WorkspaceResponse {
-            return WorkspaceResponse(
-                id = workspace.id,
-                name = workspace.name,
-                sessionId = workspace.sessionId,
-                templateId = workspace.templateId,
-                templateVersionId = workspace.templateVersionId,
-                status = workspace.status,
-                autoStartSchedule = workspace.autoStartSchedule,
-                ttlMs = workspace.ttlMs,
-                automaticUpdates = workspace.automaticUpdates,
-                richParameterValues = workspace.richParameterValues,
-                createdAt = workspace.createdAt,
-                updatedAt = workspace.updatedAt,
-                startedAt = workspace.startedAt,
-                stoppedAt = workspace.stoppedAt,
-                lastUsedAt = workspace.lastUsedAt,
-                deletedAt = workspace.deletedAt,
-                buildInfo = workspace.buildInfo?.let { WorkspaceBuildInfoResponse.fromDomain(it) },
-                resourceInfo = workspace.resourceInfo?.let { WorkspaceResourceInfoResponse.fromDomain(it) },
-                metadata = workspace.metadata,
-            )
-        }
-    }
-}
-
-/**
- * Response DTO for workspace build information.
- */
-data class WorkspaceBuildInfoResponse(
-    val buildId: String,
-    val buildNumber: Int,
-    val buildStatus: WorkspaceBuildStatus,
-    val buildReason: String?,
-    val buildStartedAt: LocalDateTime?,
-    val buildCompletedAt: LocalDateTime?,
-    val buildLog: String?,
-) {
-    companion object {
-        fun fromDomain(buildInfo: WorkspaceBuildInfo): WorkspaceBuildInfoResponse {
-            return WorkspaceBuildInfoResponse(
-                buildId = buildInfo.buildId,
-                buildNumber = buildInfo.buildNumber,
-                buildStatus = buildInfo.buildStatus,
-                buildReason = buildInfo.buildReason,
-                buildStartedAt = buildInfo.buildStartedAt,
-                buildCompletedAt = buildInfo.buildCompletedAt,
-                buildLog = buildInfo.buildLog,
-            )
-        }
-    }
-}
-
-/**
- * Response DTO for workspace resource information.
- */
-data class WorkspaceResourceInfoResponse(
-    val cpuCores: Int?,
-    val memoryMb: Long?,
-    val diskGb: Long?,
-    val kubernetesNamespace: String?,
-    val persistentVolumeClaimName: String?,
-    val podName: String?,
-    val serviceName: String?,
-    val ingressUrl: String?,
-) {
-    companion object {
-        fun fromDomain(resourceInfo: WorkspaceResourceInfo): WorkspaceResourceInfoResponse {
-            return WorkspaceResourceInfoResponse(
-                cpuCores = resourceInfo.cpuCores,
-                memoryMb = resourceInfo.memoryMb,
-                diskGb = resourceInfo.diskGb,
-                kubernetesNamespace = resourceInfo.kubernetesNamespace,
-                persistentVolumeClaimName = resourceInfo.persistentVolumeClaimName,
-                podName = resourceInfo.podName,
-                serviceName = resourceInfo.serviceName,
-                ingressUrl = resourceInfo.ingressUrl,
-            )
-        }
-    }
-}
-
-/**
- * Response DTO for workspace template operations.
- */
-data class WorkspaceTemplateResponse(
-    val id: String,
-    val name: String,
-    val description: String?,
-    val version: String,
-    val icon: String?,
-    val isDefault: Boolean,
-    val parameters: List<WorkspaceTemplateParameterResponse>,
-    val createdAt: LocalDateTime,
-    val updatedAt: LocalDateTime,
-) {
-    companion object {
-        fun fromDomain(template: WorkspaceTemplate): WorkspaceTemplateResponse {
-            return WorkspaceTemplateResponse(
-                id = template.id,
-                name = template.name,
-                description = template.description,
-                version = template.version,
-                icon = template.icon,
-                isDefault = template.isDefault,
-                parameters = template.parameters.map { WorkspaceTemplateParameterResponse.fromDomain(it) },
-                createdAt = template.createdAt,
-                updatedAt = template.updatedAt,
-            )
-        }
-    }
-}
-
-/**
- * Response DTO for workspace template parameters.
- */
-data class WorkspaceTemplateParameterResponse(
-    val name: String,
-    val displayName: String,
-    val description: String?,
-    val type: WorkspaceParameterType,
-    val required: Boolean,
-    val defaultValue: String?,
-    val options: List<String>,
-    val validationRegex: String?,
-    val mutable: Boolean,
-) {
-    companion object {
-        fun fromDomain(parameter: WorkspaceTemplateParameter): WorkspaceTemplateParameterResponse {
-            return WorkspaceTemplateParameterResponse(
-                name = parameter.name,
-                displayName = parameter.displayName,
-                description = parameter.description,
-                type = parameter.type,
-                required = parameter.required,
-                defaultValue = parameter.defaultValue,
-                options = parameter.options,
-                validationRegex = parameter.validationRegex,
-                mutable = parameter.mutable,
-            )
-        }
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/controller/TaskController.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/controller/TaskController.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/controller/TaskController.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/controller/TaskController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,264 +0,0 @@
-package net.kigawa.keruta.api.task.controller
-
-import io.swagger.v3.oas.annotations.Operation
-import io.swagger.v3.oas.annotations.tags.Tag
-import net.kigawa.keruta.api.task.dto.CreateTaskRequest
-import net.kigawa.keruta.api.task.dto.TaskResponse
-import net.kigawa.keruta.api.task.dto.UpdateTaskRequest
-import net.kigawa.keruta.core.domain.model.TaskStatus
-import net.kigawa.keruta.core.usecase.task.TaskService
-import org.slf4j.LoggerFactory
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.*
-
-@RestController
-@RequestMapping("/api/v1/tasks")
-@Tag(name = "Task", description = "Task management API")
-class TaskController(
-    private val taskService: TaskService,
-) {
-    private val logger = LoggerFactory.getLogger(this::class.java)
-
-    @GetMapping
-    @Operation(summary = "Get all tasks", description = "Retrieves all tasks in the system")
-    suspend fun getAllTasks(): List<TaskResponse> {
-        return taskService.getAllTasks().map { TaskResponse.fromDomain(it) }
-    }
-
-    @GetMapping("/{id}")
-    @Operation(summary = "Get task by ID", description = "Retrieves a specific task by its ID")
-    suspend fun getTaskById(@PathVariable id: String): ResponseEntity<TaskResponse> {
-        return try {
-            val task = taskService.getTaskById(id)
-            ResponseEntity.ok(TaskResponse.fromDomain(task))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @PostMapping
-    @Operation(summary = "Create a new task", description = "Creates a new task in the system")
-    suspend fun createTask(@RequestBody request: CreateTaskRequest): ResponseEntity<TaskResponse> {
-        logger.info("Creating new task: {}", request)
-        return try {
-            val task = request.toDomain()
-            val createdTask = taskService.createTask(task)
-            logger.info("Task created successfully: id={}", createdTask.id)
-            ResponseEntity.ok(TaskResponse.fromDomain(createdTask))
-        } catch (e: Exception) {
-            logger.error("Failed to create task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PutMapping("/{id}")
-    @Operation(summary = "Update task", description = "Updates an existing task")
-    suspend fun updateTask(
-        @PathVariable id: String,
-        @RequestBody request: UpdateTaskRequest,
-    ): ResponseEntity<TaskResponse> {
-        return try {
-            val existingTask = taskService.getTaskById(id)
-            val updatedTask = taskService.updateTask(id, request.toDomain(existingTask))
-            ResponseEntity.ok(TaskResponse.fromDomain(updatedTask))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to update task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @DeleteMapping("/{id}")
-    @Operation(summary = "Delete task", description = "Deletes a specific task")
-    suspend fun deleteTask(@PathVariable id: String): ResponseEntity<Void> {
-        return try {
-            taskService.deleteTask(id)
-            ResponseEntity.noContent().build()
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @GetMapping("/session/{sessionId}")
-    @Operation(summary = "Get tasks by session ID", description = "Retrieves all tasks for a specific session")
-    suspend fun getTasksBySessionId(@PathVariable sessionId: String): List<TaskResponse> {
-        return taskService.getTasksBySessionId(sessionId).map { TaskResponse.fromDomain(it) }
-    }
-
-    @GetMapping("/session/{sessionId}/pending")
-    @Operation(
-        summary = "Get pending tasks for session",
-        description = "Retrieves pending tasks for a specific session",
-    )
-    suspend fun getPendingTasksForSession(@PathVariable sessionId: String): List<TaskResponse> {
-        return taskService.getPendingTasksForSession(sessionId).map { TaskResponse.fromDomain(it) }
-    }
-
-    @GetMapping("/workspace/{workspaceId}")
-    @Operation(summary = "Get tasks by workspace ID", description = "Retrieves all tasks for a specific workspace")
-    suspend fun getTasksByWorkspaceId(@PathVariable workspaceId: String): List<TaskResponse> {
-        return taskService.getTasksByWorkspaceId(workspaceId).map { TaskResponse.fromDomain(it) }
-    }
-
-    @GetMapping("/status/{status}")
-    @Operation(summary = "Get tasks by status", description = "Retrieves all tasks with a specific status")
-    suspend fun getTasksByStatus(@PathVariable status: String): ResponseEntity<List<TaskResponse>> {
-        return try {
-            val taskStatus = TaskStatus.valueOf(status.uppercase())
-            val tasks = taskService.getTasksByStatus(taskStatus).map { TaskResponse.fromDomain(it) }
-            ResponseEntity.ok(tasks)
-        } catch (e: IllegalArgumentException) {
-            ResponseEntity.badRequest().build()
-        }
-    }
-
-    @GetMapping("/search")
-    @Operation(summary = "Search tasks by name", description = "Searches tasks by name pattern")
-    suspend fun searchTasksByName(@RequestParam name: String): List<TaskResponse> {
-        return taskService.searchTasksByName(name).map { TaskResponse.fromDomain(it) }
-    }
-
-    @GetMapping("/tag/{tag}")
-    @Operation(summary = "Get tasks by tag", description = "Retrieves all tasks with a specific tag")
-    suspend fun getTasksByTag(@PathVariable tag: String): List<TaskResponse> {
-        return taskService.getTasksByTag(tag).map { TaskResponse.fromDomain(it) }
-    }
-
-    @PutMapping("/{id}/status")
-    @Operation(summary = "Update task status", description = "Updates the status of a specific task")
-    suspend fun updateTaskStatus(
-        @PathVariable id: String,
-        @RequestBody statusRequest: Map<String, String>,
-    ): ResponseEntity<TaskResponse> {
-        val statusStr = statusRequest["status"] ?: return ResponseEntity.badRequest().build()
-
-        return try {
-            val taskStatus = TaskStatus.valueOf(statusStr.uppercase())
-            val updatedTask = taskService.updateTaskStatus(id, taskStatus)
-            ResponseEntity.ok(TaskResponse.fromDomain(updatedTask))
-        } catch (e: IllegalArgumentException) {
-            logger.error("Invalid task status: {}", statusStr, e)
-            ResponseEntity.badRequest().build()
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to update task status", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/start")
-    @Operation(summary = "Start task", description = "Starts a specific task")
-    suspend fun startTask(@PathVariable id: String): ResponseEntity<TaskResponse> {
-        return try {
-            val task = taskService.startTask(id)
-            ResponseEntity.ok(TaskResponse.fromDomain(task))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to start task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/complete")
-    @Operation(summary = "Complete task", description = "Marks a specific task as completed")
-    suspend fun completeTask(@PathVariable id: String): ResponseEntity<TaskResponse> {
-        return try {
-            val task = taskService.completeTask(id)
-            ResponseEntity.ok(TaskResponse.fromDomain(task))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to complete task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/fail")
-    @Operation(summary = "Fail task", description = "Marks a specific task as failed")
-    suspend fun failTask(
-        @PathVariable id: String,
-        @RequestBody failRequest: Map<String, String>,
-    ): ResponseEntity<TaskResponse> {
-        val errorMessage = failRequest["errorMessage"] ?: "Task failed"
-        val errorCode = failRequest["errorCode"]
-
-        return try {
-            val task = taskService.failTask(id, errorMessage, errorCode)
-            ResponseEntity.ok(TaskResponse.fromDomain(task))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to fail task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/retry")
-    @Operation(summary = "Retry task", description = "Retries a specific task")
-    suspend fun retryTask(@PathVariable id: String): ResponseEntity<TaskResponse> {
-        return try {
-            val task = taskService.retryTask(id)
-            ResponseEntity.ok(TaskResponse.fromDomain(task))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to retry task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/cancel")
-    @Operation(summary = "Cancel task", description = "Cancels a specific task")
-    suspend fun cancelTask(@PathVariable id: String): ResponseEntity<TaskResponse> {
-        return try {
-            val task = taskService.cancelTask(id)
-            ResponseEntity.ok(TaskResponse.fromDomain(task))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to cancel task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/logs")
-    @Operation(summary = "Add log to task", description = "Adds a log message to a specific task")
-    suspend fun addLogToTask(
-        @PathVariable id: String,
-        @RequestBody logRequest: Map<String, String>,
-    ): ResponseEntity<TaskResponse> {
-        val logMessage = logRequest["message"] ?: return ResponseEntity.badRequest().build()
-
-        return try {
-            val task = taskService.addLogToTask(id, logMessage)
-            ResponseEntity.ok(TaskResponse.fromDomain(task))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to add log to task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/artifacts")
-    @Operation(summary = "Add artifact to task", description = "Adds an artifact to a specific task")
-    suspend fun addArtifactToTask(
-        @PathVariable id: String,
-        @RequestBody artifactRequest: Map<String, String>,
-    ): ResponseEntity<TaskResponse> {
-        val artifactPath = artifactRequest["path"] ?: return ResponseEntity.badRequest().build()
-
-        return try {
-            val task = taskService.addArtifactToTask(id, artifactPath)
-            ResponseEntity.ok(TaskResponse.fromDomain(task))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to add artifact to task", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/config/SchedulingConfig.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/config/SchedulingConfig.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/config/SchedulingConfig.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/config/SchedulingConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,14 +0,0 @@
-package net.kigawa.keruta.core.usecase.config
-
-import org.springframework.context.annotation.Configuration
-import org.springframework.scheduling.annotation.EnableAsync
-import org.springframework.scheduling.annotation.EnableScheduling
-
-/**
- * Configuration for enabling Spring's scheduling and async capabilities.
- * This is required for the session-workspace status synchronization services.
- */
-@Configuration
-@EnableScheduling
-@EnableAsync
-open class SchedulingConfig
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/SessionEntity.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/SessionEntity.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/SessionEntity.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/SessionEntity.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,59 +0,0 @@
-package net.kigawa.keruta.infra.persistence.entity
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionStatus
-import net.kigawa.keruta.core.domain.model.SessionTemplateConfig
-import org.springframework.data.annotation.Id
-import org.springframework.data.mongodb.core.mapping.Document
-import java.time.LocalDateTime
-
-@Document(collection = "sessions")
-data class SessionEntity(
-    @Id
-    val id: String,
-    val name: String,
-    val description: String? = null,
-    val status: String = SessionStatus.ACTIVE.name,
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val templateConfig: SessionTemplateConfig? = null,
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-) {
-    companion object {
-        fun fromDomain(session: Session): SessionEntity {
-            return SessionEntity(
-                id = session.id,
-                name = session.name,
-                description = session.description,
-                status = session.status.name,
-                tags = session.tags,
-                metadata = session.metadata,
-                templateConfig = session.templateConfig,
-                createdAt = session.createdAt,
-                updatedAt = session.updatedAt,
-            )
-        }
-    }
-
-    fun toDomain(): Session {
-        val sessionStatus = try {
-            SessionStatus.valueOf(status)
-        } catch (e: IllegalArgumentException) {
-            println("Invalid session status: $status for session: $id. Using ACTIVE as fallback.")
-            SessionStatus.ACTIVE
-        }
-
-        return Session(
-            id = id,
-            name = name,
-            description = description,
-            status = sessionStatus,
-            tags = tags,
-            metadata = metadata,
-            templateConfig = templateConfig,
-            createdAt = createdAt,
-            updatedAt = updatedAt,
-        )
-    }
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/jwt/JwtAuthenticationFilter.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/jwt/JwtAuthenticationFilter.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/jwt/JwtAuthenticationFilter.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/jwt/JwtAuthenticationFilter.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,26 +0,0 @@
-/**
- * Filter for JWT authentication.
- * This filter has been disabled as part of the authentication removal.
- */
-package net.kigawa.keruta.infra.security.jwt
-
-import jakarta.servlet.FilterChain
-import jakarta.servlet.http.HttpServletRequest
-import jakarta.servlet.http.HttpServletResponse
-import org.slf4j.LoggerFactory
-import org.springframework.web.filter.OncePerRequestFilter
-
-// @Component and @Order annotations removed to disable this filter
-class JwtAuthenticationFilter(private val jwtTokenProvider: JwtTokenProvider) : OncePerRequestFilter() {
-    private val logger = LoggerFactory.getLogger(JwtAuthenticationFilter::class.java)
-
-    override fun doFilterInternal(
-        request: HttpServletRequest,
-        response: HttpServletResponse,
-        filterChain: FilterChain,
-    ) {
-        // Authentication logic removed
-        logger.debug("JWT authentication filter disabled")
-        filterChain.doFilter(request, response)
-    }
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/SecurityConfig.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/SecurityConfig.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/SecurityConfig.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/SecurityConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,94 +0,0 @@
-package net.kigawa.keruta.infra.security.config
-
-import org.springframework.beans.factory.annotation.Value
-import org.springframework.context.annotation.Bean
-import org.springframework.context.annotation.Configuration
-import org.springframework.core.Ordered
-import org.springframework.core.annotation.Order
-import org.springframework.security.config.annotation.web.builders.HttpSecurity
-import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
-import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
-import org.springframework.security.crypto.password.PasswordEncoder
-import org.springframework.security.web.SecurityFilterChain
-import org.springframework.web.cors.CorsConfiguration
-import org.springframework.web.cors.CorsConfigurationSource
-import org.springframework.web.cors.UrlBasedCorsConfigurationSource
-import org.springframework.web.filter.CorsFilter
-
-@Configuration
-@EnableWebSecurity
-class SecurityConfig {
-
-    @Value("\${spring.web.cors.allowed-origins:*}")
-    private lateinit var allowedOrigins: String
-
-    @Value("\${spring.web.cors.allowed-methods:GET,POST,PUT,DELETE,PATCH,OPTIONS}")
-    private lateinit var allowedMethods: String
-
-    @Value("\${spring.web.cors.allowed-headers:*}")
-    private lateinit var allowedHeaders: String
-
-    @Value("\${spring.web.cors.allow-credentials:false}")
-    private var allowCredentials: Boolean = false
-
-    @Value("\${spring.web.cors.max-age:3600}")
-    private var maxAge: Long = 3600
-
-    @Value("\${spring.web.cors.specific-origins:http://localhost:3000,http://localhost:3001,https://keruta.kigawa.net}")
-    private lateinit var specificOriginsString: String
-
-    @Bean
-    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
-        http
-            .csrf { it.disable() }
-            .cors { it.configurationSource(corsConfigurationSource()) }
-            .authorizeHttpRequests { auth ->
-                auth
-                    // Allow all requests
-                    .anyRequest().permitAll()
-            }
-
-        return http.build()
-    }
-
-    @Bean
-    fun corsConfigurationSource(): CorsConfigurationSource {
-        val configuration = CorsConfiguration()
-
-        // Always include specific origins that need to be allowed
-        val specificOrigins = specificOriginsString.split(",").map { it.trim() }
-
-        // If allowedOrigins contains a wildcard, replace it with specific origins
-        // Otherwise, add the specific origins to the existing list
-        if (allowedOrigins.contains("*")) {
-            configuration.allowedOrigins = specificOrigins
-        } else {
-            val configuredOrigins = allowedOrigins.split(",").map { it.trim() }
-            configuration.allowedOrigins = (configuredOrigins + specificOrigins).distinct()
-        }
-
-        configuration.allowedMethods = allowedMethods.split(",").map { it.trim() }
-        configuration.allowedHeaders = allowedHeaders.split(",").map { it.trim() }
-        configuration.allowCredentials = true // Always allow credentials
-        configuration.maxAge = maxAge
-
-        val source = UrlBasedCorsConfigurationSource()
-        source.registerCorsConfiguration("/**", configuration)
-        return source
-    }
-
-    @Bean
-    fun passwordEncoder(): PasswordEncoder {
-        return BCryptPasswordEncoder()
-    }
-
-    /**
-     * Creates a CorsFilter bean with a high order to ensure it's applied early in the filter chain.
-     * This ensures that CORS headers are applied to all responses, including error responses.
-     */
-    @Bean
-    @Order(Ordered.HIGHEST_PRECEDENCE)
-    fun corsFilter(): CorsFilter {
-        return CorsFilter(corsConfigurationSource())
-    }
-}
Index: keruta-api/api/src/test/test3.iml
===================================================================
diff --git a/keruta-api/api/src/test/test3.iml b/keruta-api/api/src/test/test3.iml
deleted file mode 100644
--- a/keruta-api/api/src/test/test3.iml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/kotlin" isTestSource="true" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/controller/WorkspaceController.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/controller/WorkspaceController.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/controller/WorkspaceController.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/controller/WorkspaceController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,191 +0,0 @@
-package net.kigawa.keruta.api.workspace.controller
-
-import net.kigawa.keruta.api.workspace.dto.*
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.core.usecase.workspace.WorkspaceService
-import org.slf4j.LoggerFactory
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.*
-
-/**
- * REST controller for workspace management.
- */
-@RestController
-@RequestMapping("/api/v1/workspaces")
-@CrossOrigin(origins = ["*"])
-class WorkspaceController(
-    private val workspaceService: WorkspaceService,
-) {
-    private val logger = LoggerFactory.getLogger(WorkspaceController::class.java)
-
-    /**
-     * Creates a new workspace.
-     */
-    @PostMapping
-    suspend fun createWorkspace(@RequestBody request: CreateWorkspaceRequest): ResponseEntity<WorkspaceResponse> {
-        logger.info("Creating workspace: ${request.name} for session: ${request.sessionId}")
-
-        val useCaseRequest = net.kigawa.keruta.core.usecase.workspace.CreateWorkspaceRequest(
-            name = request.name,
-            sessionId = request.sessionId,
-            templateId = request.templateId,
-            templateVersionId = request.templateVersionId,
-            autoStartSchedule = request.autoStartSchedule,
-            ttlMs = request.ttlMs,
-            automaticUpdates = request.automaticUpdates,
-            richParameterValues = request.richParameterValues,
-        )
-
-        val workspace = workspaceService.createWorkspace(useCaseRequest)
-        return ResponseEntity.ok(WorkspaceResponse.fromDomain(workspace))
-    }
-
-    /**
-     * Gets all workspaces.
-     */
-    @GetMapping
-    suspend fun getWorkspaces(
-        @RequestParam(required = false) sessionId: String?,
-    ): ResponseEntity<List<WorkspaceResponse>> {
-        val workspaces = if (sessionId != null) {
-            workspaceService.getWorkspacesBySessionId(sessionId)
-        } else {
-            workspaceService.getAllWorkspaces()
-        }
-
-        return ResponseEntity.ok(workspaces.map { WorkspaceResponse.fromDomain(it) })
-    }
-
-    /**
-     * Gets a workspace by ID.
-     */
-    @GetMapping("/{id}")
-    suspend fun getWorkspace(@PathVariable id: String): ResponseEntity<WorkspaceResponse> {
-        val workspace = workspaceService.getWorkspaceById(id)
-            ?: return ResponseEntity.notFound().build()
-
-        return ResponseEntity.ok(WorkspaceResponse.fromDomain(workspace))
-    }
-
-    /**
-     * Updates workspace status.
-     */
-    @PutMapping("/{id}/status")
-    suspend fun updateWorkspaceStatus(
-        @PathVariable id: String,
-        @RequestBody request: Map<String, String>,
-    ): ResponseEntity<WorkspaceResponse> {
-        val status = request["status"]?.let { WorkspaceStatus.valueOf(it) }
-            ?: return ResponseEntity.badRequest().build()
-
-        val workspace = workspaceService.updateWorkspaceStatus(id, status)
-            ?: return ResponseEntity.notFound().build()
-
-        return ResponseEntity.ok(WorkspaceResponse.fromDomain(workspace))
-    }
-
-    /**
-     * Starts a workspace.
-     */
-    @PostMapping("/{id}/start")
-    suspend fun startWorkspace(@PathVariable id: String): ResponseEntity<WorkspaceResponse> {
-        val workspace = workspaceService.startWorkspace(id)
-            ?: return ResponseEntity.notFound().build()
-
-        return ResponseEntity.ok(WorkspaceResponse.fromDomain(workspace))
-    }
-
-    /**
-     * Stops a workspace.
-     */
-    @PostMapping("/{id}/stop")
-    suspend fun stopWorkspace(@PathVariable id: String): ResponseEntity<WorkspaceResponse> {
-        val workspace = workspaceService.stopWorkspace(id)
-            ?: return ResponseEntity.notFound().build()
-
-        return ResponseEntity.ok(WorkspaceResponse.fromDomain(workspace))
-    }
-
-    /**
-     * Gets workspace by session ID (1:1 relationship).
-     */
-    @GetMapping("/session/{sessionId}")
-    suspend fun getWorkspaceBySessionId(@PathVariable sessionId: String): ResponseEntity<WorkspaceResponse> {
-        val workspaces = workspaceService.getWorkspacesBySessionId(sessionId)
-        val workspace = workspaces.firstOrNull()
-            ?: return ResponseEntity.notFound().build()
-
-        return ResponseEntity.ok(WorkspaceResponse.fromDomain(workspace))
-    }
-
-    /**
-     * Deletes a workspace.
-     */
-    @DeleteMapping("/{id}")
-    suspend fun deleteWorkspace(@PathVariable id: String): ResponseEntity<Void> {
-        val deleted = workspaceService.deleteWorkspace(id)
-        return if (deleted) {
-            ResponseEntity.noContent().build()
-        } else {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    /**
-     * Gets workspace templates.
-     */
-    @GetMapping("/templates")
-    suspend fun getWorkspaceTemplates(): ResponseEntity<List<WorkspaceTemplateResponse>> {
-        val templates = workspaceService.getWorkspaceTemplates()
-        return ResponseEntity.ok(templates.map { WorkspaceTemplateResponse.fromDomain(it) })
-    }
-
-    /**
-     * Gets a workspace template by ID.
-     */
-    @GetMapping("/templates/{id}")
-    suspend fun getWorkspaceTemplate(@PathVariable id: String): ResponseEntity<WorkspaceTemplateResponse> {
-        val template = workspaceService.getWorkspaceTemplate(id)
-            ?: return ResponseEntity.notFound().build()
-
-        return ResponseEntity.ok(WorkspaceTemplateResponse.fromDomain(template))
-    }
-
-    /**
-     * Creates a workspace template.
-     */
-    @PostMapping("/templates")
-    suspend fun createWorkspaceTemplate(
-        @RequestBody request: CreateWorkspaceTemplateRequest,
-    ): ResponseEntity<WorkspaceTemplateResponse> {
-        val template = request.toDomain()
-        val createdTemplate = workspaceService.createWorkspaceTemplate(template)
-        return ResponseEntity.ok(WorkspaceTemplateResponse.fromDomain(createdTemplate))
-    }
-
-    /**
-     * Updates a workspace template.
-     */
-    @PutMapping("/templates/{id}")
-    suspend fun updateWorkspaceTemplate(
-        @PathVariable id: String,
-        @RequestBody request: UpdateWorkspaceTemplateRequest,
-    ): ResponseEntity<WorkspaceTemplateResponse> {
-        val template = request.toDomain(id)
-        val updatedTemplate = workspaceService.updateWorkspaceTemplate(template)
-        return ResponseEntity.ok(WorkspaceTemplateResponse.fromDomain(updatedTemplate))
-    }
-
-    /**
-     * Deletes a workspace template.
-     */
-    @DeleteMapping("/templates/{id}")
-    suspend fun deleteWorkspaceTemplate(@PathVariable id: String): ResponseEntity<Void> {
-        val deleted = workspaceService.deleteWorkspaceTemplate(id)
-        return if (deleted) {
-            ResponseEntity.noContent().build()
-        } else {
-            ResponseEntity.notFound().build()
-        }
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/TaskResponse.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/TaskResponse.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/TaskResponse.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/TaskResponse.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,60 +0,0 @@
-package net.kigawa.keruta.api.task.dto
-
-import net.kigawa.keruta.core.domain.model.Task
-import java.time.LocalDateTime
-
-data class TaskResponse(
-    val id: String,
-    val name: String,
-    val description: String?,
-    val script: String,
-    val status: String,
-    val sessionId: String,
-    val workspaceId: String?,
-    val priority: Int,
-    val parameters: Map<String, String>,
-    val tags: List<String>,
-    val metadata: Map<String, String>,
-    val startedAt: LocalDateTime?,
-    val completedAt: LocalDateTime?,
-    val errorMessage: String?,
-    val errorCode: String?,
-    val retryCount: Int,
-    val maxRetries: Int,
-    val parentTaskId: String?,
-    val dependsOn: List<String>,
-    val artifacts: List<String>,
-    val logs: List<String>,
-    val createdAt: LocalDateTime,
-    val updatedAt: LocalDateTime,
-) {
-    companion object {
-        fun fromDomain(task: Task): TaskResponse {
-            return TaskResponse(
-                id = task.id,
-                name = task.name,
-                description = task.description,
-                script = task.script,
-                status = task.status.name,
-                sessionId = task.sessionId,
-                workspaceId = task.workspaceId,
-                priority = task.priority,
-                parameters = task.parameters,
-                tags = task.tags,
-                metadata = task.metadata,
-                startedAt = task.startedAt,
-                completedAt = task.completedAt,
-                errorMessage = task.errorMessage,
-                errorCode = task.errorCode,
-                retryCount = task.retryCount,
-                maxRetries = task.maxRetries,
-                parentTaskId = task.parentTaskId,
-                dependsOn = task.dependsOn,
-                artifacts = task.artifacts,
-                logs = task.logs,
-                createdAt = task.createdAt,
-                updatedAt = task.updatedAt,
-            )
-        }
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceOrchestrator.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceOrchestrator.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceOrchestrator.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceOrchestrator.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,245 +0,0 @@
-package net.kigawa.keruta.core.usecase.workspace
-
-import net.kigawa.keruta.core.domain.model.CoderTemplate
-import net.kigawa.keruta.core.domain.model.SessionTemplateConfig
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceResourceInfo
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplate
-import net.kigawa.keruta.core.usecase.executor.ExecutorClient
-import net.kigawa.keruta.core.usecase.repository.WorkspaceRepository
-import org.slf4j.LoggerFactory
-import org.springframework.beans.factory.annotation.Autowired
-import org.springframework.context.ApplicationContext
-import org.springframework.scheduling.annotation.Async
-import org.springframework.stereotype.Component
-import java.time.LocalDateTime
-import java.util.concurrent.CompletableFuture
-
-/**
- * Orchestrator for workspace lifecycle management.
- * Handles the asynchronous creation, starting, stopping, and deletion of workspaces.
- *
- * Note: Coder-specific functionality has been moved to keruta-executor.
- * This now serves as a stub for future workspace orchestration implementations.
- */
-@Component
-open class WorkspaceOrchestrator(
-    open val workspaceRepository: WorkspaceRepository,
-    private val applicationContext: ApplicationContext,
-) {
-    @Autowired(required = false)
-    private var executorClient: ExecutorClient? = null
-
-    open val logger = LoggerFactory.getLogger(WorkspaceOrchestrator::class.java)
-
-    private fun getWorkspaceKubernetesHandler(): Any? {
-        return try {
-            applicationContext.getBean("workspaceKubernetesHandler")
-        } catch (e: Exception) {
-            null
-        }
-    }
-
-    /**
-     * Creates a workspace asynchronously.
-     * Note: This is now a stub implementation. Actual workspace creation should be handled by keruta-executor.
-     */
-    @Async("infraTaskExecutor")
-    suspend fun createWorkspaceAsync(
-        workspace: Workspace,
-        template: WorkspaceTemplate,
-        sessionTemplateConfig: SessionTemplateConfig? = null,
-    ): CompletableFuture<Workspace> {
-        val future = CompletableFuture<Workspace>()
-
-        try {
-            logger.info("Creating workspace ${workspace.id}")
-
-            // If Kubernetes handler is available, create actual Kubernetes resources
-            val workspaceKubernetesHandler = getWorkspaceKubernetesHandler()
-            val updatedWorkspace = if (workspaceKubernetesHandler != null) {
-                try {
-                    // Use reflection to call the handler to avoid compile-time dependency
-                    val handlerClass = workspaceKubernetesHandler!!::class.java
-                    val createMethod = handlerClass.getMethod("createWorkspaceResources", Workspace::class.java)
-                    val resourceInfo = createMethod.invoke(
-                        workspaceKubernetesHandler,
-                        workspace,
-                    ) as WorkspaceResourceInfo
-
-                    val workspaceWithResources = workspace.copy(
-                        status = WorkspaceStatus.STARTING,
-                        resourceInfo = resourceInfo,
-                        updatedAt = LocalDateTime.now(),
-                    )
-                    workspaceRepository.update(workspaceWithResources)
-                } catch (e: Exception) {
-                    logger.error("Failed to create Kubernetes resources for workspace ${workspace.id}", e)
-                    workspace.copy(
-                        status = WorkspaceStatus.FAILED,
-                        updatedAt = LocalDateTime.now(),
-                    )
-                }
-            } else {
-                // Fallback: Update workspace to pending state - actual creation will be handled by keruta-executor
-                workspace.copy(
-                    status = WorkspaceStatus.PENDING,
-                    updatedAt = LocalDateTime.now(),
-                )
-            }
-
-            val savedWorkspace = workspaceRepository.update(updatedWorkspace)
-            future.complete(savedWorkspace)
-        } catch (e: Exception) {
-            logger.error("Failed to update workspace status: ${workspace.id}", e)
-            future.completeExceptionally(e)
-        }
-
-        return future
-    }
-
-    /**
-     * Starts a workspace asynchronously.
-     * Note: This is now a stub implementation. Actual workspace starting should be handled by keruta-executor.
-     */
-    @Async("infraTaskExecutor")
-    suspend fun startWorkspaceAsync(workspace: Workspace): CompletableFuture<Workspace> {
-        val future = CompletableFuture<Workspace>()
-
-        try {
-            logger.info("Stub: Starting workspace ${workspace.id} - actual implementation moved to keruta-executor")
-
-            // Update workspace to starting state - actual start will be handled by keruta-executor
-            val startingWorkspace = workspace.copy(
-                status = WorkspaceStatus.STARTING,
-                updatedAt = LocalDateTime.now(),
-            )
-            val updatedWorkspace = workspaceRepository.update(startingWorkspace)
-            future.complete(updatedWorkspace)
-        } catch (e: Exception) {
-            logger.error("Failed to update workspace status: ${workspace.id}", e)
-            future.completeExceptionally(e)
-        }
-
-        return future
-    }
-
-    /**
-     * Stops a workspace asynchronously.
-     * Note: This is now a stub implementation. Actual workspace stopping should be handled by keruta-executor.
-     */
-    @Async("infraTaskExecutor")
-    suspend fun stopWorkspaceAsync(workspace: Workspace): CompletableFuture<Workspace> {
-        val future = CompletableFuture<Workspace>()
-
-        try {
-            logger.info("Stub: Stopping workspace ${workspace.id} - actual implementation moved to keruta-executor")
-
-            // Update workspace to stopping state - actual stop will be handled by keruta-executor
-            val stoppingWorkspace = workspace.copy(
-                status = WorkspaceStatus.STOPPING,
-                updatedAt = LocalDateTime.now(),
-            )
-            val updatedWorkspace = workspaceRepository.update(stoppingWorkspace)
-            future.complete(updatedWorkspace)
-        } catch (e: Exception) {
-            logger.error("Failed to update workspace status: ${workspace.id}", e)
-            future.completeExceptionally(e)
-        }
-
-        return future
-    }
-
-    /**
-     * Deletes a workspace asynchronously.
-     * Note: This is now a stub implementation. Actual workspace deletion should be handled by keruta-executor.
-     */
-    @Async("infraTaskExecutor")
-    suspend fun deleteWorkspaceAsync(workspace: Workspace): CompletableFuture<Boolean> {
-        val future = CompletableFuture<Boolean>()
-
-        try {
-            logger.info("Deleting workspace ${workspace.id}")
-
-            // If Kubernetes handler is available, delete actual Kubernetes resources
-            val workspaceKubernetesHandler = getWorkspaceKubernetesHandler()
-            val deleteResult = if (workspaceKubernetesHandler != null) {
-                try {
-                    // Use reflection to call the handler to avoid compile-time dependency
-                    val handlerClass = workspaceKubernetesHandler!!::class.java
-                    val deleteMethod = handlerClass.getMethod("deleteWorkspaceResources", Workspace::class.java)
-                    val result = deleteMethod.invoke(workspaceKubernetesHandler, workspace) as Boolean
-
-                    if (result) {
-                        val deletedWorkspace = workspace.copy(
-                            status = WorkspaceStatus.DELETED,
-                            deletedAt = LocalDateTime.now(),
-                            updatedAt = LocalDateTime.now(),
-                        )
-                        workspaceRepository.update(deletedWorkspace)
-                        true
-                    } else {
-                        false
-                    }
-                } catch (e: Exception) {
-                    logger.error("Failed to delete Kubernetes resources for workspace ${workspace.id}", e)
-                    false
-                }
-            } else {
-                // Fallback: Update workspace to deleting state - actual deletion will be handled by keruta-executor
-                val deletingWorkspace = workspace.copy(
-                    status = WorkspaceStatus.DELETING,
-                    updatedAt = LocalDateTime.now(),
-                )
-                workspaceRepository.update(deletingWorkspace)
-                true
-            }
-
-            future.complete(deleteResult)
-        } catch (e: Exception) {
-            logger.error("Failed to update workspace status: ${workspace.id}", e)
-            future.completeExceptionally(e)
-        }
-
-        return future
-    }
-
-    /**
-     * Gets available Coder templates from the executor service.
-     */
-    suspend fun getCoderTemplates(): List<CoderTemplate> {
-        logger.info("Fetching Coder templates via executor service")
-
-        return try {
-            val client = executorClient
-            if (client == null) {
-                logger.warn("ExecutorClient is not available - returning empty list")
-                return emptyList()
-            }
-            client.getCoderTemplates()
-        } catch (e: Exception) {
-            logger.error("Failed to fetch Coder templates via executor", e)
-            emptyList()
-        }
-    }
-
-    /**
-     * Gets a specific Coder template by ID via executor service.
-     */
-    suspend fun getCoderTemplate(id: String): CoderTemplate? {
-        logger.info("Fetching Coder template: $id via executor service")
-
-        return try {
-            val client = executorClient
-            if (client == null) {
-                logger.warn("ExecutorClient is not available - returning null")
-                return null
-            }
-            client.getCoderTemplate(id)
-        } catch (e: Exception) {
-            logger.error("Failed to fetch Coder template: $id via executor", e)
-            null
-        }
-    }
-}
Index: keruta-api/infra/persistence/src/test/test.iml
===================================================================
diff --git a/keruta-api/infra/persistence/src/test/test.iml b/keruta-api/infra/persistence/src/test/test.iml
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/test/test.iml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/kotlin" isTestSource="true" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/task/TaskService.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/task/TaskService.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/task/TaskService.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/task/TaskService.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,37 +0,0 @@
-package net.kigawa.keruta.core.usecase.task
-
-import net.kigawa.keruta.core.domain.model.Task
-import net.kigawa.keruta.core.domain.model.TaskStatus
-
-/**
- * Service interface for task operations.
- */
-interface TaskService {
-    suspend fun getAllTasks(): List<Task>
-    suspend fun getTaskById(id: String): Task
-    suspend fun getTasksBySessionId(sessionId: String): List<Task>
-    suspend fun getTasksByWorkspaceId(workspaceId: String): List<Task>
-    suspend fun getTasksByStatus(status: TaskStatus): List<Task>
-    suspend fun getPendingTasksForSession(sessionId: String): List<Task>
-    suspend fun searchTasksByName(name: String): List<Task>
-    suspend fun getTasksByTag(tag: String): List<Task>
-    suspend fun getSubTasks(parentTaskId: String): List<Task>
-    suspend fun createTask(task: Task): Task
-    suspend fun updateTask(id: String, task: Task): Task
-    suspend fun deleteTask(id: String)
-    suspend fun deleteTasksBySessionId(sessionId: String)
-    suspend fun updateTaskStatus(id: String, status: TaskStatus): Task
-    suspend fun updateTaskStatusWithMessage(
-        id: String,
-        status: TaskStatus,
-        errorMessage: String?,
-        errorCode: String?,
-    ): Task
-    suspend fun startTask(id: String): Task
-    suspend fun completeTask(id: String): Task
-    suspend fun failTask(id: String, errorMessage: String, errorCode: String?): Task
-    suspend fun retryTask(id: String): Task
-    suspend fun cancelTask(id: String): Task
-    suspend fun addLogToTask(id: String, logMessage: String): Task
-    suspend fun addArtifactToTask(id: String, artifactPath: String): Task
-}
Index: keruta-api/core/domain/build.gradle.kts
===================================================================
diff --git a/keruta-api/core/domain/build.gradle.kts b/keruta-api/core/domain/build.gradle.kts
deleted file mode 100644
--- a/keruta-api/core/domain/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,10 +0,0 @@
-plugins {
-    kotlin("jvm")
-}
-
-dependencies {
-    implementation(Dependencies.kotlinStdlib)
-    implementation(Dependencies.kotlinReflect)
-
-    testImplementation(Dependencies.springBootStarterTest)
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/dto/CreateWorkspaceRequest.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/dto/CreateWorkspaceRequest.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/dto/CreateWorkspaceRequest.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/workspace/dto/CreateWorkspaceRequest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,112 +0,0 @@
-package net.kigawa.keruta.api.workspace.dto
-
-import net.kigawa.keruta.core.domain.model.WorkspaceParameterType
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplate
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplateParameter
-import java.time.LocalDateTime
-import java.util.UUID
-
-/**
- * Request DTO for creating a workspace.
- */
-data class CreateWorkspaceRequest(
-    val name: String,
-    val sessionId: String,
-    val templateId: String? = null,
-    val templateVersionId: String? = null,
-    val autoStartSchedule: String? = null,
-    val ttlMs: Long? = null,
-    val automaticUpdates: Boolean = true,
-    val richParameterValues: Map<String, String> = emptyMap(),
-)
-
-/**
- * Request DTO for updating a workspace.
- */
-data class UpdateWorkspaceRequest(
-    val name: String? = null,
-    val autoStartSchedule: String? = null,
-    val ttlMs: Long? = null,
-    val automaticUpdates: Boolean? = null,
-    val richParameterValues: Map<String, String>? = null,
-)
-
-/**
- * Request DTO for creating a workspace template.
- */
-data class CreateWorkspaceTemplateRequest(
-    val name: String,
-    val description: String? = null,
-    val version: String,
-    val icon: String? = null,
-    val isDefault: Boolean = false,
-    val parameters: List<WorkspaceTemplateParameterRequest> = emptyList(),
-) {
-    fun toDomain(): WorkspaceTemplate {
-        return WorkspaceTemplate(
-            id = UUID.randomUUID().toString(),
-            name = name,
-            description = description,
-            version = version,
-            icon = icon,
-            isDefault = isDefault,
-            parameters = parameters.map { it.toDomain() },
-            createdAt = LocalDateTime.now(),
-            updatedAt = LocalDateTime.now(),
-        )
-    }
-}
-
-/**
- * Request DTO for updating a workspace template.
- */
-data class UpdateWorkspaceTemplateRequest(
-    val name: String? = null,
-    val description: String? = null,
-    val version: String? = null,
-    val icon: String? = null,
-    val isDefault: Boolean? = null,
-    val parameters: List<WorkspaceTemplateParameterRequest>? = null,
-) {
-    fun toDomain(id: String): WorkspaceTemplate {
-        return WorkspaceTemplate(
-            id = id,
-            name = name ?: "",
-            description = description,
-            version = version ?: "",
-            icon = icon,
-            isDefault = isDefault ?: false,
-            parameters = parameters?.map { it.toDomain() } ?: emptyList(),
-            updatedAt = LocalDateTime.now(),
-        )
-    }
-}
-
-/**
- * Request DTO for workspace template parameters.
- */
-data class WorkspaceTemplateParameterRequest(
-    val name: String,
-    val displayName: String,
-    val description: String? = null,
-    val type: WorkspaceParameterType,
-    val required: Boolean = false,
-    val defaultValue: String? = null,
-    val options: List<String> = emptyList(),
-    val validationRegex: String? = null,
-    val mutable: Boolean = true,
-) {
-    fun toDomain(): WorkspaceTemplateParameter {
-        return WorkspaceTemplateParameter(
-            name = name,
-            displayName = displayName,
-            description = description,
-            type = type,
-            required = required,
-            defaultValue = defaultValue,
-            options = options,
-            validationRegex = validationRegex,
-            mutable = mutable,
-        )
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/TaskRepositoryImpl.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/TaskRepositoryImpl.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/TaskRepositoryImpl.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/TaskRepositoryImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,127 +0,0 @@
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.core.domain.model.Task
-import net.kigawa.keruta.core.domain.model.TaskStatus
-import net.kigawa.keruta.core.usecase.repository.TaskRepository
-import net.kigawa.keruta.infra.persistence.entity.TaskEntity
-import org.springframework.stereotype.Repository
-import java.time.LocalDateTime
-
-@Repository
-open class TaskRepositoryImpl(
-    private val mongoTaskRepository: MongoTaskRepository,
-) : TaskRepository {
-
-    override suspend fun findAll(): List<Task> {
-        return mongoTaskRepository.findAll().map { it.toDomain() }
-    }
-
-    override suspend fun findById(id: String): Task? {
-        return mongoTaskRepository.findById(id).orElse(null)?.toDomain()
-    }
-
-    override suspend fun findBySessionId(sessionId: String): List<Task> {
-        return mongoTaskRepository.findBySessionId(sessionId).map { it.toDomain() }
-    }
-
-    override suspend fun findByWorkspaceId(workspaceId: String): List<Task> {
-        return mongoTaskRepository.findByWorkspaceId(workspaceId).map { it.toDomain() }
-    }
-
-    override suspend fun findByStatus(status: TaskStatus): List<Task> {
-        return mongoTaskRepository.findByStatus(status.name).map { it.toDomain() }
-    }
-
-    override suspend fun findBySessionIdAndStatus(sessionId: String, status: TaskStatus): List<Task> {
-        return mongoTaskRepository.findBySessionIdAndStatus(sessionId, status.name).map { it.toDomain() }
-    }
-
-    override suspend fun findPendingTasksForSession(sessionId: String): List<Task> {
-        return mongoTaskRepository.findPendingTasksForSession(sessionId).map { it.toDomain() }
-    }
-
-    override suspend fun findByNameContaining(name: String): List<Task> {
-        return mongoTaskRepository.findByNameContainingIgnoreCase(name).map { it.toDomain() }
-    }
-
-    override suspend fun findByTag(tag: String): List<Task> {
-        return mongoTaskRepository.findByTagsContaining(tag).map { it.toDomain() }
-    }
-
-    override suspend fun findByParentTaskId(parentTaskId: String): List<Task> {
-        return mongoTaskRepository.findByParentTaskId(parentTaskId).map { it.toDomain() }
-    }
-
-    override suspend fun save(task: Task): Task {
-        val entity = TaskEntity.fromDomain(task.copy(updatedAt = LocalDateTime.now()))
-        val savedEntity = mongoTaskRepository.save(entity)
-        return savedEntity.toDomain()
-    }
-
-    override suspend fun deleteById(id: String): Boolean {
-        return if (mongoTaskRepository.existsById(id)) {
-            mongoTaskRepository.deleteById(id)
-            true
-        } else {
-            false
-        }
-    }
-
-    override suspend fun deleteBySessionId(sessionId: String): Boolean {
-        val deletedCount = mongoTaskRepository.deleteBySessionId(sessionId)
-        return deletedCount > 0
-    }
-
-    override suspend fun updateStatus(id: String, status: TaskStatus): Task? {
-        val existingEntity = mongoTaskRepository.findById(id).orElse(null) ?: return null
-        val updatedEntity = existingEntity.copy(
-            status = status.name,
-            updatedAt = LocalDateTime.now(),
-            startedAt = if (status == TaskStatus.IN_PROGRESS && existingEntity.startedAt == null) {
-                LocalDateTime.now()
-            } else {
-                existingEntity.startedAt
-            },
-            completedAt = if (status == TaskStatus.COMPLETED || status == TaskStatus.FAILED) {
-                LocalDateTime.now()
-            } else {
-                existingEntity.completedAt
-            },
-        )
-        val savedEntity = mongoTaskRepository.save(updatedEntity)
-        return savedEntity.toDomain()
-    }
-
-    override suspend fun updateStatusAndMessage(
-        id: String,
-        status: TaskStatus,
-        errorMessage: String?,
-        errorCode: String?,
-    ): Task? {
-        val existingEntity = mongoTaskRepository.findById(id).orElse(null) ?: return null
-        val updatedEntity = existingEntity.copy(
-            status = status.name,
-            errorMessage = errorMessage,
-            errorCode = errorCode,
-            updatedAt = LocalDateTime.now(),
-            completedAt = if (status == TaskStatus.COMPLETED || status == TaskStatus.FAILED) {
-                LocalDateTime.now()
-            } else {
-                existingEntity.completedAt
-            },
-        )
-        val savedEntity = mongoTaskRepository.save(updatedEntity)
-        return savedEntity.toDomain()
-    }
-
-    override suspend fun incrementRetryCount(id: String): Task? {
-        val existingEntity = mongoTaskRepository.findById(id).orElse(null) ?: return null
-        val updatedEntity = existingEntity.copy(
-            retryCount = existingEntity.retryCount + 1,
-            status = TaskStatus.RETRYING.name,
-            updatedAt = LocalDateTime.now(),
-        )
-        val savedEntity = mongoTaskRepository.save(updatedEntity)
-        return savedEntity.toDomain()
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/coder/controller/CoderController.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/coder/controller/CoderController.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/coder/controller/CoderController.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/coder/controller/CoderController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,53 +0,0 @@
-package net.kigawa.keruta.api.coder.controller
-
-import net.kigawa.keruta.api.coder.dto.CoderTemplateResponse
-import net.kigawa.keruta.core.usecase.workspace.WorkspaceService
-import org.slf4j.LoggerFactory
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.*
-
-/**
- * REST controller for Coder integration.
- */
-@RestController
-@RequestMapping("/api/v1/coder")
-@CrossOrigin(origins = ["*"])
-class CoderController(
-    private val workspaceService: WorkspaceService,
-) {
-    private val logger = LoggerFactory.getLogger(CoderController::class.java)
-
-    /**
-     * Gets available Coder templates from the Coder server.
-     */
-    @GetMapping("/templates")
-    suspend fun getCoderTemplates(): ResponseEntity<List<CoderTemplateResponse>> {
-        logger.info("Fetching Coder templates from Coder server")
-
-        try {
-            val templates = workspaceService.getCoderTemplates()
-            return ResponseEntity.ok(templates.map { CoderTemplateResponse.fromDomain(it) })
-        } catch (e: Exception) {
-            logger.error("Failed to fetch Coder templates", e)
-            return ResponseEntity.ok(emptyList())
-        }
-    }
-
-    /**
-     * Gets a specific Coder template by ID.
-     */
-    @GetMapping("/templates/{id}")
-    suspend fun getCoderTemplate(@PathVariable id: String): ResponseEntity<CoderTemplateResponse> {
-        logger.info("Fetching Coder template: $id")
-
-        try {
-            val template = workspaceService.getCoderTemplate(id)
-                ?: return ResponseEntity.notFound().build()
-
-            return ResponseEntity.ok(CoderTemplateResponse.fromDomain(template))
-        } catch (e: Exception) {
-            logger.error("Failed to fetch Coder template: $id", e)
-            return ResponseEntity.notFound().build()
-        }
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/DocumentEntity.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/DocumentEntity.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/DocumentEntity.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/DocumentEntity.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,55 +0,0 @@
-/**
- * MongoDB entity for Document.
- */
-package net.kigawa.keruta.infra.persistence.entity
-
-import net.kigawa.keruta.core.domain.model.Document
-import org.springframework.data.annotation.Id
-import java.time.LocalDateTime
-import org.springframework.data.mongodb.core.mapping.Document as MongoDocument
-
-@MongoDocument(collection = "documents")
-data class DocumentEntity(
-    @Id
-    val id: String? = null,
-    val title: String,
-    val content: String,
-    val tags: List<String> = emptyList(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-) {
-    companion object {
-        /**
-         * Creates an entity from a domain model.
-         *
-         * @param document The domain model
-         * @return The entity
-         */
-        fun fromDomain(document: Document): DocumentEntity {
-            return DocumentEntity(
-                id = document.id,
-                title = document.title,
-                content = document.content,
-                tags = document.tags,
-                createdAt = document.createdAt,
-                updatedAt = document.updatedAt,
-            )
-        }
-    }
-
-    /**
-     * Converts this entity to a domain model.
-     *
-     * @return The domain model
-     */
-    fun toDomain(): Document {
-        return Document(
-            id = id,
-            title = title,
-            content = content,
-            tags = tags,
-            createdAt = createdAt,
-            updatedAt = updatedAt,
-        )
-    }
-}
Index: keruta-api/infra/app/src/main/main2.iml
===================================================================
diff --git a/keruta-api/infra/app/src/main/main2.iml b/keruta-api/infra/app/src/main/main2.iml
deleted file mode 100644
--- a/keruta-api/infra/app/src/main/main2.iml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/kotlin" isTestSource="false" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/config/AsyncConfig.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/config/AsyncConfig.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/config/AsyncConfig.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/config/AsyncConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,43 +0,0 @@
-package net.kigawa.keruta.api.config
-
-import org.springframework.context.annotation.Bean
-import org.springframework.context.annotation.Configuration
-import org.springframework.scheduling.annotation.EnableAsync
-import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor
-import java.util.concurrent.Executor
-
-/**
- * Configuration class for asynchronous task execution.
- * Defines a custom thread pool for handling asynchronous tasks with increased thread counts.
- */
-@Configuration(value = "apiAsyncConfig")
-@EnableAsync
-class AsyncConfig {
-
-    /**
-     * Creates a custom thread pool task executor with increased thread counts.
-     *
-     * @return A configured ThreadPoolTaskExecutor
-     */
-    @Bean(name = ["taskExecutor"])
-    fun taskExecutor(): Executor {
-        val executor = ThreadPoolTaskExecutor()
-
-        // Set core pool size (number of threads to keep in the pool, even if they are idle)
-        executor.corePoolSize = 10
-
-        // Set max pool size (maximum number of threads to allow in the pool)
-        executor.maxPoolSize = 50
-
-        // Set queue capacity (size of the queue used for holding tasks before they are executed)
-        executor.queueCapacity = 100
-
-        // Set thread name prefix for better identification in logs and monitoring
-        executor.setThreadNamePrefix("AsyncTask-")
-
-        // Initialize the executor
-        executor.initialize()
-
-        return executor
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/WorkspaceTemplateEntity.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/WorkspaceTemplateEntity.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/WorkspaceTemplateEntity.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/WorkspaceTemplateEntity.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,100 +0,0 @@
-package net.kigawa.keruta.infra.persistence.entity
-
-import net.kigawa.keruta.core.domain.model.WorkspaceParameterType
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplate
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplateParameter
-import org.springframework.data.annotation.Id
-import org.springframework.data.mongodb.core.mapping.Document
-import java.time.LocalDateTime
-
-/**
- * MongoDB entity for workspace template.
- */
-@Document(collection = "workspace_templates")
-data class WorkspaceTemplateEntity(
-    @Id
-    val id: String,
-    val name: String,
-    val description: String? = null,
-    val version: String,
-    val icon: String? = null,
-    val isDefault: Boolean = false,
-    val parameters: List<WorkspaceTemplateParameterEntity> = emptyList(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-) {
-    fun toDomain(): WorkspaceTemplate {
-        return WorkspaceTemplate(
-            id = id,
-            name = name,
-            description = description,
-            version = version,
-            icon = icon,
-            isDefault = isDefault,
-            parameters = parameters.map { it.toDomain() },
-            createdAt = createdAt,
-            updatedAt = updatedAt,
-        )
-    }
-
-    companion object {
-        fun fromDomain(template: WorkspaceTemplate): WorkspaceTemplateEntity {
-            return WorkspaceTemplateEntity(
-                id = template.id,
-                name = template.name,
-                description = template.description,
-                version = template.version,
-                icon = template.icon,
-                isDefault = template.isDefault,
-                parameters = template.parameters.map { WorkspaceTemplateParameterEntity.fromDomain(it) },
-                createdAt = template.createdAt,
-                updatedAt = template.updatedAt,
-            )
-        }
-    }
-}
-
-/**
- * MongoDB entity for workspace template parameter.
- */
-data class WorkspaceTemplateParameterEntity(
-    val name: String,
-    val displayName: String,
-    val description: String? = null,
-    val type: WorkspaceParameterType,
-    val required: Boolean = false,
-    val defaultValue: String? = null,
-    val options: List<String> = emptyList(),
-    val validationRegex: String? = null,
-    val mutable: Boolean = true,
-) {
-    fun toDomain(): WorkspaceTemplateParameter {
-        return WorkspaceTemplateParameter(
-            name = name,
-            displayName = displayName,
-            description = description,
-            type = type,
-            required = required,
-            defaultValue = defaultValue,
-            options = options,
-            validationRegex = validationRegex,
-            mutable = mutable,
-        )
-    }
-
-    companion object {
-        fun fromDomain(parameter: WorkspaceTemplateParameter): WorkspaceTemplateParameterEntity {
-            return WorkspaceTemplateParameterEntity(
-                name = parameter.name,
-                displayName = parameter.displayName,
-                description = parameter.description,
-                type = parameter.type,
-                required = parameter.required,
-                defaultValue = parameter.defaultValue,
-                options = parameter.options,
-                validationRegex = parameter.validationRegex,
-                mutable = parameter.mutable,
-            )
-        }
-    }
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/service/UserService.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/service/UserService.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/service/UserService.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/service/UserService.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,80 +0,0 @@
-package net.kigawa.keruta.infra.security.service
-
-import jakarta.annotation.PostConstruct
-import net.kigawa.keruta.infra.security.model.User
-import org.springframework.beans.factory.annotation.Value
-import org.springframework.security.core.userdetails.UserDetails
-import org.springframework.security.core.userdetails.UserDetailsService
-import org.springframework.security.core.userdetails.UsernameNotFoundException
-import org.springframework.security.crypto.password.PasswordEncoder
-import org.springframework.stereotype.Service
-
-/**
- * Service for user management.
- */
-@Service
-open class UserService(
-    private val passwordEncoder: PasswordEncoder,
-) : UserDetailsService {
-
-    @Value("\${auth.admin.username:admin}")
-    private lateinit var adminUsername: String
-
-    @Value("\${auth.admin.password:password}")
-    private lateinit var adminPassword: String
-
-    @Value("\${auth.api.username:keruta-api}")
-    private lateinit var apiUsername: String
-
-    @Value("\${auth.api.password:api-password}")
-    private lateinit var apiPassword: String
-
-    private val users = mutableMapOf<String, User>()
-
-    /**
-     * Initializes the user service with default users.
-     */
-    @PostConstruct
-    fun init() {
-        if (users.isEmpty()) {
-            // Create admin user
-            val encodedAdminPassword = passwordEncoder.encode(adminPassword)
-            val adminUser = User.create(adminUsername, encodedAdminPassword, listOf("ADMIN"))
-            users[adminUsername] = adminUser
-
-            // Create API user
-            val encodedApiPassword = passwordEncoder.encode(apiPassword)
-            val apiUser = User.create(apiUsername, encodedApiPassword, listOf("API"))
-            users[apiUsername] = apiUser
-        }
-    }
-
-    /**
-     * Loads a user by username.
-     *
-     * @param username The username
-     * @return The user details
-     * @throws UsernameNotFoundException If the user is not found
-     */
-    override fun loadUserByUsername(username: String): UserDetails {
-        init()
-        return users[username] ?: throw UsernameNotFoundException("User not found: $username")
-    }
-
-    /**
-     * Validates a user's credentials.
-     *
-     * @param username The username
-     * @param password The password
-     * @return true if the credentials are valid, false otherwise
-     */
-    fun validateCredentials(username: String, password: String): Boolean {
-        val user = try {
-            loadUserByUsername(username)
-        } catch (e: UsernameNotFoundException) {
-            return false
-        }
-
-        return passwordEncoder.matches(password, user.password)
-    }
-}
Index: keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/config/KubernetesProperties.kt
===================================================================
diff --git a/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/config/KubernetesProperties.kt b/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/config/KubernetesProperties.kt
deleted file mode 100644
--- a/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/config/KubernetesProperties.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,17 +0,0 @@
-package net.kigawa.keruta.infra.app.config
-
-import org.springframework.boot.context.properties.ConfigurationProperties
-
-@ConfigurationProperties(prefix = "keruta.kubernetes")
-data class KubernetesProperties(
-    var enabled: Boolean = false,
-    var configPath: String = "",
-    var inCluster: Boolean = false,
-    var defaultNamespace: String = "default",
-    var defaultImage: String = "keruta-task-executor:latest",
-    var defaultPvcStorageSize: String = "1Gi",
-    var defaultPvcAccessMode: String = "ReadWriteOnce",
-    var defaultPvcStorageClass: String = "",
-    var apiUrl: String = "http://keruta-api",
-    var apiPort: Int? = null,
-)
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/ApiSecurityConfig.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/ApiSecurityConfig.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/ApiSecurityConfig.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/ApiSecurityConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,34 +0,0 @@
-package net.kigawa.keruta.infra.security.config
-
-import org.springframework.context.annotation.Bean
-import org.springframework.context.annotation.Configuration
-import org.springframework.core.annotation.Order
-import org.springframework.security.config.annotation.web.builders.HttpSecurity
-import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
-import org.springframework.security.web.SecurityFilterChain
-
-/**
- * Security configuration for API endpoints.
- * This configuration has a higher order than the default one,
- * so it will be applied first for API endpoints.
- */
-@Configuration
-@EnableWebSecurity
-class ApiSecurityConfig(private val securityConfig: SecurityConfig) {
-
-    @Bean
-    @Order(1) // Higher priority than the default SecurityFilterChain
-    fun apiSecurityFilterChain(http: HttpSecurity): SecurityFilterChain {
-        http
-            .securityMatcher("/api/**") // Only apply this configuration to API endpoints
-            .csrf { it.disable() }
-            .cors { it.configurationSource(securityConfig.corsConfigurationSource()) }
-            .authorizeHttpRequests { auth ->
-                auth
-                    // Allow all API requests
-                    .anyRequest().permitAll()
-            }
-
-        return http.build()
-    }
-}
Index: keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Script.kt
===================================================================
diff --git a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Script.kt b/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Script.kt
deleted file mode 100644
--- a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/Script.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,16 +0,0 @@
-package net.kigawa.keruta.core.domain.model
-
-import java.time.LocalDateTime
-
-/**
- * Represents a script for a task.
- */
-data class Script(
-    val taskId: String,
-    val installScript: String,
-    val executeScript: String,
-    val cleanupScript: String,
-    val environment: Map<String, String> = emptyMap(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-)
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/DocumentRepositoryImpl.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/DocumentRepositoryImpl.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/DocumentRepositoryImpl.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/DocumentRepositoryImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,43 +0,0 @@
-/**
- * Implementation of the DocumentRepository interface using MongoDB.
- */
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.core.domain.model.Document
-import net.kigawa.keruta.core.usecase.repository.DocumentRepository
-import net.kigawa.keruta.infra.persistence.entity.DocumentEntity
-import org.springframework.stereotype.Component
-
-@Component
-class DocumentRepositoryImpl(private val mongoDocumentRepository: MongoDocumentRepository) : DocumentRepository {
-
-    override fun findAll(): List<Document> {
-        return mongoDocumentRepository.findAll().map { it.toDomain() }
-    }
-
-    override fun findById(id: String): Document? {
-        return mongoDocumentRepository.findById(id).orElse(null)?.toDomain()
-    }
-
-    override fun save(document: Document): Document {
-        val entity = DocumentEntity.fromDomain(document)
-        return mongoDocumentRepository.save(entity).toDomain()
-    }
-
-    override fun deleteById(id: String): Boolean {
-        return if (mongoDocumentRepository.existsById(id)) {
-            mongoDocumentRepository.deleteById(id)
-            true
-        } else {
-            false
-        }
-    }
-
-    override fun search(query: String): List<Document> {
-        return mongoDocumentRepository.search(query).map { it.toDomain() }
-    }
-
-    override fun findByTag(tag: String): List<Document> {
-        return mongoDocumentRepository.findByTagsContaining(tag).map { it.toDomain() }
-    }
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/controller/AuthController.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/controller/AuthController.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/controller/AuthController.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/controller/AuthController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,59 +0,0 @@
-package net.kigawa.keruta.infra.security.controller
-
-import io.swagger.v3.oas.annotations.Operation
-import io.swagger.v3.oas.annotations.tags.Tag
-import net.kigawa.keruta.infra.security.dto.LoginRequest
-import net.kigawa.keruta.infra.security.dto.RefreshTokenRequest
-import net.kigawa.keruta.infra.security.dto.TokenResponse
-import org.slf4j.LoggerFactory
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.PostMapping
-import org.springframework.web.bind.annotation.RequestBody
-import org.springframework.web.bind.annotation.RequestMapping
-import org.springframework.web.bind.annotation.RestController
-
-/**
- * Controller for authentication.
- * Authentication has been disabled, but endpoints are kept for compatibility.
- */
-@RestController
-@RequestMapping("/api/v1/auth")
-@Tag(name = "Authentication", description = "Authentication API (Disabled)")
-class AuthController {
-    private val logger = LoggerFactory.getLogger(AuthController::class.java)
-
-    // Dummy tokens that will be returned for all requests
-    private val dummyAccessToken = "dummy-access-token"
-    private val dummyRefreshToken = "dummy-refresh-token"
-
-    /**
-     * Login endpoint.
-     * Authentication has been disabled, so this always returns dummy tokens.
-     *
-     * @param loginRequest The login request
-     * @return The token response with dummy tokens
-     */
-    @PostMapping("/login")
-    @Operation(summary = "Login (Disabled)", description = "Authentication has been disabled, returns dummy tokens")
-    fun login(@RequestBody loginRequest: LoginRequest): ResponseEntity<TokenResponse> {
-        logger.info("Login request received for user: ${loginRequest.username} (Authentication disabled)")
-        return ResponseEntity.ok(TokenResponse(dummyAccessToken, dummyRefreshToken))
-    }
-
-    /**
-     * Refresh token endpoint.
-     * Authentication has been disabled, so this always returns dummy tokens.
-     *
-     * @param refreshTokenRequest The refresh token request
-     * @return The token response with dummy tokens
-     */
-    @PostMapping("/refresh")
-    @Operation(
-        summary = "Refresh token (Disabled)",
-        description = "Authentication has been disabled, returns dummy tokens",
-    )
-    fun refresh(@RequestBody refreshTokenRequest: RefreshTokenRequest): ResponseEntity<TokenResponse> {
-        logger.info("Token refresh request received (Authentication disabled)")
-        return ResponseEntity.ok(TokenResponse(dummyAccessToken, dummyRefreshToken))
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/DocumentRepository.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/DocumentRepository.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/DocumentRepository.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/DocumentRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,55 +0,0 @@
-/**
- * Repository interface for Document entity operations.
- */
-package net.kigawa.keruta.core.usecase.repository
-
-import net.kigawa.keruta.core.domain.model.Document
-
-interface DocumentRepository {
-    /**
-     * Finds all documents in the system.
-     *
-     * @return List of all documents
-     */
-    fun findAll(): List<Document>
-
-    /**
-     * Finds a document by its ID.
-     *
-     * @param id The ID of the document to find
-     * @return The document if found, null otherwise
-     */
-    fun findById(id: String): Document?
-
-    /**
-     * Saves a document to the repository.
-     *
-     * @param document The document to save
-     * @return The saved document with generated ID if it was a new document
-     */
-    fun save(document: Document): Document
-
-    /**
-     * Deletes a document by its ID.
-     *
-     * @param id The ID of the document to delete
-     * @return true if the document was deleted, false otherwise
-     */
-    fun deleteById(id: String): Boolean
-
-    /**
-     * Searches for documents by title or content.
-     *
-     * @param query The search query
-     * @return List of documents matching the query
-     */
-    fun search(query: String): List<Document>
-
-    /**
-     * Finds documents by tag.
-     *
-     * @param tag The tag to filter by
-     * @return List of documents with the specified tag
-     */
-    fun findByTag(tag: String): List<Document>
-}
Index: keruta-api/api/src/main/resources/application.properties
===================================================================
diff --git a/keruta-api/api/src/main/resources/application.properties b/keruta-api/api/src/main/resources/application.properties
deleted file mode 100644
--- a/keruta-api/api/src/main/resources/application.properties	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,123 +0,0 @@
-# Application
-spring.application.name=keruta
-server.port=${SERVER_PORT:8080}
-
-# Server Thread Pool Configuration
-server.tomcat.threads.max=200
-server.tomcat.threads.min-spare=20
-server.tomcat.max-connections=10000
-server.tomcat.accept-count=100
-
-# Jackson JSON Configuration
-spring.jackson.serialization.write-dates-as-timestamps=false
-spring.jackson.date-format=yyyy-MM-dd'T'HH:mm:ss.SSS
-spring.jackson.time-zone=Asia/Tokyo
-
-# MongoDB
-spring.data.mongodb.host=${SPRING_DATA_MONGODB_HOST:localhost}
-spring.data.mongodb.port=${SPRING_DATA_MONGODB_PORT:27017}
-spring.data.mongodb.database=${SPRING_DATA_MONGODB_DATABASE:keruta}
-spring.data.mongodb.username=${SPRING_DATA_MONGODB_USERNAME:admin}
-spring.data.mongodb.password=${SPRING_DATA_MONGODB_PASSWORD:password}
-spring.data.mongodb.authentication-database=${SPRING_DATA_MONGODB_AUTHENTICATION_DATABASE:admin}
-spring.data.mongodb.auto-index-creation=true
-
-# Logging
-# Set the logging pattern to include more information
-logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [${spring.application.name}] [%X{requestId}] [%X{userId}] [%t] [%c{1}:%L] - %m%n
-logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [${spring.application.name}] [%X{requestId}] [%X{userId}] [%t] [%c{1}:%L] - %m%n
-
-# Set log levels for different components
-logging.level.org.springframework.data.mongodb=INFO
-#logging.level.net.kigawa.keruta=DEBUG
-logging.level.net.kigawa.keruta=INFO
-
-# Security-related components logging
-logging.level.org.springframework.security=INFO
-logging.level.net.kigawa.keruta.infra.security=INFO
-logging.level.org.keycloak=INFO
-
-# HTTP requests and responses logging
-logging.level.org.springframework.web=INFO
-logging.level.org.springframework.web.filter.CommonsRequestLoggingFilter=INFO
-
-# Security - JWT Configuration removed
-# jwt.secret=${JWT_SECRET:your-secret-key-here-should-be-very-long-and-secure}
-# jwt.expiration=${JWT_EXPIRATION:86400000}
-# jwt.refresh-expiration=${JWT_REFRESH_EXPIRATION:604800000}
-
-# Token-based Authentication removed
-# auth.token.header=Authorization
-# auth.token.prefix=Bearer
-# auth.token.audience=keruta-api
-# auth.token.issuer=keruta-auth
-
-# WebSocket Authentication - Removed
-# websocket.token.required=true
-# websocket.token.param=token
-
-# Swagger/OpenAPI
-springdoc.api-docs.path=/api-docs
-springdoc.swagger-ui.path=/swagger-ui.html
-springdoc.swagger-ui.operationsSorter=method
-springdoc.swagger-ui.tagsSorter=alpha
-springdoc.swagger-ui.doc-expansion=none
-springdoc.swagger-ui.display-request-duration=true
-springdoc.swagger-ui.groups-order=asc
-springdoc.swagger-ui.disable-swagger-default-url=true
-springdoc.swagger-ui.csrf.enabled=true
-springdoc.info.title=Keruta API
-springdoc.info.description=API for managing sessions, workspaces, and documents
-springdoc.info.version=1.0
-springdoc.info.contact.name=Kigawa
-springdoc.info.contact.url=https://github.com/kigawa-net/keruta
-springdoc.info.license.name=MIT
-springdoc.info.license.url=https://opensource.org/licenses/MIT
-
-
-# CORS Configuration
-spring.web.cors.allowed-origins=${SPRING_WEB_CORS_ALLOWED_ORIGINS:*}
-spring.web.cors.allowed-methods=${SPRING_WEB_CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,PATCH,OPTIONS}
-spring.web.cors.allowed-headers=${SPRING_WEB_CORS_ALLOWED_HEADERS:*}
-spring.web.cors.allow-credentials=${SPRING_WEB_CORS_ALLOW_CREDENTIALS:false}
-spring.web.cors.max-age=${SPRING_WEB_CORS_MAX_AGE:3600}
-spring.web.cors.specific-origins=${SPRING_WEB_CORS_SPECIFIC_ORIGINS:http://localhost:3000,http://localhost:3001,https://keruta.kigawa.net}
-
-# Keycloak configuration removed
-# spring.security.oauth2.client.registration.keycloak.client-id=${KEYCLOAK_CLIENT_ID:keruta}
-# spring.security.oauth2.client.registration.keycloak.client-secret=${KEYCLOAK_CLIENT_SECRET:your-client-secret}
-# spring.security.oauth2.client.registration.keycloak.scope=${KEYCLOAK_SCOPE:openid,profile,email}
-# spring.security.oauth2.client.registration.keycloak.authorization-grant-type=${KEYCLOAK_GRANT_TYPE:authorization_code}
-# spring.security.oauth2.client.registration.keycloak.redirect-uri=${KEYCLOAK_REDIRECT_URI:{baseUrl}/login/oauth2/code/{registrationId}}
-#
-# spring.security.oauth2.client.provider.keycloak.issuer-uri=${KEYCLOAK_URL:http://localhost:8180}/realms/${KEYCLOAK_REALM:keruta}
-# spring.security.oauth2.client.provider.keycloak.user-name-attribute=${KEYCLOAK_USERNAME_ATTRIBUTE:preferred_username}
-#
-# keycloak.realm=${KEYCLOAK_REALM:keruta}
-# keycloak.auth-server-url=${KEYCLOAK_URL:http://localhost:8180}
-# keycloak.resource=${KEYCLOAK_CLIENT_ID:keruta}
-# keycloak.public-client=${KEYCLOAK_PUBLIC_CLIENT:true}
-# keycloak.principal-attribute=${KEYCLOAK_USERNAME_ATTRIBUTE:preferred_username}
-
-# Coder Configuration
-coder.base-url=${CODER_BASE_URL:http://localhost:3000}
-coder.session-token=${CODER_SESSION_TOKEN:}
-coder.organization=${CODER_ORGANIZATION:default}
-coder.user=${CODER_USER:admin}
-coder.default-template-id=${CODER_DEFAULT_TEMPLATE_ID:}
-coder.connection-timeout=${CODER_CONNECTION_TIMEOUT:10000}
-coder.read-timeout=${CODER_READ_TIMEOUT:30000}
-coder.enable-ssl-verification=${CODER_ENABLE_SSL_VERIFICATION:true}
-
-# Coder Template Preferences
-# Comma-separated list of keywords to search for in template names/descriptions
-# Templates are prioritized in the order specified
-coder.preferred-template-keywords=${CODER_PREFERRED_TEMPLATE_KEYWORDS:keruta-ubuntu,ubuntu,linux}
-
-# Coder Template Creation (for future use)
-coder.template-creation.enabled=${CODER_TEMPLATE_CREATION_ENABLED:false}
-coder.template-creation.template-name=${CODER_TEMPLATE_NAME:keruta-ubuntu}
-coder.template-creation.display-name=${CODER_TEMPLATE_DISPLAY_NAME:Keruta Ubuntu Environment}
-coder.template-creation.description=${CODER_TEMPLATE_DESCRIPTION:Custom Ubuntu environment optimized for Keruta development tasks}
-coder.template-creation.icon-url=${CODER_TEMPLATE_ICON_URL:}
-coder.template-creation.default-ttl-ms=${CODER_TEMPLATE_DEFAULT_TTL_MS:3600000}
Index: keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/CoderTemplate.kt
===================================================================
diff --git a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/CoderTemplate.kt b/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/CoderTemplate.kt
deleted file mode 100644
--- a/keruta-api/core/domain/src/main/kotlin/net/kigawa/keruta/core/domain/model/CoderTemplate.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,24 +0,0 @@
-package net.kigawa.keruta.core.domain.model
-
-import java.time.LocalDateTime
-
-/**
- * Represents a Coder template fetched from the Coder server.
- */
-data class CoderTemplate(
-    val id: String,
-    val name: String,
-    val displayName: String,
-    val description: String,
-    val icon: String,
-    val defaultTtlMs: Long,
-    val maxTtlMs: Long,
-    val minAutostartIntervalMs: Long,
-    val createdByName: String,
-    val updatedAt: LocalDateTime,
-    val organizationId: String,
-    val provisioner: String,
-    val activeVersionId: String,
-    val workspaceCount: Int,
-    val deprecated: Boolean = false,
-)
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/executor/ExecutorClient.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/executor/ExecutorClient.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/executor/ExecutorClient.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/executor/ExecutorClient.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,18 +0,0 @@
-package net.kigawa.keruta.core.usecase.executor
-
-import net.kigawa.keruta.core.domain.model.CoderTemplate
-
-/**
- * Interface for communicating with keruta-executor service.
- */
-interface ExecutorClient {
-    /**
-     * Fetches Coder templates from the executor service.
-     */
-    fun getCoderTemplates(): List<CoderTemplate>
-
-    /**
-     * Fetches a specific Coder template from the executor service.
-     */
-    fun getCoderTemplate(id: String): CoderTemplate?
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoDocumentRepository.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoDocumentRepository.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoDocumentRepository.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoDocumentRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,29 +0,0 @@
-/**
- * Spring Data MongoDB repository for DocumentEntity.
- */
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.infra.persistence.entity.DocumentEntity
-import org.springframework.data.mongodb.repository.MongoRepository
-import org.springframework.data.mongodb.repository.Query
-import org.springframework.stereotype.Repository
-
-@Repository
-interface MongoDocumentRepository : MongoRepository<DocumentEntity, String> {
-    /**
-     * Finds documents by tag.
-     *
-     * @param tag The tag to filter by
-     * @return List of documents with the specified tag
-     */
-    fun findByTagsContaining(tag: String): List<DocumentEntity>
-
-    /**
-     * Searches for documents by title or content.
-     *
-     * @param query The search query
-     * @return List of documents matching the query
-     */
-    @Query("{ \$or: [ { 'title': { \$regex: ?0, \$options: 'i' } }, { 'content': { \$regex: ?0, \$options: 'i' } } ] }")
-    fun search(query: String): List<DocumentEntity>
-}
Index: keruta-api/api/src/main/main4.iml
===================================================================
diff --git a/keruta-api/api/src/main/main4.iml b/keruta-api/api/src/main/main4.iml
deleted file mode 100644
--- a/keruta-api/api/src/main/main4.iml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/kotlin" isTestSource="false" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/jwt/JwtTokenProvider.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/jwt/JwtTokenProvider.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/jwt/JwtTokenProvider.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/jwt/JwtTokenProvider.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,198 +0,0 @@
-/**
- * Provider for JWT token generation and validation.
- * This component handles all JWT token operations, including creation,
- * validation, and extraction of authentication information.
- */
-package net.kigawa.keruta.infra.security.jwt
-
-import io.jsonwebtoken.Claims
-import io.jsonwebtoken.ExpiredJwtException
-import io.jsonwebtoken.Jwts
-import io.jsonwebtoken.MalformedJwtException
-import io.jsonwebtoken.SignatureAlgorithm
-import io.jsonwebtoken.SignatureException
-import io.jsonwebtoken.UnsupportedJwtException
-import io.jsonwebtoken.security.Keys
-import org.slf4j.LoggerFactory
-import org.springframework.beans.factory.annotation.Value
-import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
-import org.springframework.security.core.Authentication
-import org.springframework.security.core.userdetails.UserDetailsService
-import org.springframework.stereotype.Component
-import java.util.*
-import javax.crypto.SecretKey
-
-@Component
-class JwtTokenProvider(
-    private val userDetailsService: UserDetailsService,
-) {
-    private val logger = LoggerFactory.getLogger(JwtTokenProvider::class.java)
-
-    @Value("\${jwt.secret:your-secret-key-here-should-be-very-long-and-secure}")
-    private lateinit var secretString: String
-
-    @Value("\${jwt.expiration:86400000}")
-    private var validityInMilliseconds: Long = 0 // 24h by default
-
-    @Value("\${jwt.refresh-expiration:604800000}")
-    private var refreshValidityInMilliseconds: Long = 0 // 7 days by default
-
-    private val secretKey: SecretKey by lazy {
-        Keys.hmacShaKeyFor(secretString.toByteArray())
-    }
-
-    /**
-     * Creates a JWT token for the given authentication.
-     *
-     * @param authentication The authentication object
-     * @return The JWT token
-     */
-    fun createToken(authentication: Authentication): String {
-        val username = authentication.name
-        val now = Date()
-        val validity = Date(now.time + validityInMilliseconds)
-
-        logger.debug("Creating JWT token for user: $username, valid until: $validity")
-
-        return Jwts.builder()
-            .setSubject(username)
-            .setIssuedAt(now)
-            .setExpiration(validity)
-            .signWith(secretKey, SignatureAlgorithm.HS256)
-            .compact().also {
-                logger.debug("JWT token created successfully for user: $username")
-            }
-    }
-
-    /**
-     * Creates a refresh token for the given authentication.
-     *
-     * @param authentication The authentication object
-     * @return The refresh token
-     */
-    fun createRefreshToken(authentication: Authentication): String {
-        val username = authentication.name
-        val now = Date()
-        val validity = Date(now.time + refreshValidityInMilliseconds)
-
-        logger.debug("Creating refresh token for user: $username, valid until: $validity")
-
-        return Jwts.builder()
-            .setSubject(username)
-            .setIssuedAt(now)
-            .setExpiration(validity)
-            .claim("refresh", true)
-            .signWith(secretKey, SignatureAlgorithm.HS256)
-            .compact().also {
-                logger.debug("Refresh token created successfully for user: $username")
-            }
-    }
-
-    /**
-     * Gets the authentication from a JWT token.
-     *
-     * @param token The JWT token
-     * @return The authentication object
-     */
-    fun getAuthentication(token: String): Authentication {
-        logger.debug("Getting authentication from JWT token")
-
-        val claims = getClaims(token)
-        val username = claims.subject
-        logger.debug("JWT token subject: $username")
-
-        val userDetails = userDetailsService.loadUserByUsername(username)
-        logger.debug("User details loaded for user: $username, authorities: ${userDetails.authorities}")
-
-        return UsernamePasswordAuthenticationToken(userDetails, "", userDetails.authorities).also {
-            logger.debug("Authentication created for user: $username with authorities: ${it.authorities}")
-        }
-    }
-
-    /**
-     * Validates a JWT token.
-     *
-     * @param token The JWT token
-     * @return true if the token is valid, false otherwise
-     */
-    fun validateToken(token: String): Boolean {
-        logger.debug("Validating JWT token")
-
-        return try {
-            val claims = getClaims(token)
-            val isValid = !claims.expiration.before(Date())
-
-            if (isValid) {
-                logger.debug("JWT token is valid, subject: ${claims.subject}, expiration: ${claims.expiration}")
-            } else {
-                logger.warn("JWT token is expired, subject: ${claims.subject}, expiration: ${claims.expiration}")
-            }
-
-            isValid
-        } catch (e: ExpiredJwtException) {
-            logger.warn("JWT token is expired: ${e.message}")
-            false
-        } catch (e: UnsupportedJwtException) {
-            logger.warn("JWT token is unsupported: ${e.message}")
-            false
-        } catch (e: MalformedJwtException) {
-            logger.warn("JWT token is malformed: ${e.message}")
-            false
-        } catch (e: SignatureException) {
-            logger.warn("JWT token has invalid signature: ${e.message}")
-            false
-        } catch (e: Exception) {
-            logger.error("JWT token validation error", e)
-            false
-        }
-    }
-
-    /**
-     * Gets the claims from a JWT token.
-     *
-     * @param token The JWT token
-     * @return The claims
-     */
-    private fun getClaims(token: String): Claims {
-        logger.debug("Parsing JWT token to extract claims")
-
-        return try {
-            Jwts.parserBuilder()
-                .setSigningKey(secretKey)
-                .build()
-                .parseClaimsJws(token)
-                .body.also {
-                    logger.debug(
-                        "JWT claims extracted successfully: subject=${it.subject}, expiration=${it.expiration}",
-                    )
-                }
-        } catch (e: Exception) {
-            logger.error("Failed to parse JWT token", e)
-            throw e
-        }
-    }
-
-    /**
-     * Creates a JWT token for API access.
-     * This method doesn't require an Authentication object and is useful for system-generated tokens.
-     *
-     * @param subject The subject of the token (usually a username or identifier)
-     * @return The JWT token
-     */
-    fun createApiToken(subject: String): String {
-        val now = Date()
-        val validity = Date(now.time + validityInMilliseconds)
-
-        logger.debug("Creating API token for subject: $subject, valid until: $validity")
-
-        return Jwts.builder()
-            .setSubject(subject)
-            .setIssuedAt(now)
-            .setExpiration(validity)
-            .claim("type", "api")
-            .signWith(secretKey, SignatureAlgorithm.HS256)
-            .compact().also {
-                logger.debug("API token created successfully for subject: $subject")
-            }
-    }
-}
Index: keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/executor/ExecutorClient.kt
===================================================================
diff --git a/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/executor/ExecutorClient.kt b/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/executor/ExecutorClient.kt
deleted file mode 100644
--- a/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/executor/ExecutorClient.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,103 +0,0 @@
-package net.kigawa.keruta.infra.app.executor
-
-import net.kigawa.keruta.core.domain.model.CoderTemplate
-import org.slf4j.LoggerFactory
-import org.springframework.beans.factory.annotation.Value
-import org.springframework.core.ParameterizedTypeReference
-import org.springframework.http.HttpMethod
-import org.springframework.stereotype.Component
-import org.springframework.web.client.RestTemplate
-import java.time.LocalDateTime
-
-/**
- * Client for communicating with keruta-executor service.
- */
-@Component
-class ExecutorClientImpl(
-    private val restTemplate: RestTemplate,
-    @Value("\${keruta.executor.base-url:http://localhost:8081}")
-    private val executorBaseUrl: String,
-) : net.kigawa.keruta.core.usecase.executor.ExecutorClient {
-    private val logger = LoggerFactory.getLogger(ExecutorClientImpl::class.java)
-
-    /**
-     * Fetches Coder templates from the executor service.
-     */
-    override fun getCoderTemplates(): List<CoderTemplate> {
-        logger.info("Fetching Coder templates from executor: $executorBaseUrl")
-
-        return try {
-            val url = "$executorBaseUrl/api/v1/coder/templates"
-            val typeReference = object : ParameterizedTypeReference<List<ExecutorCoderTemplateDto>>() {}
-            val response = restTemplate.exchange(url, HttpMethod.GET, null, typeReference)
-
-            val templates = response.body ?: emptyList()
-            logger.info("Successfully fetched {} Coder templates from executor", templates.size)
-
-            templates.map { it.toDomain() }
-        } catch (e: Exception) {
-            logger.error("Failed to fetch Coder templates from executor", e)
-            emptyList()
-        }
-    }
-
-    /**
-     * Fetches a specific Coder template from the executor service.
-     */
-    override fun getCoderTemplate(id: String): CoderTemplate? {
-        logger.info("Fetching Coder template from executor: $executorBaseUrl, id: $id")
-
-        return try {
-            val url = "$executorBaseUrl/api/v1/coder/templates/$id"
-            val response = restTemplate.getForObject(url, ExecutorCoderTemplateDto::class.java)
-
-            response?.toDomain()?.also {
-                logger.info("Successfully fetched Coder template from executor: $id")
-            }
-        } catch (e: Exception) {
-            logger.error("Failed to fetch Coder template from executor: $id", e)
-            null
-        }
-    }
-}
-
-/**
- * DTO for Coder template data from executor.
- */
-data class ExecutorCoderTemplateDto(
-    val id: String,
-    val name: String,
-    val displayName: String,
-    val description: String,
-    val icon: String,
-    val defaultTtlMs: Long,
-    val maxTtlMs: Long,
-    val minAutostartIntervalMs: Long,
-    val createdByName: String,
-    val updatedAt: LocalDateTime,
-    val organizationId: String,
-    val provisioner: String,
-    val activeVersionId: String,
-    val workspaceCount: Int,
-    val deprecated: Boolean = false,
-) {
-    fun toDomain(): CoderTemplate {
-        return CoderTemplate(
-            id = id,
-            name = name,
-            displayName = displayName,
-            description = description,
-            icon = icon,
-            defaultTtlMs = defaultTtlMs,
-            maxTtlMs = maxTtlMs,
-            minAutostartIntervalMs = minAutostartIntervalMs,
-            createdByName = createdByName,
-            updatedAt = updatedAt,
-            organizationId = organizationId,
-            provisioner = provisioner,
-            activeVersionId = activeVersionId,
-            workspaceCount = workspaceCount,
-            deprecated = deprecated,
-        )
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/SessionRepository.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/SessionRepository.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/SessionRepository.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/SessionRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,64 +0,0 @@
-/**
- * Repository interface for Session entity operations.
- */
-package net.kigawa.keruta.core.usecase.repository
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionStatus
-
-interface SessionRepository {
-    /**
-     * Finds all sessions in the system.
-     *
-     * @return List of all sessions
-     */
-    suspend fun findAll(): List<Session>
-
-    /**
-     * Finds a session by its ID.
-     *
-     * @param id The ID of the session to find
-     * @return The session if found, null otherwise
-     */
-    suspend fun findById(id: String): Session?
-
-    /**
-     * Saves a session to the repository.
-     *
-     * @param session The session to save
-     * @return The saved session with generated ID if it was a new session
-     */
-    suspend fun save(session: Session): Session
-
-    /**
-     * Deletes a session by its ID.
-     *
-     * @param id The ID of the session to delete
-     * @return true if the session was deleted, false otherwise
-     */
-    suspend fun deleteById(id: String): Boolean
-
-    /**
-     * Finds sessions by their status.
-     *
-     * @param status The status to filter by
-     * @return List of sessions with the specified status
-     */
-    suspend fun findByStatus(status: SessionStatus): List<Session>
-
-    /**
-     * Finds sessions by name containing the specified string.
-     *
-     * @param name The name pattern to search for
-     * @return List of sessions with names containing the specified string
-     */
-    suspend fun findByNameContaining(name: String): List<Session>
-
-    /**
-     * Finds sessions by tag.
-     *
-     * @param tag The tag to filter by
-     * @return List of sessions with the specified tag
-     */
-    suspend fun findByTag(tag: String): List<Session>
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/template/controller/TemplateController.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/template/controller/TemplateController.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/template/controller/TemplateController.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/template/controller/TemplateController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,350 +0,0 @@
-package net.kigawa.keruta.api.template.controller
-
-import io.swagger.v3.oas.annotations.Operation
-import io.swagger.v3.oas.annotations.tags.Tag
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.*
-import java.io.File
-import java.nio.file.Files
-import java.time.LocalDateTime
-import java.time.format.DateTimeFormatter
-import java.util.*
-
-@RestController
-@RequestMapping("/api/v1/templates")
-@Tag(name = "Template", description = "Coder template management API")
-class TemplateController {
-
-    data class Template(
-        val id: String,
-        val name: String,
-        val description: String,
-        val path: String,
-        val content: String,
-        val lastModified: String,
-        val status: String = "active",
-    )
-
-    data class CreateTemplateRequest(
-        val name: String,
-        val description: String,
-        val content: String,
-    )
-
-    data class UpdateTemplateRequest(
-        val name: String?,
-        val description: String?,
-        val content: String?,
-    )
-
-    data class ValidateTemplateRequest(
-        val content: String,
-    )
-
-    data class ValidateTemplateResponse(
-        val isValid: Boolean,
-        val errors: List<String> = emptyList(),
-        val warnings: List<String> = emptyList(),
-    )
-
-    data class TemplateContentResponse(
-        val content: String,
-    )
-
-    data class UpdateTemplateContentRequest(
-        val content: String,
-    )
-
-    data class UpdateTemplateContentResponse(
-        val success: Boolean,
-    )
-
-    private val templatesBasePath = "./terraform-templates"
-
-    @GetMapping
-    @Operation(summary = "Get all templates", description = "Retrieves a list of all Terraform templates")
-    fun getAllTemplates(): List<Template> {
-        val templates = mutableListOf<Template>()
-
-        try {
-            val templatesDir = File(templatesBasePath)
-            if (!templatesDir.exists()) {
-                templatesDir.mkdirs()
-            }
-
-            templatesDir.listFiles { file -> file.isDirectory }?.forEach { templateDir ->
-                val mainTfFile = File(templateDir, "main.tf")
-                if (mainTfFile.exists()) {
-                    val content = mainTfFile.readText()
-                    val lastModified = Files.getLastModifiedTime(mainTfFile.toPath())
-                        .toInstant()
-                        .atZone(java.time.ZoneId.systemDefault())
-                        .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
-
-                    templates.add(
-                        Template(
-                            id = templateDir.name,
-                            name = templateDir.name,
-                            description = extractDescription(content),
-                            path = mainTfFile.absolutePath,
-                            content = content,
-                            lastModified = lastModified,
-                            status = if (isValidTerraform(content)) "active" else "error",
-                        ),
-                    )
-                }
-            }
-        } catch (e: Exception) {
-            // ログ出力（実際の実装では適切なロギングフレームワークを使用）
-            println("Error reading templates: ${e.message}")
-        }
-
-        return templates
-    }
-
-    @GetMapping("/{id}")
-    @Operation(summary = "Get template by ID", description = "Retrieves a specific template by its ID")
-    fun getTemplateById(@PathVariable id: String): ResponseEntity<Template> {
-        val templateDir = File(templatesBasePath, id)
-        val mainTfFile = File(templateDir, "main.tf")
-
-        if (!mainTfFile.exists()) {
-            return ResponseEntity.notFound().build()
-        }
-
-        return try {
-            val content = mainTfFile.readText()
-            val lastModified = Files.getLastModifiedTime(mainTfFile.toPath())
-                .toInstant()
-                .atZone(java.time.ZoneId.systemDefault())
-                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
-
-            val template = Template(
-                id = id,
-                name = id,
-                description = extractDescription(content),
-                path = mainTfFile.absolutePath,
-                content = content,
-                lastModified = lastModified,
-                status = if (isValidTerraform(content)) "active" else "error",
-            )
-            ResponseEntity.ok(template)
-        } catch (e: Exception) {
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping
-    @Operation(summary = "Create a new template", description = "Creates a new Terraform template")
-    fun createTemplate(@RequestBody request: CreateTemplateRequest): ResponseEntity<Template> {
-        val templateId = generateTemplateId(request.name)
-        val templateDir = File(templatesBasePath, templateId)
-        val mainTfFile = File(templateDir, "main.tf")
-
-        return try {
-            templateDir.mkdirs()
-            mainTfFile.writeText(request.content)
-
-            val template = Template(
-                id = templateId,
-                name = request.name,
-                description = request.description,
-                path = mainTfFile.absolutePath,
-                content = request.content,
-                lastModified = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")),
-                status = if (isValidTerraform(request.content)) "active" else "error",
-            )
-            ResponseEntity.ok(template)
-        } catch (e: Exception) {
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PutMapping("/{id}")
-    @Operation(summary = "Update template", description = "Updates an existing template")
-    fun updateTemplate(
-        @PathVariable id: String,
-        @RequestBody request: UpdateTemplateRequest,
-    ): ResponseEntity<Template> {
-        val templateDir = File(templatesBasePath, id)
-        val mainTfFile = File(templateDir, "main.tf")
-
-        if (!mainTfFile.exists()) {
-            return ResponseEntity.notFound().build()
-        }
-
-        return try {
-            if (request.content != null) {
-                mainTfFile.writeText(request.content)
-            }
-
-            val content = mainTfFile.readText()
-            val template = Template(
-                id = id,
-                name = request.name ?: id,
-                description = request.description ?: extractDescription(content),
-                path = mainTfFile.absolutePath,
-                content = content,
-                lastModified = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")),
-                status = if (isValidTerraform(content)) "active" else "error",
-            )
-            ResponseEntity.ok(template)
-        } catch (e: Exception) {
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @DeleteMapping("/{id}")
-    @Operation(summary = "Delete template", description = "Deletes a template by its ID")
-    fun deleteTemplate(@PathVariable id: String): ResponseEntity<Void> {
-        val templateDir = File(templatesBasePath, id)
-
-        return if (templateDir.exists() && templateDir.isDirectory) {
-            try {
-                templateDir.deleteRecursively()
-                ResponseEntity.noContent().build()
-            } catch (e: Exception) {
-                ResponseEntity.internalServerError().build()
-            }
-        } else {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @PostMapping("/{id}/validate")
-    @Operation(summary = "Validate template", description = "Validates the Terraform syntax of a template")
-    fun validateTemplate(
-        @PathVariable id: String,
-        @RequestBody request: ValidateTemplateRequest,
-    ): ResponseEntity<ValidateTemplateResponse> {
-        val errors = mutableListOf<String>()
-        val warnings = mutableListOf<String>()
-
-        // 基本的な構文チェック
-        val content = request.content
-
-        if (!content.contains("terraform {")) {
-            errors.add("terraform {} ブロックが見つかりません")
-        }
-
-        if (!content.contains("required_providers")) {
-            warnings.add("required_providers の指定を推奨します")
-        }
-
-        if (!content.contains("data \"coder_workspace\"") && !content.contains("data \"coder_provisioner\"")) {
-            warnings.add("Coderデータソースの使用を推奨します")
-        }
-
-        val response = ValidateTemplateResponse(
-            isValid = errors.isEmpty(),
-            errors = errors,
-            warnings = warnings,
-        )
-
-        return ResponseEntity.ok(response)
-    }
-
-    @PostMapping("/{id}/deploy")
-    @Operation(summary = "Deploy template to Coder", description = "Deploys the template to Coder server")
-    fun deployToCoder(@PathVariable id: String): ResponseEntity<Map<String, String>> {
-        // TODO: 実際のCoderサーバーとの連携を実装
-        return ResponseEntity.ok(
-            mapOf(
-                "status" to "success",
-                "message" to "テンプレートの登録機能は未実装です",
-            ),
-        )
-    }
-
-    @GetMapping("/content")
-    @Operation(summary = "Get template content by path", description = "Retrieves template content by file path")
-    fun getTemplateContent(@RequestParam path: String): ResponseEntity<TemplateContentResponse> {
-        return try {
-            // パス正規化: 絶対パスが渡された場合は相対パスに変換
-            val normalizedPath = if (path.startsWith("/")) {
-                // 絶対パスの場合、先頭の / を除去して相対パスとして扱う
-                ".$path"
-            } else if (!path.startsWith("./")) {
-                // 相対パスの場合、./ プレフィックスを追加
-                "./$path"
-            } else {
-                path
-            }
-
-            val file = File(normalizedPath)
-            if (!file.exists() || !file.isFile) {
-                return ResponseEntity.notFound().build()
-            }
-
-            // セキュリティチェック: テンプレートベースパス配下のファイルのみ許可
-            val canonicalPath = file.canonicalPath
-            val basePath = File(templatesBasePath).canonicalPath
-            if (!canonicalPath.startsWith(basePath)) {
-                return ResponseEntity.badRequest().build()
-            }
-
-            val content = file.readText()
-            ResponseEntity.ok(TemplateContentResponse(content))
-        } catch (e: Exception) {
-            println("Error reading template content: ${e.message}")
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PutMapping("/content")
-    @Operation(summary = "Update template content by path", description = "Updates template content by file path")
-    fun updateTemplateContent(
-        @RequestParam path: String,
-        @RequestBody request: UpdateTemplateContentRequest,
-    ): ResponseEntity<UpdateTemplateContentResponse> {
-        return try {
-            // パス正規化: 絶対パスが渡された場合は相対パスに変換
-            val normalizedPath = if (path.startsWith("/")) {
-                // 絶対パスの場合、先頭の / を除去して相対パスとして扱う
-                ".$path"
-            } else if (!path.startsWith("./")) {
-                // 相対パスの場合、./ プレフィックスを追加
-                "./$path"
-            } else {
-                path
-            }
-
-            val file = File(normalizedPath)
-
-            // セキュリティチェック: テンプレートベースパス配下のファイルのみ許可
-            val canonicalPath = file.canonicalPath
-            val basePath = File(templatesBasePath).canonicalPath
-            if (!canonicalPath.startsWith(basePath)) {
-                return ResponseEntity.badRequest().build()
-            }
-
-            // ディレクトリが存在しない場合は作成
-            file.parentFile?.mkdirs()
-
-            file.writeText(request.content)
-            ResponseEntity.ok(UpdateTemplateContentResponse(success = true))
-        } catch (e: Exception) {
-            println("Error updating template content: ${e.message}")
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    private fun extractDescription(content: String): String {
-        // コメントから説明を抽出（簡易実装）
-        val lines = content.lines()
-        val descriptionLine = lines.find { it.trim().startsWith("# ") && it.contains("description") }
-        return descriptionLine?.substring(descriptionLine.indexOf("#") + 1)?.trim()
-            ?: "Terraformテンプレート"
-    }
-
-    private fun isValidTerraform(content: String): Boolean {
-        return content.contains("terraform {") &&
-            content.contains("required_providers")
-    }
-
-    private fun generateTemplateId(name: String): String {
-        return name.lowercase()
-            .replace(Regex("[^a-z0-9]+"), "-")
-            .trim('-')
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoWorkspaceTemplateRepository.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoWorkspaceTemplateRepository.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoWorkspaceTemplateRepository.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoWorkspaceTemplateRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,30 +0,0 @@
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.infra.persistence.entity.WorkspaceTemplateEntity
-import org.springframework.data.mongodb.repository.MongoRepository
-import org.springframework.data.mongodb.repository.Query
-import org.springframework.stereotype.Repository
-
-/**
- * MongoDB repository for workspace template entities.
- */
-@Repository
-interface MongoWorkspaceTemplateRepository : MongoRepository<WorkspaceTemplateEntity, String> {
-
-    fun findByName(name: String): WorkspaceTemplateEntity?
-
-    fun findByNameContainingIgnoreCase(name: String): List<WorkspaceTemplateEntity>
-
-    fun existsByName(name: String): Boolean
-
-    @Query("{ 'isDefault': true }")
-    fun findDefaultTemplates(): List<WorkspaceTemplateEntity>
-
-    fun findFirstByIsDefaultTrue(): WorkspaceTemplateEntity?
-
-    @Query("{ 'version': ?0 }")
-    fun findByVersion(version: String): List<WorkspaceTemplateEntity>
-
-    @Query("{ 'name': ?0, 'version': ?1 }")
-    fun findByNameAndVersion(name: String, version: String): WorkspaceTemplateEntity?
-}
Index: keruta-api/infra/security/src/test/kotlin/net/kigawa/keruta/infra/security/service/UserServiceTest.kt
===================================================================
diff --git a/keruta-api/infra/security/src/test/kotlin/net/kigawa/keruta/infra/security/service/UserServiceTest.kt b/keruta-api/infra/security/src/test/kotlin/net/kigawa/keruta/infra/security/service/UserServiceTest.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/test/kotlin/net/kigawa/keruta/infra/security/service/UserServiceTest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,90 +0,0 @@
-package net.kigawa.keruta.infra.security.service
-
-import org.junit.jupiter.api.Assertions.assertEquals
-import org.junit.jupiter.api.Assertions.assertNotNull
-import org.junit.jupiter.api.Assertions.assertTrue
-import org.junit.jupiter.api.Test
-import org.junit.jupiter.api.extension.ExtendWith
-import org.mockito.InjectMocks
-import org.mockito.Mock
-import org.mockito.Mockito.`when`
-import org.mockito.junit.jupiter.MockitoExtension
-import org.springframework.security.core.userdetails.UsernameNotFoundException
-import org.springframework.security.crypto.password.PasswordEncoder
-import org.springframework.test.util.ReflectionTestUtils
-
-@ExtendWith(MockitoExtension::class)
-class UserServiceTest {
-
-    @Mock
-    private lateinit var passwordEncoder: PasswordEncoder
-
-    @InjectMocks
-    private lateinit var userService: UserService
-
-    @Test
-    fun `should load admin user successfully`() {
-        // Given
-        ReflectionTestUtils.setField(userService, "adminUsername", "admin")
-        ReflectionTestUtils.setField(userService, "adminPassword", "password")
-        ReflectionTestUtils.setField(userService, "apiUsername", "keruta-api")
-        ReflectionTestUtils.setField(userService, "apiPassword", "api-password")
-
-        `when`(passwordEncoder.encode("password")).thenReturn("encoded-password")
-        `when`(passwordEncoder.encode("api-password")).thenReturn("encoded-api-password")
-
-        // When
-        userService.init() // Manually call init to set up users
-        val user = userService.loadUserByUsername("admin")
-
-        // Then
-        assertNotNull(user)
-        assertEquals("admin", user.username)
-        assertEquals("encoded-password", user.password)
-        assertTrue(user.authorities.any { it.authority == "ROLE_ADMIN" })
-    }
-
-    @Test
-    fun `should load api user successfully`() {
-        // Given
-        ReflectionTestUtils.setField(userService, "adminUsername", "admin")
-        ReflectionTestUtils.setField(userService, "adminPassword", "password")
-        ReflectionTestUtils.setField(userService, "apiUsername", "keruta-api")
-        ReflectionTestUtils.setField(userService, "apiPassword", "api-password")
-
-        `when`(passwordEncoder.encode("password")).thenReturn("encoded-password")
-        `when`(passwordEncoder.encode("api-password")).thenReturn("encoded-api-password")
-
-        // When
-        userService.init() // Manually call init to set up users
-        val user = userService.loadUserByUsername("keruta-api")
-
-        // Then
-        assertNotNull(user)
-        assertEquals("keruta-api", user.username)
-        assertEquals("encoded-api-password", user.password)
-        assertTrue(user.authorities.any { it.authority == "ROLE_API" })
-    }
-
-    @Test
-    fun `should throw exception when user not found`() {
-        // Given
-        ReflectionTestUtils.setField(userService, "adminUsername", "admin")
-        ReflectionTestUtils.setField(userService, "adminPassword", "password")
-        ReflectionTestUtils.setField(userService, "apiUsername", "keruta-api")
-        ReflectionTestUtils.setField(userService, "apiPassword", "api-password")
-
-        `when`(passwordEncoder.encode("password")).thenReturn("encoded-password")
-        `when`(passwordEncoder.encode("api-password")).thenReturn("encoded-api-password")
-
-        // When/Then
-        userService.init() // Manually call init to set up users
-
-        try {
-            userService.loadUserByUsername("non-existent-user")
-            throw AssertionError("Expected UsernameNotFoundException was not thrown")
-        } catch (e: UsernameNotFoundException) {
-            assertEquals("User not found: non-existent-user", e.message)
-        }
-    }
-}
Index: keruta-api/infra/core/build.gradle.kts
===================================================================
diff --git a/keruta-api/infra/core/build.gradle.kts b/keruta-api/infra/core/build.gradle.kts
deleted file mode 100644
--- a/keruta-api/infra/core/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,28 +0,0 @@
-plugins {
-    kotlin("jvm")
-    kotlin("plugin.spring")
-    id("org.springframework.boot")
-}
-
-tasks.bootJar {
-    enabled = false
-}
-
-tasks.bootRun {
-    enabled = false
-}
-
-dependencies {
-    implementation(project(":core:domain"))
-    implementation(project(":core:usecase"))
-
-    implementation(Dependencies.kotlinStdlib)
-    implementation(Dependencies.kotlinReflect)
-    implementation(Dependencies.springBootStarter)
-
-    // Coroutines
-    implementation(Dependencies.kotlinxCoroutinesCore)
-    implementation(Dependencies.kotlinxCoroutinesReactor)
-
-    testImplementation(Dependencies.springBootStarterTest)
-}
Index: keruta-api/infra/app/build.gradle.kts
===================================================================
diff --git a/keruta-api/infra/app/build.gradle.kts b/keruta-api/infra/app/build.gradle.kts
deleted file mode 100644
--- a/keruta-api/infra/app/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,30 +0,0 @@
-plugins {
-    kotlin("jvm")
-    kotlin("plugin.spring")
-    id("org.springframework.boot")
-}
-
-tasks.bootJar {
-    enabled = false
-}
-
-dependencies {
-    implementation(project(":core:domain"))
-    implementation(project(":core:usecase"))
-    implementation(project(":infra:persistence"))
-    implementation(project(":infra:security"))
-
-    implementation(Dependencies.kotlinStdlib)
-    implementation(Dependencies.kotlinReflect)
-    implementation(Dependencies.springBootStarter)
-    implementation(Dependencies.springBootStarterWeb)
-
-    // Swagger/OpenAPI
-    implementation(Dependencies.springdocOpenApi)
-
-    // Kubernetes
-    implementation(Dependencies.fabric8KubernetesClient)
-
-    testImplementation(Dependencies.springBootStarterTest)
-    testImplementation(Dependencies.mockitoKotlin)
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/controller/SessionController.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/controller/SessionController.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/controller/SessionController.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/controller/SessionController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,239 +0,0 @@
-package net.kigawa.keruta.api.session.controller
-
-import io.swagger.v3.oas.annotations.Operation
-import io.swagger.v3.oas.annotations.tags.Tag
-import net.kigawa.keruta.api.session.dto.CreateSessionRequest
-import net.kigawa.keruta.api.session.dto.SessionResponse
-import net.kigawa.keruta.api.session.dto.UpdateSessionRequest
-import net.kigawa.keruta.api.workspace.dto.WorkspaceResponse
-import net.kigawa.keruta.core.usecase.session.SessionService
-import net.kigawa.keruta.core.usecase.session.SessionServiceImpl
-import net.kigawa.keruta.core.usecase.session.SessionWorkspaceStatusSyncService
-import org.slf4j.LoggerFactory
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.*
-
-@RestController
-@RequestMapping("/api/v1/sessions")
-@Tag(name = "Session", description = "Session management API")
-class SessionController(
-    private val sessionService: SessionService,
-    private val sessionServiceImpl: SessionServiceImpl,
-    private val sessionWorkspaceStatusSyncService: SessionWorkspaceStatusSyncService,
-) {
-    private val logger = LoggerFactory.getLogger(this::class.java)
-
-    @PostMapping
-    @Operation(summary = "Create a new session", description = "Creates a new session in the system")
-    suspend fun createSession(@RequestBody request: CreateSessionRequest): ResponseEntity<SessionResponse> {
-        logger.info("Creating new session: {}", request)
-        try {
-            val session = request.toDomain()
-            val createdSession = sessionService.createSession(session)
-            logger.info("Session created successfully: id={}", createdSession.id)
-            return ResponseEntity.ok(SessionResponse.fromDomain(createdSession))
-        } catch (e: Exception) {
-            logger.error("Failed to create session", e)
-            return ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @GetMapping
-    @Operation(summary = "Get all sessions", description = "Retrieves all sessions in the system")
-    suspend fun getAllSessions(): List<SessionResponse> {
-        return sessionService.getAllSessions().map { SessionResponse.fromDomain(it) }
-    }
-
-    @GetMapping("/{id}")
-    @Operation(summary = "Get session by ID", description = "Retrieves a specific session by its ID")
-    suspend fun getSessionById(@PathVariable id: String): ResponseEntity<SessionResponse> {
-        return try {
-            val session = sessionService.getSessionById(id)
-            val workspaces = sessionServiceImpl.getSessionWorkspaces(id)
-            ResponseEntity.ok(SessionResponse.fromDomain(session, workspaces))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @PutMapping("/{id}")
-    @Operation(summary = "Update session", description = "Updates an existing session")
-    suspend fun updateSession(
-        @PathVariable id: String,
-        @RequestBody request: UpdateSessionRequest,
-    ): ResponseEntity<SessionResponse> {
-        return try {
-            val session = request.toDomain(id)
-            val updatedSession = sessionService.updateSession(id, session)
-            ResponseEntity.ok(SessionResponse.fromDomain(updatedSession))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to update session", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @DeleteMapping("/{id}")
-    @Operation(summary = "Delete session", description = "Deletes a specific session")
-    suspend fun deleteSession(@PathVariable id: String): ResponseEntity<Void> {
-        return try {
-            sessionService.deleteSession(id)
-            ResponseEntity.noContent().build()
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @GetMapping("/status/{status}")
-    @Operation(summary = "Get sessions by status", description = "Retrieves all sessions with a specific status")
-    suspend fun getSessionsByStatus(@PathVariable status: String): List<SessionResponse> {
-        val sessionStatus = try {
-            net.kigawa.keruta.core.domain.model.SessionStatus.valueOf(status.uppercase())
-        } catch (e: IllegalArgumentException) {
-            return emptyList()
-        }
-        return sessionService.getSessionsByStatus(sessionStatus).map { SessionResponse.fromDomain(it) }
-    }
-
-    @GetMapping("/search")
-    @Operation(summary = "Search sessions by name", description = "Searches sessions by name pattern")
-    suspend fun searchSessionsByName(@RequestParam name: String): List<SessionResponse> {
-        return sessionService.searchSessionsByName(name).map { SessionResponse.fromDomain(it) }
-    }
-
-    @GetMapping("/tag/{tag}")
-    @Operation(summary = "Get sessions by tag", description = "Retrieves all sessions with a specific tag")
-    suspend fun getSessionsByTag(@PathVariable tag: String): List<SessionResponse> {
-        return sessionService.getSessionsByTag(tag).map { SessionResponse.fromDomain(it) }
-    }
-
-    @PutMapping("/{id}/status")
-    @Operation(summary = "Update session status", description = "Updates the status of a specific session")
-    suspend fun updateSessionStatus(
-        @PathVariable id: String,
-        @RequestBody statusRequest: Map<String, String>,
-    ): ResponseEntity<SessionResponse> {
-        logger.info("updateSessionStatus id={} status={}", id, statusRequest["status"])
-        val statusStr = statusRequest["status"] ?: return ResponseEntity.badRequest().build()
-
-        return try {
-            val sessionStatus = try {
-                net.kigawa.keruta.core.domain.model.SessionStatus.valueOf(statusStr.uppercase())
-            } catch (e: IllegalArgumentException) {
-                logger.error(
-                    "Invalid session status: {} for session: {}. Valid statuses are: {}",
-                    statusStr,
-                    id,
-                    net.kigawa.keruta.core.domain.model.SessionStatus.values().joinToString(", "),
-                    e,
-                )
-                return ResponseEntity.badRequest().build()
-            }
-
-            val updatedSession = sessionService.updateSessionStatus(id, sessionStatus)
-            logger.info("Session status updated successfully: id={} status={}", id, statusStr)
-            ResponseEntity.ok(SessionResponse.fromDomain(updatedSession))
-        } catch (e: NoSuchElementException) {
-            logger.error("Session not found: id={}", id, e)
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to update session status: id={} status={}", id, statusStr, e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/tags")
-    @Operation(summary = "Add tag to session", description = "Adds a tag to a specific session")
-    suspend fun addTagToSession(
-        @PathVariable id: String,
-        @RequestBody tagRequest: Map<String, String>,
-    ): ResponseEntity<SessionResponse> {
-        val tag = tagRequest["tag"] ?: return ResponseEntity.badRequest().build()
-        return try {
-            val updatedSession = sessionService.addTagToSession(id, tag)
-            ResponseEntity.ok(SessionResponse.fromDomain(updatedSession))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @DeleteMapping("/{id}/tags/{tag}")
-    @Operation(summary = "Remove tag from session", description = "Removes a tag from a specific session")
-    suspend fun removeTagFromSession(
-        @PathVariable id: String,
-        @PathVariable tag: String,
-    ): ResponseEntity<SessionResponse> {
-        return try {
-            val updatedSession = sessionService.removeTagFromSession(id, tag)
-            ResponseEntity.ok(SessionResponse.fromDomain(updatedSession))
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @GetMapping("/{id}/workspace")
-    @Operation(summary = "Get session workspace", description = "Gets the single workspace for a specific session")
-    suspend fun getSessionWorkspace(@PathVariable id: String): ResponseEntity<WorkspaceResponse> {
-        return try {
-            val workspace = sessionServiceImpl.getSessionWorkspace(id)
-            if (workspace != null) {
-                ResponseEntity.ok(WorkspaceResponse.fromDomain(workspace))
-            } else {
-                ResponseEntity.notFound().build()
-            }
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @PostMapping("/{id}/sync-status")
-    @Operation(summary = "Sync session status", description = "Synchronizes session status with workspace states")
-    suspend fun syncSessionStatus(@PathVariable id: String): ResponseEntity<SessionResponse> {
-        return try {
-            val success = sessionWorkspaceStatusSyncService.forceSyncSessionStatus(id)
-            if (success) {
-                val session = sessionService.getSessionById(id)
-                ResponseEntity.ok(SessionResponse.fromDomain(session))
-            } else {
-                ResponseEntity.internalServerError().build()
-            }
-        } catch (e: NoSuchElementException) {
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to sync session status", e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-
-    @PostMapping("/{id}/monitor-workspaces")
-    @Operation(
-        summary = "Monitor session workspaces",
-        description = "Stub: Workspace monitoring moved to keruta-executor",
-    )
-    suspend fun monitorSessionWorkspaces(@PathVariable id: String): ResponseEntity<Void> {
-        logger.info("Stub: Monitor workspaces for session $id - functionality moved to keruta-executor")
-        return ResponseEntity.ok().build()
-    }
-
-    @GetMapping("/by-workspace/{workspaceId}")
-    @Operation(
-        summary = "Get session by workspace ID",
-        description = "Retrieves a session by its associated workspace ID",
-    )
-    suspend fun getSessionByWorkspaceId(
-        @PathVariable workspaceId: String,
-    ): ResponseEntity<SessionResponse> {
-        return try {
-            val session = sessionServiceImpl.getSessionByWorkspaceId(workspaceId)
-            if (session != null) {
-                ResponseEntity.ok(SessionResponse.fromDomain(session))
-            } else {
-                ResponseEntity.notFound().build()
-            }
-        } catch (e: Exception) {
-            logger.error("Failed to get session by workspace ID: {}", workspaceId, e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionService.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionService.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionService.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionService.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,105 +0,0 @@
-/**
- * Service interface for Session operations.
- */
-package net.kigawa.keruta.core.usecase.session
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionStatus
-
-interface SessionService {
-    /**
-     * Gets all sessions.
-     *
-     * @return List of all sessions
-     */
-    suspend fun getAllSessions(): List<Session>
-
-    /**
-     * Gets a session by its ID.
-     *
-     * @param id The ID of the session to get
-     * @return The session if found
-     * @throws NoSuchElementException if the session is not found
-     */
-    suspend fun getSessionById(id: String): Session
-
-    /**
-     * Creates a new session.
-     *
-     * @param session The session to create
-     * @return The created session with generated ID
-     */
-    suspend fun createSession(session: Session): Session
-
-    /**
-     * Updates an existing session.
-     *
-     * @param id The ID of the session to update
-     * @param session The updated session data
-     * @return The updated session
-     * @throws NoSuchElementException if the session is not found
-     */
-    suspend fun updateSession(id: String, session: Session): Session
-
-    /**
-     * Deletes a session by its ID.
-     *
-     * @param id The ID of the session to delete
-     * @throws NoSuchElementException if the session is not found
-     */
-    suspend fun deleteSession(id: String)
-
-    /**
-     * Gets sessions by status.
-     *
-     * @param status The status to filter by
-     * @return List of sessions with the specified status
-     */
-    suspend fun getSessionsByStatus(status: SessionStatus): List<Session>
-
-    /**
-     * Searches sessions by name.
-     *
-     * @param name The name pattern to search for
-     * @return List of sessions with names containing the specified string
-     */
-    suspend fun searchSessionsByName(name: String): List<Session>
-
-    /**
-     * Gets sessions by tag.
-     *
-     * @param tag The tag to filter by
-     * @return List of sessions with the specified tag
-     */
-    suspend fun getSessionsByTag(tag: String): List<Session>
-
-    /**
-     * Updates the status of a session.
-     *
-     * @param id The ID of the session to update
-     * @param status The new status
-     * @return The updated session
-     * @throws NoSuchElementException if the session is not found
-     */
-    suspend fun updateSessionStatus(id: String, status: SessionStatus): Session
-
-    /**
-     * Adds a tag to a session.
-     *
-     * @param id The ID of the session
-     * @param tag The tag to add
-     * @return The updated session
-     * @throws NoSuchElementException if the session is not found
-     */
-    suspend fun addTagToSession(id: String, tag: String): Session
-
-    /**
-     * Removes a tag from a session.
-     *
-     * @param id The ID of the session
-     * @param tag The tag to remove
-     * @return The updated session
-     * @throws NoSuchElementException if the session is not found
-     */
-    suspend fun removeTagFromSession(id: String, tag: String): Session
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/JacksonConfig.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/JacksonConfig.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/JacksonConfig.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/JacksonConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,25 +0,0 @@
-package net.kigawa.keruta.infra.security.config
-
-import com.fasterxml.jackson.databind.ObjectMapper
-import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
-import com.fasterxml.jackson.module.kotlin.KotlinModule
-import org.springframework.context.annotation.Bean
-import org.springframework.context.annotation.Configuration
-
-/**
- * Configuration for Jackson ObjectMapper.
- */
-@Configuration
-class JacksonConfig {
-
-    /**
-     * Provides an ObjectMapper bean for JSON serialization/deserialization.
-     * Registers JavaTimeModule to handle Java 8 date/time types like LocalDateTime.
-     */
-    @Bean
-    fun objectMapper(): ObjectMapper {
-        return ObjectMapper()
-            .registerModule(JavaTimeModule())
-            .registerModule(KotlinModule.Builder().build())
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceServiceImpl.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceServiceImpl.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceServiceImpl.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceServiceImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,378 +0,0 @@
-package net.kigawa.keruta.core.usecase.workspace
-
-import net.kigawa.keruta.core.domain.model.CoderTemplate
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceBuildInfo
-import net.kigawa.keruta.core.domain.model.WorkspaceBuildStatus
-import net.kigawa.keruta.core.domain.model.WorkspaceResourceInfo
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplate
-import net.kigawa.keruta.core.usecase.repository.SessionRepository
-import net.kigawa.keruta.core.usecase.repository.WorkspaceRepository
-import net.kigawa.keruta.core.usecase.repository.WorkspaceTemplateRepository
-import org.slf4j.LoggerFactory
-import org.springframework.stereotype.Service
-import java.time.LocalDateTime
-import java.util.UUID
-
-/**
- * Service implementation for workspace operations.
- */
-@Service
-open class WorkspaceServiceImpl(
-    open val workspaceRepository: WorkspaceRepository,
-    open val workspaceTemplateRepository: WorkspaceTemplateRepository,
-    open val sessionRepository: SessionRepository,
-    open val workspaceOrchestrator: WorkspaceOrchestrator,
-) : WorkspaceService {
-    open val logger = LoggerFactory.getLogger(WorkspaceServiceImpl::class.java)
-
-    override suspend fun createWorkspace(request: CreateWorkspaceRequest): Workspace {
-        logger.info("Creating workspace: ${request.name} for session: ${request.sessionId}")
-
-        // Validate session exists
-        val session = sessionRepository.findById(request.sessionId)
-            ?: throw IllegalArgumentException("Session not found: ${request.sessionId}")
-
-        // Validate that session doesn't already have an active workspace (1:1 relationship)
-        // DELETED workspaces are considered as non-existent
-        val existingWorkspaces = workspaceRepository.findBySessionId(request.sessionId)
-        val activeWorkspaces = existingWorkspaces.filter { it.status != WorkspaceStatus.DELETED }
-        if (activeWorkspaces.isNotEmpty()) {
-            throw IllegalArgumentException(
-                "Session already has an active workspace. Each session can have only one active workspace. SessionId: ${request.sessionId}, existing workspace: ${activeWorkspaces.first().id}",
-            )
-        }
-
-        // Determine template
-        val template = if (request.templateId != null) {
-            workspaceTemplateRepository.findById(request.templateId)
-                ?: throw IllegalArgumentException("Template not found: ${request.templateId}")
-        } else {
-            workspaceTemplateRepository.findDefaultTemplate()
-                ?: createDefaultTemplate()
-        }
-
-        // Create workspace - Use sessionId as workspace ID for 1:1 relationship
-        val workspace = Workspace(
-            id = request.sessionId,
-            name = request.name,
-            sessionId = request.sessionId,
-            templateId = template.id,
-            templateVersionId = request.templateVersionId,
-            status = WorkspaceStatus.PENDING,
-            autoStartSchedule = request.autoStartSchedule,
-            ttlMs = request.ttlMs,
-            automaticUpdates = request.automaticUpdates,
-            richParameterValues = request.richParameterValues,
-            buildInfo = WorkspaceBuildInfo(
-                buildId = UUID.randomUUID().toString(),
-                buildNumber = 1,
-                buildStatus = WorkspaceBuildStatus.PENDING,
-                buildReason = "Initial workspace creation",
-                buildStartedAt = LocalDateTime.now(),
-            ),
-            resourceInfo = WorkspaceResourceInfo(
-                kubernetesNamespace = "keruta-workspaces",
-                persistentVolumeClaimName = "workspace-${request.sessionId}-${request.name}",
-            ),
-        )
-
-        val savedWorkspace = workspaceRepository.save(workspace)
-
-        // Get session template configuration
-        val sessionTemplateConfig = session.templateConfig
-
-        // Start workspace creation asynchronously with session template configuration
-        workspaceOrchestrator.createWorkspaceAsync(savedWorkspace, template, sessionTemplateConfig)
-
-        return savedWorkspace
-    }
-
-    override suspend fun getWorkspaceById(id: String): Workspace? {
-        return workspaceRepository.findById(id)
-    }
-
-    override suspend fun getAllWorkspaces(): List<Workspace> {
-        return workspaceRepository.findAll()
-    }
-
-    override suspend fun getWorkspacesBySessionId(sessionId: String): List<Workspace> {
-        return workspaceRepository.findBySessionId(sessionId)
-    }
-
-    override suspend fun updateWorkspaceStatus(id: String, status: WorkspaceStatus): Workspace? {
-        val workspace = workspaceRepository.findById(id) ?: return null
-        val oldStatus = workspace.status
-
-        val updatedWorkspace = workspace.copy(
-            status = status,
-            updatedAt = LocalDateTime.now(),
-            startedAt = if (status == WorkspaceStatus.RUNNING) LocalDateTime.now() else workspace.startedAt,
-            stoppedAt = if (status == WorkspaceStatus.STOPPED) LocalDateTime.now() else workspace.stoppedAt,
-            deletedAt = if (status == WorkspaceStatus.DELETED) LocalDateTime.now() else workspace.deletedAt,
-        )
-
-        val savedWorkspace = workspaceRepository.update(updatedWorkspace)
-
-        // Trigger session status synchronization if workspace status changed
-        if (savedWorkspace != null && oldStatus != status) {
-            notifyWorkspaceStatusChange(savedWorkspace, oldStatus)
-        }
-
-        return savedWorkspace
-    }
-
-    override suspend fun startWorkspace(id: String): Workspace? {
-        val workspace = workspaceRepository.findById(id) ?: return null
-
-        // If workspace is already starting or running, return current state
-        if (workspace.status == WorkspaceStatus.STARTING) {
-            logger.debug("Workspace is already starting: {}", id)
-            return workspace
-        }
-
-        if (workspace.status == WorkspaceStatus.RUNNING) {
-            logger.debug("Workspace is already running: {}", id)
-            return workspace
-        }
-
-        // Allow starting from STOPPED, PENDING, or FAILED states
-        if (workspace.status != WorkspaceStatus.STOPPED &&
-            workspace.status != WorkspaceStatus.PENDING &&
-            workspace.status != WorkspaceStatus.FAILED
-        ) {
-            throw IllegalStateException("Workspace cannot be started from current status: ${workspace.status}")
-        }
-
-        // Log special handling for FAILED state
-        if (workspace.status == WorkspaceStatus.FAILED) {
-            logger.warn("Starting workspace from FAILED state: {}", id)
-        }
-
-        val updatedWorkspace = workspace.copy(
-            status = WorkspaceStatus.STARTING,
-            updatedAt = LocalDateTime.now(),
-            lastUsedAt = LocalDateTime.now(),
-        )
-
-        val savedWorkspace = workspaceRepository.update(updatedWorkspace)
-
-        // Start workspace asynchronously
-        workspaceOrchestrator.startWorkspaceAsync(savedWorkspace)
-
-        return savedWorkspace
-    }
-
-    override suspend fun stopWorkspace(id: String): Workspace? {
-        val workspace = workspaceRepository.findById(id) ?: return null
-
-        if (workspace.status != WorkspaceStatus.RUNNING) {
-            throw IllegalStateException("Workspace must be running to stop")
-        }
-
-        val updatedWorkspace = workspace.copy(
-            status = WorkspaceStatus.STOPPING,
-            updatedAt = LocalDateTime.now(),
-        )
-
-        val savedWorkspace = workspaceRepository.update(updatedWorkspace)
-
-        // Stop workspace asynchronously
-        workspaceOrchestrator.stopWorkspaceAsync(savedWorkspace)
-
-        return savedWorkspace
-    }
-
-    override suspend fun deleteWorkspace(id: String): Boolean {
-        val workspace = workspaceRepository.findById(id) ?: return false
-
-        // Stop workspace first if running
-        if (workspace.status == WorkspaceStatus.RUNNING) {
-            stopWorkspace(id)
-        }
-
-        val updatedWorkspace = workspace.copy(
-            status = WorkspaceStatus.DELETING,
-            updatedAt = LocalDateTime.now(),
-        )
-
-        workspaceRepository.update(updatedWorkspace)
-
-        // Delete workspace asynchronously
-        workspaceOrchestrator.deleteWorkspaceAsync(updatedWorkspace)
-
-        return true
-    }
-
-    override suspend fun deleteWorkspacesBySessionId(sessionId: String): Boolean {
-        logger.info("Deleting all workspaces for session: sessionId={}", sessionId)
-
-        val workspaces = workspaceRepository.findBySessionId(sessionId)
-
-        if (workspaces.isEmpty()) {
-            logger.info("No workspaces found for session: sessionId={}", sessionId)
-            return false
-        }
-
-        logger.info("Found {} workspace(s) to delete for session: sessionId={}", workspaces.size, sessionId)
-
-        var successCount = 0
-        var failureCount = 0
-
-        workspaces.forEach { workspace ->
-            try {
-                logger.info(
-                    "Deleting workspace: workspaceId={} name={} status={} for session={}",
-                    workspace.id,
-                    workspace.name,
-                    workspace.status,
-                    sessionId,
-                )
-
-                val deleted = deleteWorkspace(workspace.id)
-                if (deleted) {
-                    successCount++
-                    logger.info("Successfully initiated deletion for workspace: workspaceId={}", workspace.id)
-                } else {
-                    failureCount++
-                    logger.warn("Failed to delete workspace: workspaceId={}", workspace.id)
-                }
-            } catch (e: Exception) {
-                failureCount++
-                logger.error(
-                    "Exception occurred while deleting workspace: workspaceId={} for session={}",
-                    workspace.id,
-                    sessionId,
-                    e,
-                )
-            }
-        }
-
-        logger.info(
-            "Workspace deletion summary for session {}: {} successful, {} failed",
-            sessionId,
-            successCount,
-            failureCount,
-        )
-
-        return successCount > 0
-    }
-
-    override suspend fun getWorkspaceTemplates(): List<WorkspaceTemplate> {
-        return workspaceTemplateRepository.findAll()
-    }
-
-    override suspend fun getWorkspaceTemplate(id: String): WorkspaceTemplate? {
-        return workspaceTemplateRepository.findById(id)
-    }
-
-    override suspend fun getDefaultWorkspaceTemplate(): WorkspaceTemplate? {
-        return workspaceTemplateRepository.findDefaultTemplate()
-    }
-
-    override suspend fun createWorkspaceTemplate(template: WorkspaceTemplate): WorkspaceTemplate {
-        if (workspaceTemplateRepository.existsByName(template.name)) {
-            throw IllegalArgumentException("Template with name '${template.name}' already exists")
-        }
-
-        return workspaceTemplateRepository.save(template)
-    }
-
-    override suspend fun updateWorkspaceTemplate(template: WorkspaceTemplate): WorkspaceTemplate {
-        @Suppress("UNUSED_VARIABLE")
-        val existing = workspaceTemplateRepository.findById(template.id)
-            ?: throw IllegalArgumentException("Template not found: ${template.id}")
-
-        val updatedTemplate = template.copy(
-            updatedAt = LocalDateTime.now(),
-        )
-
-        return workspaceTemplateRepository.update(updatedTemplate)
-    }
-
-    override suspend fun deleteWorkspaceTemplate(id: String): Boolean {
-        return workspaceTemplateRepository.delete(id)
-    }
-
-    private suspend fun createDefaultTemplate(): WorkspaceTemplate {
-        logger.info("Creating default workspace template")
-
-        // First check if there are any existing default templates
-        val existingDefault = workspaceTemplateRepository.findDefaultTemplate()
-        if (existingDefault != null) {
-            logger.info("Default template already exists: {}", existingDefault.id)
-            return existingDefault
-        }
-
-        // Check if there's a template named "default" that isn't marked as default
-        val namedDefaultTemplate = workspaceTemplateRepository.findByName("default")
-        if (namedDefaultTemplate != null) {
-            logger.info("Found existing 'default' template, marking it as default: {}", namedDefaultTemplate.id)
-            val updatedTemplate = namedDefaultTemplate.copy(
-                isDefault = true,
-                updatedAt = LocalDateTime.now(),
-            )
-            return workspaceTemplateRepository.update(updatedTemplate)
-        }
-
-        // Create new default template
-        val defaultTemplate = WorkspaceTemplate(
-            id = UUID.randomUUID().toString(),
-            name = "default",
-            description = "Default workspace template for Keruta",
-            version = "1.0.0",
-            icon = null,
-            isDefault = true,
-            parameters = emptyList(),
-            createdAt = LocalDateTime.now(),
-            updatedAt = LocalDateTime.now(),
-        )
-
-        logger.info("Creating new default template")
-        return workspaceTemplateRepository.save(defaultTemplate)
-    }
-
-    /**
-     * Notifies about workspace status changes for session synchronization.
-     * This is a placeholder method that can be enhanced with event publishing.
-     */
-    private fun notifyWorkspaceStatusChange(workspace: Workspace, oldStatus: WorkspaceStatus) {
-        // This could be enhanced to publish events to a message queue or event bus
-        // For now, we'll use a simple async call approach
-        logger.debug(
-            "Workspace status changed: workspaceId={} sessionId={} oldStatus={} newStatus={}",
-            workspace.id,
-            workspace.sessionId,
-            oldStatus,
-            workspace.status,
-        )
-
-        // Note: In a real implementation, this would be handled through dependency injection
-        // and proper event publishing mechanisms to avoid tight coupling
-    }
-
-    override suspend fun getCoderTemplates(): List<CoderTemplate> {
-        logger.info("Fetching Coder templates from Coder server")
-
-        try {
-            // ここではCoderAPIクライアントを使用してテンプレートを取得
-            // 実装としてはHTTPクライアントでCoderサーバーのAPIを呼び出す
-            return workspaceOrchestrator.getCoderTemplates()
-        } catch (e: Exception) {
-            logger.error("Failed to fetch Coder templates", e)
-            return emptyList()
-        }
-    }
-
-    override suspend fun getCoderTemplate(id: String): CoderTemplate? {
-        logger.info("Fetching Coder template: $id")
-
-        try {
-            return workspaceOrchestrator.getCoderTemplate(id)
-        } catch (e: Exception) {
-            logger.error("Failed to fetch Coder template: $id", e)
-            return null
-        }
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/CreateSessionRequest.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/CreateSessionRequest.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/CreateSessionRequest.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/CreateSessionRequest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,35 +0,0 @@
-package net.kigawa.keruta.api.session.dto
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionStatus
-import java.time.LocalDateTime
-import java.util.*
-
-data class CreateSessionRequest(
-    val name: String,
-    val description: String? = null,
-    val status: String = SessionStatus.ACTIVE.name,
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val templateConfig: SessionTemplateConfigRequest? = null,
-) {
-    fun toDomain(): Session {
-        val sessionStatus = try {
-            SessionStatus.valueOf(status.uppercase())
-        } catch (e: IllegalArgumentException) {
-            SessionStatus.ACTIVE
-        }
-
-        return Session(
-            id = UUID.randomUUID().toString(),
-            name = name,
-            description = description,
-            status = sessionStatus,
-            tags = tags,
-            metadata = metadata,
-            templateConfig = templateConfig?.toDomain(),
-            createdAt = LocalDateTime.now(),
-            updatedAt = LocalDateTime.now(),
-        )
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/controller/SessionDetailController.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/controller/SessionDetailController.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/controller/SessionDetailController.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/controller/SessionDetailController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,45 +0,0 @@
-package net.kigawa.keruta.api.session.controller
-
-import io.swagger.v3.oas.annotations.Operation
-import io.swagger.v3.oas.annotations.tags.Tag
-import net.kigawa.keruta.api.session.dto.SessionDetailResponse
-import net.kigawa.keruta.core.usecase.session.SessionService
-import net.kigawa.keruta.core.usecase.session.SessionServiceImpl
-import org.slf4j.LoggerFactory
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.*
-
-/**
- * REST controller for session detail operations.
- */
-@RestController
-@RequestMapping("/api/v1/sessions")
-@Tag(name = "Session Detail", description = "Session detail management API")
-class SessionDetailController(
-    private val sessionService: SessionService,
-    private val sessionServiceImpl: SessionServiceImpl,
-) {
-    private val logger = LoggerFactory.getLogger(this::class.java)
-
-    @GetMapping("/{id}/detail")
-    @Operation(
-        summary = "Get session detail",
-        description = "Retrieves detailed information about a session including workspaces",
-    )
-    suspend fun getSessionDetail(@PathVariable id: String): ResponseEntity<SessionDetailResponse> {
-        return try {
-            val session = sessionService.getSessionById(id)
-            val workspaces = sessionServiceImpl.getSessionWorkspaces(id)
-
-            logger.info("Retrieved session detail: id={}, workspaces={}", id, workspaces.size)
-
-            ResponseEntity.ok(SessionDetailResponse.fromDomain(session, workspaces))
-        } catch (e: NoSuchElementException) {
-            logger.warn("Session not found: id={}", id)
-            ResponseEntity.notFound().build()
-        } catch (e: Exception) {
-            logger.error("Failed to get session detail: id={}", id, e)
-            ResponseEntity.internalServerError().build()
-        }
-    }
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/dto/AuthDto.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/dto/AuthDto.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/dto/AuthDto.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/dto/AuthDto.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,25 +0,0 @@
-package net.kigawa.keruta.infra.security.dto
-
-/**
- * Request for login.
- */
-data class LoginRequest(
-    val username: String,
-    val password: String,
-)
-
-/**
- * Request for token refresh.
- */
-data class RefreshTokenRequest(
-    val refreshToken: String,
-)
-
-/**
- * Response with authentication tokens.
- */
-data class TokenResponse(
-    val accessToken: String,
-    val refreshToken: String,
-    val tokenType: String = "Bearer",
-)
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionResponse.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionResponse.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionResponse.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionResponse.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,88 +0,0 @@
-package net.kigawa.keruta.api.session.dto
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionTemplateConfig
-import net.kigawa.keruta.core.domain.model.Workspace
-import java.time.LocalDateTime
-
-data class SessionResponse(
-    val id: String,
-    val name: String,
-    val description: String? = null,
-    val status: String,
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val templateConfig: SessionTemplateConfigResponse? = null,
-    val createdAt: LocalDateTime,
-    val updatedAt: LocalDateTime,
-    val workspaces: List<SessionWorkspaceInfo> = emptyList(),
-) {
-    companion object {
-        fun fromDomain(session: Session, workspaces: List<Workspace> = emptyList()): SessionResponse {
-            return SessionResponse(
-                id = session.id,
-                name = session.name,
-                description = session.description,
-                status = session.status.name,
-                tags = session.tags,
-                metadata = session.metadata,
-                templateConfig = session.templateConfig?.let { SessionTemplateConfigResponse.fromDomain(it) },
-                createdAt = session.createdAt,
-                updatedAt = session.updatedAt,
-                workspaces = workspaces.map { SessionWorkspaceInfo.fromDomain(it) },
-            )
-        }
-    }
-}
-
-/**
- * Response DTO for session template configuration.
- */
-data class SessionTemplateConfigResponse(
-    val templateId: String? = null,
-    val templateName: String? = null,
-    val repositoryUrl: String? = null,
-    val repositoryRef: String = "main",
-    val templatePath: String = ".",
-    val preferredKeywords: List<String> = emptyList(),
-    val parameters: Map<String, String> = emptyMap(),
-) {
-    companion object {
-        fun fromDomain(config: SessionTemplateConfig): SessionTemplateConfigResponse {
-            return SessionTemplateConfigResponse(
-                templateId = config.templateId,
-                templateName = config.templateName,
-                repositoryUrl = config.repositoryUrl,
-                repositoryRef = config.repositoryRef,
-                templatePath = config.templatePath,
-                preferredKeywords = config.preferredKeywords,
-                parameters = config.parameters,
-            )
-        }
-    }
-}
-
-/**
- * Workspace information for session response.
- */
-data class SessionWorkspaceInfo(
-    val id: String,
-    val name: String,
-    val status: String,
-    val workspaceUrl: String? = null,
-    val createdAt: LocalDateTime,
-    val lastUsedAt: LocalDateTime? = null,
-) {
-    companion object {
-        fun fromDomain(workspace: Workspace): SessionWorkspaceInfo {
-            return SessionWorkspaceInfo(
-                id = workspace.id,
-                name = workspace.name,
-                status = workspace.status.name,
-                workspaceUrl = workspace.resourceInfo?.ingressUrl,
-                createdAt = workspace.createdAt,
-                lastUsedAt = workspace.lastUsedAt,
-            )
-        }
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/WorkspaceEntity.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/WorkspaceEntity.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/WorkspaceEntity.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/entity/WorkspaceEntity.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,168 +0,0 @@
-package net.kigawa.keruta.infra.persistence.entity
-
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceBuildInfo
-import net.kigawa.keruta.core.domain.model.WorkspaceBuildStatus
-import net.kigawa.keruta.core.domain.model.WorkspaceResourceInfo
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import org.springframework.data.annotation.Id
-import org.springframework.data.mongodb.core.mapping.Document
-import java.time.LocalDateTime
-
-/**
- * MongoDB entity for workspace.
- */
-@Document(collection = "workspaces")
-data class WorkspaceEntity(
-    @Id
-    val id: String,
-    val name: String,
-    val sessionId: String,
-    val templateId: String? = null,
-    val templateVersionId: String? = null,
-    val status: WorkspaceStatus = WorkspaceStatus.PENDING,
-    val autoStartSchedule: String? = null,
-    val ttlMs: Long? = null,
-    val automaticUpdates: Boolean = true,
-    val richParameterValues: Map<String, String> = emptyMap(),
-    val createdAt: LocalDateTime = LocalDateTime.now(),
-    val updatedAt: LocalDateTime = LocalDateTime.now(),
-    val startedAt: LocalDateTime? = null,
-    val stoppedAt: LocalDateTime? = null,
-    val lastUsedAt: LocalDateTime? = null,
-    val deletedAt: LocalDateTime? = null,
-    val buildInfo: WorkspaceBuildInfoEntity? = null,
-    val resourceInfo: WorkspaceResourceInfoEntity? = null,
-    val metadata: Map<String, String> = emptyMap(),
-) {
-    fun toDomain(): Workspace {
-        return Workspace(
-            id = id,
-            name = name,
-            sessionId = sessionId,
-            templateId = templateId,
-            templateVersionId = templateVersionId,
-            status = status,
-            autoStartSchedule = autoStartSchedule,
-            ttlMs = ttlMs,
-            automaticUpdates = automaticUpdates,
-            richParameterValues = richParameterValues,
-            createdAt = createdAt,
-            updatedAt = updatedAt,
-            startedAt = startedAt,
-            stoppedAt = stoppedAt,
-            lastUsedAt = lastUsedAt,
-            deletedAt = deletedAt,
-            buildInfo = buildInfo?.toDomain(),
-            resourceInfo = resourceInfo?.toDomain(),
-            metadata = metadata,
-        )
-    }
-
-    companion object {
-        fun fromDomain(workspace: Workspace): WorkspaceEntity {
-            return WorkspaceEntity(
-                id = workspace.id,
-                name = workspace.name,
-                sessionId = workspace.sessionId,
-                templateId = workspace.templateId,
-                templateVersionId = workspace.templateVersionId,
-                status = workspace.status,
-                autoStartSchedule = workspace.autoStartSchedule,
-                ttlMs = workspace.ttlMs,
-                automaticUpdates = workspace.automaticUpdates,
-                richParameterValues = workspace.richParameterValues,
-                createdAt = workspace.createdAt,
-                updatedAt = workspace.updatedAt,
-                startedAt = workspace.startedAt,
-                stoppedAt = workspace.stoppedAt,
-                lastUsedAt = workspace.lastUsedAt,
-                deletedAt = workspace.deletedAt,
-                buildInfo = workspace.buildInfo?.let { WorkspaceBuildInfoEntity.fromDomain(it) },
-                resourceInfo = workspace.resourceInfo?.let { WorkspaceResourceInfoEntity.fromDomain(it) },
-                metadata = workspace.metadata,
-            )
-        }
-    }
-}
-
-/**
- * MongoDB entity for workspace build information.
- */
-data class WorkspaceBuildInfoEntity(
-    val buildId: String,
-    val buildNumber: Int,
-    val buildStatus: WorkspaceBuildStatus,
-    val buildReason: String? = null,
-    val buildStartedAt: LocalDateTime? = null,
-    val buildCompletedAt: LocalDateTime? = null,
-    val buildLog: String? = null,
-) {
-    fun toDomain(): WorkspaceBuildInfo {
-        return WorkspaceBuildInfo(
-            buildId = buildId,
-            buildNumber = buildNumber,
-            buildStatus = buildStatus,
-            buildReason = buildReason,
-            buildStartedAt = buildStartedAt,
-            buildCompletedAt = buildCompletedAt,
-            buildLog = buildLog,
-        )
-    }
-
-    companion object {
-        fun fromDomain(buildInfo: WorkspaceBuildInfo): WorkspaceBuildInfoEntity {
-            return WorkspaceBuildInfoEntity(
-                buildId = buildInfo.buildId,
-                buildNumber = buildInfo.buildNumber,
-                buildStatus = buildInfo.buildStatus,
-                buildReason = buildInfo.buildReason,
-                buildStartedAt = buildInfo.buildStartedAt,
-                buildCompletedAt = buildInfo.buildCompletedAt,
-                buildLog = buildInfo.buildLog,
-            )
-        }
-    }
-}
-
-/**
- * MongoDB entity for workspace resource information.
- */
-data class WorkspaceResourceInfoEntity(
-    val cpuCores: Int? = null,
-    val memoryMb: Long? = null,
-    val diskGb: Long? = null,
-    val kubernetesNamespace: String? = null,
-    val persistentVolumeClaimName: String? = null,
-    val podName: String? = null,
-    val serviceName: String? = null,
-    val ingressUrl: String? = null,
-) {
-    fun toDomain(): WorkspaceResourceInfo {
-        return WorkspaceResourceInfo(
-            cpuCores = cpuCores,
-            memoryMb = memoryMb,
-            diskGb = diskGb,
-            kubernetesNamespace = kubernetesNamespace,
-            persistentVolumeClaimName = persistentVolumeClaimName,
-            podName = podName,
-            serviceName = serviceName,
-            ingressUrl = ingressUrl,
-        )
-    }
-
-    companion object {
-        fun fromDomain(resourceInfo: WorkspaceResourceInfo): WorkspaceResourceInfoEntity {
-            return WorkspaceResourceInfoEntity(
-                cpuCores = resourceInfo.cpuCores,
-                memoryMb = resourceInfo.memoryMb,
-                diskGb = resourceInfo.diskGb,
-                kubernetesNamespace = resourceInfo.kubernetesNamespace,
-                persistentVolumeClaimName = resourceInfo.persistentVolumeClaimName,
-                podName = resourceInfo.podName,
-                serviceName = resourceInfo.serviceName,
-                ingressUrl = resourceInfo.ingressUrl,
-            )
-        }
-    }
-}
Index: keruta-api/infra/security/src/main/main.iml
===================================================================
diff --git a/keruta-api/infra/security/src/main/main.iml b/keruta-api/infra/security/src/main/main.iml
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/main.iml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/kotlin" isTestSource="false" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionDetailResponse.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionDetailResponse.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionDetailResponse.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/SessionDetailResponse.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,165 +0,0 @@
-package net.kigawa.keruta.api.session.dto
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import java.time.LocalDateTime
-
-/**
- * Detailed response DTO for session operations including workspace links.
- */
-data class SessionDetailResponse(
-    val id: String,
-    val name: String,
-    val description: String? = null,
-    val status: String,
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val createdAt: LocalDateTime,
-    val updatedAt: LocalDateTime,
-    val workspaces: List<SessionWorkspaceDetail> = emptyList(),
-    val workspaceStats: SessionWorkspaceStats,
-) {
-    companion object {
-        fun fromDomain(session: Session, workspaces: List<Workspace> = emptyList()): SessionDetailResponse {
-            return SessionDetailResponse(
-                id = session.id,
-                name = session.name,
-                description = session.description,
-                status = session.status.name,
-                tags = session.tags,
-                metadata = session.metadata,
-                createdAt = session.createdAt,
-                updatedAt = session.updatedAt,
-                workspaces = workspaces.map { SessionWorkspaceDetail.fromDomain(it) },
-                workspaceStats = SessionWorkspaceStats.fromWorkspaces(workspaces),
-            )
-        }
-    }
-}
-
-/**
- * Detailed workspace information for session response.
- */
-data class SessionWorkspaceDetail(
-    val id: String,
-    val name: String,
-    val status: String,
-    val workspaceUrl: String? = null,
-    val coderWorkspaceUrl: String? = null,
-    val templateId: String? = null,
-    val automaticUpdates: Boolean,
-    val ttlMs: Long? = null,
-    val createdAt: LocalDateTime,
-    val startedAt: LocalDateTime? = null,
-    val lastUsedAt: LocalDateTime? = null,
-    val buildInfo: WorkspaceBuildDetail? = null,
-    val actions: List<String> = emptyList(),
-) {
-    companion object {
-        fun fromDomain(workspace: Workspace): SessionWorkspaceDetail {
-            val actions = mutableListOf<String>()
-
-            // Determine available actions based on current status
-            when (workspace.status) {
-                WorkspaceStatus.PENDING, WorkspaceStatus.FAILED -> {
-                    actions.add("start")
-                    actions.add("delete")
-                }
-                WorkspaceStatus.STOPPED -> {
-                    actions.add("start")
-                    actions.add("delete")
-                }
-                WorkspaceStatus.RUNNING -> {
-                    actions.add("stop")
-                    actions.add("access")
-                }
-                WorkspaceStatus.STARTING, WorkspaceStatus.STOPPING -> {
-                    // No actions available during transitional states
-                }
-                WorkspaceStatus.DELETING, WorkspaceStatus.DELETED -> {
-                    // No actions available for deleted workspaces
-                }
-                WorkspaceStatus.CANCELED -> {
-                    actions.add("start")
-                    actions.add("delete")
-                }
-            }
-
-            // Generate Coder workspace URL if available
-            val coderWorkspaceUrl = workspace.metadata["coderWorkspaceId"]?.let { coderWorkspaceId ->
-                workspace.resourceInfo?.ingressUrl ?: "http://localhost:3000/workspaces/$coderWorkspaceId"
-            }
-
-            return SessionWorkspaceDetail(
-                id = workspace.id,
-                name = workspace.name,
-                status = workspace.status.name,
-                workspaceUrl = workspace.resourceInfo?.ingressUrl,
-                coderWorkspaceUrl = coderWorkspaceUrl,
-                templateId = workspace.templateId,
-                automaticUpdates = workspace.automaticUpdates,
-                ttlMs = workspace.ttlMs,
-                createdAt = workspace.createdAt,
-                startedAt = workspace.startedAt,
-                lastUsedAt = workspace.lastUsedAt,
-                buildInfo = workspace.buildInfo?.let { WorkspaceBuildDetail.fromDomain(it) },
-                actions = actions,
-            )
-        }
-    }
-}
-
-/**
- * Build information for workspace detail.
- */
-data class WorkspaceBuildDetail(
-    val buildId: String,
-    val buildNumber: Int,
-    val buildStatus: String,
-    val buildReason: String? = null,
-    val buildStartedAt: LocalDateTime? = null,
-    val buildCompletedAt: LocalDateTime? = null,
-) {
-    companion object {
-        fun fromDomain(buildInfo: net.kigawa.keruta.core.domain.model.WorkspaceBuildInfo): WorkspaceBuildDetail {
-            return WorkspaceBuildDetail(
-                buildId = buildInfo.buildId,
-                buildNumber = buildInfo.buildNumber,
-                buildStatus = buildInfo.buildStatus.name,
-                buildReason = buildInfo.buildReason,
-                buildStartedAt = buildInfo.buildStartedAt,
-                buildCompletedAt = buildInfo.buildCompletedAt,
-            )
-        }
-    }
-}
-
-/**
- * Statistics about workspaces in a session.
- */
-data class SessionWorkspaceStats(
-    val total: Int,
-    val running: Int,
-    val stopped: Int,
-    val pending: Int,
-    val failed: Int,
-    val deleting: Int,
-) {
-    companion object {
-        fun fromWorkspaces(workspaces: List<Workspace>): SessionWorkspaceStats {
-            val statusCounts = workspaces.groupingBy { it.status }.eachCount()
-
-            return SessionWorkspaceStats(
-                total = workspaces.size,
-                running = statusCounts[WorkspaceStatus.RUNNING] ?: 0,
-                stopped = statusCounts[WorkspaceStatus.STOPPED] ?: 0,
-                pending = (statusCounts[WorkspaceStatus.PENDING] ?: 0) +
-                    (statusCounts[WorkspaceStatus.STARTING] ?: 0),
-                failed = statusCounts[WorkspaceStatus.FAILED] ?: 0,
-                deleting = (statusCounts[WorkspaceStatus.DELETING] ?: 0) +
-                    (statusCounts[WorkspaceStatus.DELETED] ?: 0),
-            )
-        }
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/document/DocumentService.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/document/DocumentService.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/document/DocumentService.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/document/DocumentService.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,66 +0,0 @@
-/**
- * Service interface for Document operations.
- */
-package net.kigawa.keruta.core.usecase.document
-
-import net.kigawa.keruta.core.domain.model.Document
-
-interface DocumentService {
-    /**
-     * Gets all documents.
-     *
-     * @return List of all documents
-     */
-    fun getAllDocuments(): List<Document>
-
-    /**
-     * Gets a document by its ID.
-     *
-     * @param id The ID of the document to get
-     * @return The document if found
-     * @throws NoSuchElementException if the document is not found
-     */
-    fun getDocumentById(id: String): Document
-
-    /**
-     * Creates a new document.
-     *
-     * @param document The document to create
-     * @return The created document with generated ID
-     */
-    fun createDocument(document: Document): Document
-
-    /**
-     * Updates an existing document.
-     *
-     * @param id The ID of the document to update
-     * @param document The updated document data
-     * @return The updated document
-     * @throws NoSuchElementException if the document is not found
-     */
-    fun updateDocument(id: String, document: Document): Document
-
-    /**
-     * Deletes a document by its ID.
-     *
-     * @param id The ID of the document to delete
-     * @throws NoSuchElementException if the document is not found
-     */
-    fun deleteDocument(id: String)
-
-    /**
-     * Searches for documents by title or content.
-     *
-     * @param query The search query
-     * @return List of documents matching the query
-     */
-    fun searchDocuments(query: String): List<Document>
-
-    /**
-     * Gets documents by tag.
-     *
-     * @param tag The tag to filter by
-     * @return List of documents with the specified tag
-     */
-    fun getDocumentsByTag(tag: String): List<Document>
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionServiceImpl.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionServiceImpl.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionServiceImpl.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionServiceImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,236 +0,0 @@
-/**
- * Implementation of the SessionService interface.
- */
-package net.kigawa.keruta.core.usecase.session
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionStatus
-import net.kigawa.keruta.core.usecase.repository.SessionRepository
-import net.kigawa.keruta.core.usecase.workspace.WorkspaceService
-import org.slf4j.LoggerFactory
-import org.springframework.stereotype.Service
-import java.time.LocalDateTime
-
-@Service
-open class SessionServiceImpl(
-    open val sessionRepository: SessionRepository,
-    open val workspaceService: WorkspaceService,
-    open val sessionEventListener: SessionEventListener,
-) : SessionService {
-
-    open val logger = LoggerFactory.getLogger(SessionServiceImpl::class.java)
-
-    override suspend fun getAllSessions(): List<Session> {
-        return sessionRepository.findAll()
-    }
-
-    override suspend fun getSessionById(id: String): Session {
-        return sessionRepository.findById(id) ?: throw NoSuchElementException("Session not found with id: $id")
-    }
-
-    override suspend fun createSession(session: Session): Session {
-        val createdSession = sessionRepository.save(session)
-
-        // Trigger workspace creation event
-        try {
-            sessionEventListener.onSessionCreated(createdSession)
-        } catch (e: Exception) {
-            logger.error("Failed to handle session creation event for session: {}", createdSession.id, e)
-            // Don't fail the session creation if workspace creation fails
-        }
-
-        return createdSession
-    }
-
-    override suspend fun updateSession(id: String, session: Session): Session {
-        logger.info("Updating session: id={}", id)
-        val existingSession = getSessionById(id)
-
-        // Check if template configuration has changed
-        val templateConfigChanged = hasTemplateConfigChanged(existingSession, session)
-
-        val updatedSession = session.copy(
-            id = existingSession.id,
-            createdAt = existingSession.createdAt,
-            updatedAt = LocalDateTime.now(),
-        )
-
-        val savedSession = sessionRepository.save(updatedSession)
-
-        // Create new workspace if template configuration changed
-        if (templateConfigChanged) {
-            logger.info("Template configuration changed for session: id={}, creating new workspace", id)
-            try {
-                sessionEventListener.onSessionTemplateChanged(savedSession, existingSession)
-            } catch (e: Exception) {
-                logger.error("Failed to handle session template change event for session: {}", id, e)
-            }
-        }
-
-        logger.info("Session updated successfully: id={}", id)
-        return savedSession
-    }
-
-    /**
-     * Checks if the template configuration has changed between two sessions.
-     * This includes template path and parameters.
-     */
-    private fun hasTemplateConfigChanged(existingSession: Session, newSession: Session): Boolean {
-        val existingConfig = existingSession.templateConfig
-        val newConfig = newSession.templateConfig
-
-        // If one is null and the other is not, it's a change
-        if (existingConfig == null && newConfig != null) return true
-        if (existingConfig != null && newConfig == null) return true
-        if (existingConfig == null && newConfig == null) return false
-
-        // Both are non-null, compare their contents
-        return existingConfig!!.templateId != newConfig!!.templateId ||
-            existingConfig.templateName != newConfig.templateName ||
-            existingConfig.repositoryUrl != newConfig.repositoryUrl ||
-            existingConfig.repositoryRef != newConfig.repositoryRef ||
-            existingConfig.templatePath != newConfig.templatePath ||
-            existingConfig.preferredKeywords != newConfig.preferredKeywords ||
-            existingConfig.parameters != newConfig.parameters
-    }
-
-    override suspend fun deleteSession(id: String) {
-        logger.info("Deleting session and its workspaces: id={}", id)
-
-        // Verify session exists before deletion
-        val session = getSessionById(id)
-        logger.info("Found session to delete: id={} name={} status={}", id, session.name, session.status)
-
-        // Trigger session deletion event to clean up associated workspaces
-        try {
-            logger.info("Initiating workspace cleanup for session: id={}", id)
-            sessionEventListener.onSessionDeleted(id)
-        } catch (e: Exception) {
-            logger.error("Failed to handle session deletion event for session: {}", id, e)
-            // Continue with session deletion even if workspace cleanup fails
-            // This ensures the session can still be deleted from the database
-        }
-
-        // Delete the session itself
-        if (!sessionRepository.deleteById(id)) {
-            throw NoSuchElementException("Session not found with id: $id")
-        }
-
-        logger.info("Successfully deleted session: id={} name={}", id, session.name)
-    }
-
-    override suspend fun getSessionsByStatus(status: SessionStatus): List<Session> {
-        return sessionRepository.findByStatus(status)
-    }
-
-    override suspend fun searchSessionsByName(name: String): List<Session> {
-        return sessionRepository.findByNameContaining(name)
-    }
-
-    override suspend fun getSessionsByTag(tag: String): List<Session> {
-        return sessionRepository.findByTag(tag)
-    }
-
-    override suspend fun updateSessionStatus(id: String, status: SessionStatus): Session {
-        logger.info("Updating session status: id={} status={}", id, status)
-        try {
-            val existingSession = getSessionById(id)
-            val oldStatus = existingSession.status
-            val updatedSession = existingSession.copy(
-                status = status,
-                updatedAt = LocalDateTime.now(),
-            )
-            val savedSession = sessionRepository.save(updatedSession)
-
-            // Trigger status change event if status actually changed
-            if (oldStatus != status) {
-                try {
-                    sessionEventListener.onSessionStatusChanged(savedSession, oldStatus)
-                } catch (e: Exception) {
-                    logger.error("Failed to handle session status change event for session: {}", id, e)
-                }
-            }
-
-            logger.info("Session status updated successfully: id={} status={}", id, status)
-            return savedSession
-        } catch (e: NoSuchElementException) {
-            logger.error("Session not found with id: {}", id, e)
-            throw e
-        } catch (e: Exception) {
-            logger.error("Failed to update session status: id={} status={}", id, status, e)
-            throw e
-        }
-    }
-
-    override suspend fun addTagToSession(id: String, tag: String): Session {
-        val existingSession = getSessionById(id)
-        val updatedTags = if (tag in existingSession.tags) {
-            existingSession.tags
-        } else {
-            existingSession.tags + tag
-        }
-        val updatedSession = existingSession.copy(
-            tags = updatedTags,
-            updatedAt = LocalDateTime.now(),
-        )
-        return sessionRepository.save(updatedSession)
-    }
-
-    /**
-     * Gets the single workspace associated with a session.
-     * Since each session has exactly one workspace, this returns the workspace if it exists.
-     */
-    suspend fun getSessionWorkspace(sessionId: String): net.kigawa.keruta.core.domain.model.Workspace? {
-        val workspaces = workspaceService.getWorkspacesBySessionId(sessionId)
-
-        if (workspaces.isEmpty()) {
-            return null
-        }
-
-        if (workspaces.size > 1) {
-            logger.warn(
-                "Multiple workspaces found for session (expected 1): sessionId={} count={}",
-                sessionId,
-                workspaces.size,
-            )
-        }
-
-        return workspaces.first()
-    }
-
-    /**
-     * Gets workspaces for session (backward compatibility).
-     * Returns a list containing the single workspace.
-     */
-    suspend fun getSessionWorkspaces(sessionId: String): List<net.kigawa.keruta.core.domain.model.Workspace> {
-        val workspace = getSessionWorkspace(sessionId)
-        return if (workspace != null) listOf(workspace) else emptyList()
-    }
-
-    /**
-     * Gets a session by its associated workspace ID.
-     */
-    suspend fun getSessionByWorkspaceId(workspaceId: String): Session? {
-        return try {
-            val workspace = workspaceService.getWorkspaceById(workspaceId)
-                ?: return null
-            getSessionById(workspace.sessionId)
-        } catch (e: NoSuchElementException) {
-            logger.debug("No session found for workspace ID: {}", workspaceId)
-            null
-        } catch (e: Exception) {
-            logger.error("Error retrieving session for workspace ID: {}", workspaceId, e)
-            null
-        }
-    }
-
-    override suspend fun removeTagFromSession(id: String, tag: String): Session {
-        val existingSession = getSessionById(id)
-        val updatedTags = existingSession.tags.filter { it != tag }
-        val updatedSession = existingSession.copy(
-            tags = updatedTags,
-            updatedAt = LocalDateTime.now(),
-        )
-        return sessionRepository.save(updatedSession)
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/WorkspaceRepositoryImpl.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/WorkspaceRepositoryImpl.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/WorkspaceRepositoryImpl.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/WorkspaceRepositoryImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,120 +0,0 @@
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.core.usecase.repository.WorkspaceRepository
-import net.kigawa.keruta.infra.persistence.entity.WorkspaceEntity
-import org.springframework.stereotype.Component
-
-/**
- * Implementation of WorkspaceRepository using MongoDB.
- */
-@Component
-class WorkspaceRepositoryImpl(
-    private val mongoWorkspaceRepository: MongoWorkspaceRepository,
-) : WorkspaceRepository {
-
-    override suspend fun findById(id: String): Workspace? {
-        return mongoWorkspaceRepository.findById(id).orElse(null)?.toDomain()
-    }
-
-    override suspend fun findBySessionId(sessionId: String): List<Workspace> {
-        return mongoWorkspaceRepository.findBySessionId(sessionId).map { it.toDomain() }
-    }
-
-    override suspend fun findByStatus(status: WorkspaceStatus): List<Workspace> {
-        return mongoWorkspaceRepository.findByStatus(status).map { it.toDomain() }
-    }
-
-    override suspend fun findByName(name: String): List<Workspace> {
-        return mongoWorkspaceRepository.findByNameContainingIgnoreCase(name).map { it.toDomain() }
-    }
-
-    override suspend fun findAll(): List<Workspace> {
-        return mongoWorkspaceRepository.findAll().map { it.toDomain() }
-    }
-
-    override suspend fun save(workspace: Workspace): Workspace {
-        val entity = WorkspaceEntity.fromDomain(workspace)
-        val savedEntity = mongoWorkspaceRepository.save(entity)
-        return savedEntity.toDomain()
-    }
-
-    override suspend fun update(workspace: Workspace): Workspace {
-        val entity = WorkspaceEntity.fromDomain(workspace)
-        val updatedEntity = mongoWorkspaceRepository.save(entity)
-        return updatedEntity.toDomain()
-    }
-
-    override suspend fun delete(id: String): Boolean {
-        return if (mongoWorkspaceRepository.existsById(id)) {
-            mongoWorkspaceRepository.deleteById(id)
-            true
-        } else {
-            false
-        }
-    }
-
-    override suspend fun deleteBySessionId(sessionId: String): Boolean {
-        val deletedCount = mongoWorkspaceRepository.deleteBySessionId(sessionId)
-        return deletedCount > 0
-    }
-
-    override suspend fun existsByName(name: String): Boolean {
-        return mongoWorkspaceRepository.findByNameContainingIgnoreCase(name).isNotEmpty()
-    }
-
-    override suspend fun existsBySessionId(sessionId: String): Boolean {
-        return mongoWorkspaceRepository.existsBySessionId(sessionId)
-    }
-
-    override suspend fun countByStatus(status: WorkspaceStatus): Long {
-        return mongoWorkspaceRepository.countByStatus(status)
-    }
-
-    override suspend fun countBySessionId(sessionId: String): Long {
-        return mongoWorkspaceRepository.countBySessionId(sessionId)
-    }
-
-    /**
-     * Finds workspace by session ID and name.
-     */
-    fun findBySessionIdAndName(sessionId: String, name: String): Workspace? {
-        return mongoWorkspaceRepository.findBySessionIdAndName(sessionId, name)?.toDomain()
-    }
-
-    /**
-     * Checks if workspace exists by session ID and name.
-     */
-    fun existsBySessionIdAndName(sessionId: String, name: String): Boolean {
-        return mongoWorkspaceRepository.existsBySessionIdAndName(sessionId, name)
-    }
-
-    /**
-     * Finds workspaces by session ID and status list.
-     */
-    fun findBySessionIdAndStatusIn(sessionId: String, statuses: List<WorkspaceStatus>): List<Workspace> {
-        return mongoWorkspaceRepository.findBySessionIdAndStatusIn(sessionId, statuses).map { it.toDomain() }
-    }
-
-    /**
-     * Finds workspaces by template ID.
-     */
-    fun findByTemplateId(templateId: String): List<Workspace> {
-        return mongoWorkspaceRepository.findByTemplateId(templateId).map { it.toDomain() }
-    }
-
-    /**
-     * Finds all active workspaces (not deleted).
-     */
-    fun findAllActive(): List<Workspace> {
-        return mongoWorkspaceRepository.findAllActive().map { it.toDomain() }
-    }
-
-    /**
-     * Finds active workspaces by session ID.
-     */
-    fun findActiveBySessionId(sessionId: String): List<Workspace> {
-        return mongoWorkspaceRepository.findActiveBySessionId(sessionId).map { it.toDomain() }
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/config/InitializationConfig.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/config/InitializationConfig.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/config/InitializationConfig.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/config/InitializationConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,23 +0,0 @@
-package net.kigawa.keruta.api.config
-
-import net.kigawa.keruta.core.usecase.workspace.WorkspaceService
-import org.slf4j.LoggerFactory
-import org.springframework.boot.CommandLineRunner
-import org.springframework.stereotype.Component
-
-/**
- * Initialization configuration that runs on application startup.
- */
-@Component
-class InitializationConfig(
-    private val workspaceService: WorkspaceService,
-) : CommandLineRunner {
-
-    private val logger = LoggerFactory.getLogger(InitializationConfig::class.java)
-
-    override fun run(vararg args: String?) {
-        logger.info("Starting application initialization...")
-        logger.info("Default workspace template will be created automatically when first workspace is requested")
-        logger.info("Application initialization completed")
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/config/MongoConfig.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/config/MongoConfig.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/config/MongoConfig.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/config/MongoConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,51 +0,0 @@
-package net.kigawa.keruta.infra.persistence.config
-
-import com.mongodb.ConnectionString
-import com.mongodb.MongoClientSettings
-import com.mongodb.client.MongoClient
-import com.mongodb.client.MongoClients
-import org.springframework.beans.factory.annotation.Value
-import org.springframework.context.annotation.Configuration
-import org.springframework.data.mongodb.config.AbstractMongoClientConfiguration
-import org.springframework.data.mongodb.repository.config.EnableMongoRepositories
-
-@Configuration
-@EnableMongoRepositories(basePackages = ["net.kigawa.keruta.infra.persistence.repository"])
-class MongoConfig : AbstractMongoClientConfiguration() {
-
-    @Value("\${spring.data.mongodb.host}")
-    private lateinit var host: String
-
-    @Value("\${spring.data.mongodb.port}")
-    private lateinit var port: String
-
-    @Value("\${spring.data.mongodb.database}")
-    private lateinit var database: String
-
-    @Value("\${spring.data.mongodb.username:}")
-    private var username: String = ""
-
-    @Value("\${spring.data.mongodb.password:}")
-    private var password: String = ""
-
-    @Value("\${spring.data.mongodb.authentication-database:}")
-    private var authSource: String = ""
-
-    override fun getDatabaseName(): String {
-        return database
-    }
-
-    override fun mongoClient(): MongoClient {
-        val connectionString = if (username.isNotEmpty() && password.isNotEmpty()) {
-            ConnectionString("mongodb://$username:$password@$host:$port/$database?authSource=$authSource")
-        } else {
-            ConnectionString("mongodb://$host:$port/$database")
-        }
-
-        val clientSettings = MongoClientSettings.builder()
-            .applyConnectionString(connectionString)
-            .build()
-
-        return MongoClients.create(clientSettings)
-    }
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/RestAuthenticationEntryPoint.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/RestAuthenticationEntryPoint.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/RestAuthenticationEntryPoint.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/RestAuthenticationEntryPoint.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,59 +0,0 @@
-package net.kigawa.keruta.infra.security.config
-
-import com.fasterxml.jackson.databind.ObjectMapper
-import jakarta.servlet.http.HttpServletRequest
-import jakarta.servlet.http.HttpServletResponse
-import org.springframework.http.MediaType
-import org.springframework.security.core.AuthenticationException
-import org.springframework.security.web.AuthenticationEntryPoint
-import org.springframework.stereotype.Component
-import java.time.ZonedDateTime
-import java.time.format.DateTimeFormatter
-
-/**
- * Custom AuthenticationEntryPoint for REST API endpoints.
- * Returns 401 Unauthorized instead of redirecting to login page.
- * Formats error response according to API specifications.
- */
-@Component
-class RestAuthenticationEntryPoint(private val objectMapper: ObjectMapper) : AuthenticationEntryPoint {
-    override fun commence(
-        request: HttpServletRequest,
-        response: HttpServletResponse,
-        authException: AuthenticationException,
-    ) {
-        // Get the authentication error message
-        val originalMessage = authException.message
-
-        // Create a more polite and detailed error message
-        val errorMessage = when {
-            originalMessage?.contains("expired", ignoreCase = true) == true ->
-                "Your session has expired. Please log in again to continue."
-            originalMessage?.contains("bad credentials", ignoreCase = true) == true ->
-                "The provided credentials are incorrect. Please check your username and password and try again."
-            originalMessage?.contains("disabled", ignoreCase = true) == true ->
-                "Your account is currently disabled. Please contact support for assistance."
-            originalMessage?.contains("locked", ignoreCase = true) == true ->
-                "Your account is locked. Please contact support for assistance."
-            else ->
-                "Authentication is required to access this resource. Please log in with valid credentials."
-        }
-
-        // Format error response according to API specifications
-        val errorResponse = mapOf(
-            "error" to mapOf(
-                "code" to "UNAUTHORIZED",
-                "message" to errorMessage,
-                "status" to HttpServletResponse.SC_UNAUTHORIZED,
-            ),
-            "meta" to mapOf(
-                "timestamp" to ZonedDateTime.now().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME),
-                "version" to "1.0.0",
-            ),
-        )
-
-        response.contentType = MediaType.APPLICATION_JSON_VALUE
-        response.status = HttpServletResponse.SC_UNAUTHORIZED
-        objectMapper.writeValue(response.outputStream, errorResponse)
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/task/TaskServiceImpl.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/task/TaskServiceImpl.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/task/TaskServiceImpl.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/task/TaskServiceImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,178 +0,0 @@
-package net.kigawa.keruta.core.usecase.task
-
-import net.kigawa.keruta.core.domain.model.Task
-import net.kigawa.keruta.core.domain.model.TaskStatus
-import net.kigawa.keruta.core.usecase.repository.TaskRepository
-import org.slf4j.LoggerFactory
-import org.springframework.stereotype.Service
-import java.time.LocalDateTime
-
-@Service
-open class TaskServiceImpl(
-    private val taskRepository: TaskRepository,
-) : TaskService {
-
-    private val logger = LoggerFactory.getLogger(TaskServiceImpl::class.java)
-
-    override suspend fun getAllTasks(): List<Task> {
-        return taskRepository.findAll()
-    }
-
-    override suspend fun getTaskById(id: String): Task {
-        return taskRepository.findById(id) ?: throw NoSuchElementException("Task not found with id: $id")
-    }
-
-    override suspend fun getTasksBySessionId(sessionId: String): List<Task> {
-        return taskRepository.findBySessionId(sessionId)
-    }
-
-    override suspend fun getTasksByWorkspaceId(workspaceId: String): List<Task> {
-        return taskRepository.findByWorkspaceId(workspaceId)
-    }
-
-    override suspend fun getTasksByStatus(status: TaskStatus): List<Task> {
-        return taskRepository.findByStatus(status)
-    }
-
-    override suspend fun getPendingTasksForSession(sessionId: String): List<Task> {
-        return taskRepository.findPendingTasksForSession(sessionId)
-    }
-
-    override suspend fun searchTasksByName(name: String): List<Task> {
-        return taskRepository.findByNameContaining(name)
-    }
-
-    override suspend fun getTasksByTag(tag: String): List<Task> {
-        return taskRepository.findByTag(tag)
-    }
-
-    override suspend fun getSubTasks(parentTaskId: String): List<Task> {
-        return taskRepository.findByParentTaskId(parentTaskId)
-    }
-
-    override suspend fun createTask(task: Task): Task {
-        logger.info("Creating new task: name={}, sessionId={}", task.name, task.sessionId)
-
-        val taskWithDefaults = task.copy(
-            createdAt = LocalDateTime.now(),
-            updatedAt = LocalDateTime.now(),
-            status = TaskStatus.PENDING,
-        )
-
-        val createdTask = taskRepository.save(taskWithDefaults)
-        logger.info("Task created successfully: id={}", createdTask.id)
-        return createdTask
-    }
-
-    override suspend fun updateTask(id: String, task: Task): Task {
-        logger.info("Updating task: id={}", id)
-        val existingTask = getTaskById(id)
-
-        val updatedTask = task.copy(
-            id = existingTask.id,
-            createdAt = existingTask.createdAt,
-            updatedAt = LocalDateTime.now(),
-        )
-
-        val savedTask = taskRepository.save(updatedTask)
-        logger.info("Task updated successfully: id={}", id)
-        return savedTask
-    }
-
-    override suspend fun deleteTask(id: String) {
-        logger.info("Deleting task: id={}", id)
-        val task = getTaskById(id) // Verify task exists
-
-        if (!taskRepository.deleteById(id)) {
-            throw NoSuchElementException("Task not found with id: $id")
-        }
-
-        logger.info("Task deleted successfully: id={} name={}", id, task.name)
-    }
-
-    override suspend fun deleteTasksBySessionId(sessionId: String) {
-        logger.info("Deleting tasks for session: sessionId={}", sessionId)
-        val deleted = taskRepository.deleteBySessionId(sessionId)
-        logger.info("Deleted {} tasks for session: sessionId={}", if (deleted) "some" else "no", sessionId)
-    }
-
-    override suspend fun updateTaskStatus(id: String, status: TaskStatus): Task {
-        logger.info("Updating task status: id={} status={}", id, status)
-        val updatedTask = taskRepository.updateStatus(id, status)
-            ?: throw NoSuchElementException("Task not found with id: $id")
-
-        logger.info("Task status updated successfully: id={} status={}", id, status)
-        return updatedTask
-    }
-
-    override suspend fun updateTaskStatusWithMessage(
-        id: String,
-        status: TaskStatus,
-        errorMessage: String?,
-        errorCode: String?,
-    ): Task {
-        logger.info("Updating task status with message: id={} status={} errorCode={}", id, status, errorCode)
-        val updatedTask = taskRepository.updateStatusAndMessage(id, status, errorMessage, errorCode)
-            ?: throw NoSuchElementException("Task not found with id: $id")
-
-        logger.info("Task status and message updated successfully: id={} status={}", id, status)
-        return updatedTask
-    }
-
-    override suspend fun startTask(id: String): Task {
-        logger.info("Starting task: id={}", id)
-        return updateTaskStatus(id, TaskStatus.IN_PROGRESS)
-    }
-
-    override suspend fun completeTask(id: String): Task {
-        logger.info("Completing task: id={}", id)
-        return updateTaskStatus(id, TaskStatus.COMPLETED)
-    }
-
-    override suspend fun failTask(id: String, errorMessage: String, errorCode: String?): Task {
-        logger.error("Failing task: id={} errorMessage={} errorCode={}", id, errorMessage, errorCode)
-        return updateTaskStatusWithMessage(id, TaskStatus.FAILED, errorMessage, errorCode)
-    }
-
-    override suspend fun retryTask(id: String): Task {
-        logger.info("Retrying task: id={}", id)
-        val task = getTaskById(id)
-
-        if (task.retryCount >= task.maxRetries) {
-            logger.warn(
-                "Task has exceeded max retries: id={} retryCount={} maxRetries={}",
-                id,
-                task.retryCount,
-                task.maxRetries,
-            )
-            return failTask(id, "Max retries exceeded", "MAX_RETRIES_EXCEEDED")
-        }
-
-        val retriedTask = taskRepository.incrementRetryCount(id)
-            ?: throw NoSuchElementException("Task not found with id: $id")
-
-        logger.info("Task retry count incremented: id={} retryCount={}", id, retriedTask.retryCount)
-        return retriedTask
-    }
-
-    override suspend fun cancelTask(id: String): Task {
-        logger.info("Cancelling task: id={}", id)
-        return updateTaskStatus(id, TaskStatus.CANCELLED)
-    }
-
-    override suspend fun addLogToTask(id: String, logMessage: String): Task {
-        logger.debug("Adding log to task: id={}", id)
-        val task = getTaskById(id)
-        val updatedLogs = task.logs + logMessage
-        val updatedTask = task.copy(logs = updatedLogs, updatedAt = LocalDateTime.now())
-        return taskRepository.save(updatedTask)
-    }
-
-    override suspend fun addArtifactToTask(id: String, artifactPath: String): Task {
-        logger.info("Adding artifact to task: id={} artifactPath={}", id, artifactPath)
-        val task = getTaskById(id)
-        val updatedArtifacts = task.artifacts + artifactPath
-        val updatedTask = task.copy(artifacts = updatedArtifacts, updatedAt = LocalDateTime.now())
-        return taskRepository.save(updatedTask)
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/WorkspaceRepository.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/WorkspaceRepository.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/WorkspaceRepository.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/repository/WorkspaceRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,38 +0,0 @@
-package net.kigawa.keruta.core.usecase.repository
-
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.core.domain.model.WorkspaceTemplate
-
-/**
- * Repository interface for workspace operations.
- */
-interface WorkspaceRepository {
-    suspend fun findById(id: String): Workspace?
-    suspend fun findBySessionId(sessionId: String): List<Workspace>
-    suspend fun findByStatus(status: WorkspaceStatus): List<Workspace>
-    suspend fun findByName(name: String): List<Workspace>
-    suspend fun findAll(): List<Workspace>
-    suspend fun save(workspace: Workspace): Workspace
-    suspend fun update(workspace: Workspace): Workspace
-    suspend fun delete(id: String): Boolean
-    suspend fun deleteBySessionId(sessionId: String): Boolean
-    suspend fun existsByName(name: String): Boolean
-    suspend fun existsBySessionId(sessionId: String): Boolean
-    suspend fun countByStatus(status: WorkspaceStatus): Long
-    suspend fun countBySessionId(sessionId: String): Long
-}
-
-/**
- * Repository interface for workspace template operations.
- */
-interface WorkspaceTemplateRepository {
-    suspend fun findById(id: String): WorkspaceTemplate?
-    suspend fun findByName(name: String): WorkspaceTemplate?
-    suspend fun findAll(): List<WorkspaceTemplate>
-    suspend fun findDefaultTemplate(): WorkspaceTemplate?
-    suspend fun save(template: WorkspaceTemplate): WorkspaceTemplate
-    suspend fun update(template: WorkspaceTemplate): WorkspaceTemplate
-    suspend fun delete(id: String): Boolean
-    suspend fun existsByName(name: String): Boolean
-}
Index: keruta-api/infra/core/src/main/kotlin/net/kigawa/keruta/infra/core/coroutine/CoroutineServiceImpl.kt
===================================================================
diff --git a/keruta-api/infra/core/src/main/kotlin/net/kigawa/keruta/infra/core/coroutine/CoroutineServiceImpl.kt b/keruta-api/infra/core/src/main/kotlin/net/kigawa/keruta/infra/core/coroutine/CoroutineServiceImpl.kt
deleted file mode 100644
--- a/keruta-api/infra/core/src/main/kotlin/net/kigawa/keruta/infra/core/coroutine/CoroutineServiceImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,43 +0,0 @@
-package net.kigawa.keruta.infra.core.coroutine
-
-import kotlinx.coroutines.CoroutineExceptionHandler
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.SupervisorJob
-import kotlinx.coroutines.launch
-import net.kigawa.keruta.core.usecase.CoroutineService
-import org.slf4j.LoggerFactory
-import org.springframework.stereotype.Service
-
-/**
- * Implementation of the CoroutineService interface.
- * Uses a SupervisorJob to ensure that failures in one coroutine don't affect others.
- */
-@Service
-open class CoroutineServiceImpl : CoroutineService {
-    private val logger = LoggerFactory.getLogger(CoroutineServiceImpl::class.java)
-
-    // Create a CoroutineScope with a SupervisorJob and Dispatchers.Default
-    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
-
-    override fun launch(block: suspend CoroutineScope.() -> Unit): Job {
-        return scope.launch {
-            block()
-        }
-    }
-
-    override fun launchWithErrorHandling(
-        block: suspend CoroutineScope.() -> Unit,
-        onError: (Throwable) -> Unit,
-    ): Job {
-        val exceptionHandler = CoroutineExceptionHandler { _, throwable ->
-            logger.error("Coroutine failed with exception", throwable)
-            onError(throwable)
-        }
-
-        return scope.launch(exceptionHandler) {
-            block()
-        }
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoTaskRepository.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoTaskRepository.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoTaskRepository.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoTaskRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,21 +0,0 @@
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.infra.persistence.entity.TaskEntity
-import org.springframework.data.mongodb.repository.MongoRepository
-import org.springframework.data.mongodb.repository.Query
-import org.springframework.stereotype.Repository
-
-@Repository
-interface MongoTaskRepository : MongoRepository<TaskEntity, String> {
-    fun findBySessionId(sessionId: String): List<TaskEntity>
-    fun findByWorkspaceId(workspaceId: String): List<TaskEntity>
-    fun findByStatus(status: String): List<TaskEntity>
-    fun findBySessionIdAndStatus(sessionId: String, status: String): List<TaskEntity>
-    fun findByNameContainingIgnoreCase(name: String): List<TaskEntity>
-    fun findByTagsContaining(tag: String): List<TaskEntity>
-    fun findByParentTaskId(parentTaskId: String): List<TaskEntity>
-    fun deleteBySessionId(sessionId: String): Long
-
-    @Query("{ 'sessionId': ?0, 'status': 'PENDING' }")
-    fun findPendingTasksForSession(sessionId: String): List<TaskEntity>
-}
Index: keruta-api/infra/persistence/src/main/main3.iml
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/main3.iml b/keruta-api/infra/persistence/src/main/main3.iml
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/main3.iml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/kotlin" isTestSource="false" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: keruta-api/buildSrc/src/main/kotlin/Dependencies.kt
===================================================================
diff --git a/keruta-api/buildSrc/src/main/kotlin/Dependencies.kt b/keruta-api/buildSrc/src/main/kotlin/Dependencies.kt
deleted file mode 100644
--- a/keruta-api/buildSrc/src/main/kotlin/Dependencies.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,73 +0,0 @@
-object Versions {
-    const val springBoot = "3.2.0"
-    const val springDependencyManagement = "1.1.4"
-    const val kotlin = "1.9.20"
-    const val mongodbDriver = "4.11.1"
-    const val jjwt = "0.11.5"
-    const val jakartaServlet = "6.0.0"
-    const val springdoc = "2.3.0"
-    const val thymeleaf = "3.1.2.RELEASE"
-    const val keycloak = "23.0.3"
-    const val fabric8KubernetesClient = "6.5.1"
-    const val testcontainers = "1.19.3"
-    const val kotlinxCoroutines = "1.7.3"
-    const val junit = "5.10.1"
-    const val mockitoKotlin = "5.2.1"
-}
-
-object Dependencies {
-    // Spring
-    const val springBootStarter = "org.springframework.boot:spring-boot-starter"
-    const val springBootStarterWeb = "org.springframework.boot:spring-boot-starter-web"
-    const val springBootStarterSecurity = "org.springframework.boot:spring-boot-starter-security"
-    const val springBootStarterData = "org.springframework.boot:spring-boot-starter-data-mongodb"
-    const val springBootStarterTest = "org.springframework.boot:spring-boot-starter-test"
-    const val springBootStarterOauth2Client = "org.springframework.boot:spring-boot-starter-oauth2-client"
-    // WebSocket functionality has been removed
-    // const val springBootStarterWebsocket = "org.springframework.boot:spring-boot-starter-websocket"
-
-    // MongoDB
-    const val mongodbDriver = "org.mongodb:mongodb-driver-sync:${Versions.mongodbDriver}"
-
-    // JWT
-    const val jjwtApi = "io.jsonwebtoken:jjwt-api:${Versions.jjwt}"
-    const val jjwtImpl = "io.jsonwebtoken:jjwt-impl:${Versions.jjwt}"
-    const val jjwtJackson = "io.jsonwebtoken:jjwt-jackson:${Versions.jjwt}"
-
-    // Jackson
-    const val jacksonDatatypeJsr310 = "com.fasterxml.jackson.datatype:jackson-datatype-jsr310"
-    const val jacksonModuleKotlin = "com.fasterxml.jackson.module:jackson-module-kotlin"
-
-    // Kotlin
-    const val kotlinReflect = "org.jetbrains.kotlin:kotlin-reflect"
-    const val kotlinStdlib = "org.jetbrains.kotlin:kotlin-stdlib"
-
-    // Kotlin Coroutines
-    const val kotlinxCoroutinesCore = "org.jetbrains.kotlinx:kotlinx-coroutines-core:${Versions.kotlinxCoroutines}"
-    const val kotlinxCoroutinesReactor = "org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${Versions.kotlinxCoroutines}"
-
-    // Jakarta
-    const val jakartaServletApi = "jakarta.servlet:jakarta.servlet-api:${Versions.jakartaServlet}"
-
-    // Springdoc OpenAPI (Swagger)
-    const val springdocOpenApi = "org.springdoc:springdoc-openapi-starter-webmvc-ui:${Versions.springdoc}"
-
-    // Thymeleaf
-    const val springBootStarterThymeleaf = "org.springframework.boot:spring-boot-starter-thymeleaf"
-
-    // Keycloak
-    const val keycloakSpringBootAdapter = "org.keycloak:keycloak-spring-boot-starter:${Versions.keycloak}"
-    const val keycloakSpringSecurityAdapter = "org.keycloak:keycloak-spring-security-adapter:${Versions.keycloak}"
-
-    // Kubernetes
-    const val fabric8KubernetesClient = "io.fabric8:kubernetes-client:${Versions.fabric8KubernetesClient}"
-
-    // TestContainers
-    const val testcontainersJunit = "org.testcontainers:junit-jupiter:${Versions.testcontainers}"
-    const val testcontainersCore = "org.testcontainers:testcontainers:${Versions.testcontainers}"
-    const val testcontainersMongodb = "org.testcontainers:mongodb:${Versions.testcontainers}"
-    const val testcontainersPostgresql = "org.testcontainers:postgresql:${Versions.testcontainers}"
-
-    // Mockito for Kotlin
-    const val mockitoKotlin = "org.mockito.kotlin:mockito-kotlin:${Versions.mockitoKotlin}"
-}
Index: keruta-api/infra/security/src/test/test4.iml
===================================================================
diff --git a/keruta-api/infra/security/src/test/test4.iml b/keruta-api/infra/security/src/test/test4.iml
deleted file mode 100644
--- a/keruta-api/infra/security/src/test/test4.iml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="true">
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/kotlin" isTestSource="true" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionEventListener.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionEventListener.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionEventListener.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/session/SessionEventListener.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,365 +0,0 @@
-package net.kigawa.keruta.core.usecase.session
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionStatus
-import net.kigawa.keruta.core.domain.model.Workspace
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.core.usecase.workspace.CreateWorkspaceRequest
-import net.kigawa.keruta.core.usecase.workspace.WorkspaceService
-import org.slf4j.LoggerFactory
-import org.springframework.stereotype.Component
-
-/**
- * Event listener for session lifecycle events.
- */
-@Component
-open class SessionEventListener(
-    open val workspaceService: WorkspaceService,
-) {
-    open val logger = LoggerFactory.getLogger(SessionEventListener::class.java)
-
-    /**
-     * Handles session creation event.
-     * Automatically creates a single workspace for the new session.
-     * Each session has exactly one workspace.
-     */
-    suspend fun onSessionCreated(session: Session) {
-        logger.info("Handling session created event: sessionId={}", session.id)
-
-        try {
-            // Check if workspace already exists for this session
-            val existingWorkspaces = workspaceService.getWorkspacesBySessionId(session.id)
-            if (existingWorkspaces.isNotEmpty()) {
-                logger.info(
-                    "Workspace already exists for session: sessionId={} workspaceId={}",
-                    session.id,
-                    existingWorkspaces.first().id,
-                )
-                return
-            }
-
-            // Create single workspace for the new session
-            val workspaceRequest = CreateWorkspaceRequest(
-                name = normalizeWorkspaceName(session.name), // Normalize session name for Coder compatibility
-                sessionId = session.id,
-                templateId = session.templateConfig?.templateId, // Use session-specific template if configured
-                automaticUpdates = true,
-                ttlMs = 3600000, // 1 hour default TTL
-            )
-
-            val workspace = workspaceService.createWorkspace(workspaceRequest)
-            logger.info(
-                "Successfully created workspace for session: sessionId={} workspaceId={}",
-                session.id,
-                workspace.id,
-            )
-        } catch (e: Exception) {
-            logger.error("Failed to create workspace for session: sessionId={}", session.id, e)
-            throw e
-        }
-    }
-
-    /**
-     * Handles session status change event.
-     * Starts or stops the single workspace based on session status.
-     */
-    suspend fun onSessionStatusChanged(session: Session, oldStatus: SessionStatus) {
-        logger.info(
-            "Handling session status change: sessionId={} oldStatus={} newStatus={}",
-            session.id,
-            oldStatus,
-            session.status,
-        )
-
-        try {
-            val workspaces = workspaceService.getWorkspacesBySessionId(session.id)
-
-            if (workspaces.isEmpty()) {
-                logger.warn("No workspace found for session: sessionId={}", session.id)
-                return
-            }
-
-            if (workspaces.size > 1) {
-                logger.warn(
-                    "Multiple workspaces found for session (expected 1): sessionId={} count={}",
-                    session.id,
-                    workspaces.size,
-                )
-            }
-
-            // Filter out DELETED workspaces and get the first active one
-            val activeWorkspaces = workspaces.filter { it.status != WorkspaceStatus.DELETED }
-            if (activeWorkspaces.isEmpty()) {
-                logger.warn("No active workspace found for session, all are DELETED: sessionId={}", session.id)
-                // Create a new workspace if all are deleted
-                if (session.status == SessionStatus.ACTIVE) {
-                    logger.info(
-                        "Creating new workspace for active session with no active workspaces: sessionId={}",
-                        session.id,
-                    )
-                    val workspaceRequest = CreateWorkspaceRequest(
-                        name = normalizeWorkspaceName(session.name),
-                        sessionId = session.id,
-                        templateId = session.templateConfig?.templateId,
-                        automaticUpdates = true,
-                        ttlMs = 3600000, // 1 hour default TTL
-                    )
-                    val newWorkspace = workspaceService.createWorkspace(workspaceRequest)
-                    workspaceService.startWorkspace(newWorkspace.id)
-                    logger.info(
-                        "Successfully created and started new workspace: sessionId={} workspaceId={}",
-                        session.id,
-                        newWorkspace.id,
-                    )
-                }
-                return
-            }
-
-            val workspace = activeWorkspaces.first() // Use the first active workspace
-
-            when (session.status) {
-                SessionStatus.ACTIVE -> {
-                    logger.info(
-                        "Starting workspace for active session: sessionId={} workspaceId={}",
-                        session.id,
-                        workspace.id,
-                    )
-
-                    // Handle FAILED workspace by trying to recreate it
-                    if (workspace.status == WorkspaceStatus.FAILED) {
-                        logger.warn(
-                            "Workspace is in FAILED state, attempting to recreate: sessionId={} workspaceId={}",
-                            session.id,
-                            workspace.id,
-                        )
-                        try {
-                            // For FAILED workspace, try to reset it to a recoverable state first
-                            logger.info("Attempting to reset FAILED workspace status: workspaceId={}", workspace.id)
-
-                            // Reset the workspace status to STOPPED to allow restarting
-                            workspaceService.updateWorkspaceStatus(workspace.id, WorkspaceStatus.STOPPED)
-
-                            // Now try to start the workspace
-                            workspaceService.startWorkspace(workspace.id)
-                            logger.info(
-                                "Successfully reset and started FAILED workspace: sessionId={} workspaceId={}",
-                                session.id,
-                                workspace.id,
-                            )
-                        } catch (e: Exception) {
-                            logger.error(
-                                "Failed to reset FAILED workspace for session: sessionId={} workspaceId={}",
-                                session.id,
-                                workspace.id,
-                                e,
-                            )
-                            logger.warn("Will attempt to delete and recreate workspace in background")
-                            // TODO: Consider implementing background cleanup task for failed workspaces
-                        }
-                    } else {
-                        workspaceService.startWorkspace(workspace.id)
-                    }
-                }
-                SessionStatus.INACTIVE -> {
-                    // Only stop if workspace is not already DELETED
-                    if (workspace.status != WorkspaceStatus.DELETED) {
-                        logger.info(
-                            "Stopping workspace for inactive session: sessionId={} workspaceId={}",
-                            session.id,
-                            workspace.id,
-                        )
-                        workspaceService.stopWorkspace(workspace.id)
-                    } else {
-                        logger.info(
-                            "Workspace is already DELETED, no action needed for inactive session: sessionId={} workspaceId={}",
-                            session.id,
-                            workspace.id,
-                        )
-                    }
-                }
-                else -> {
-                    logger.debug("No workspace action needed for session status: {}", session.status)
-                }
-            }
-        } catch (e: Exception) {
-            logger.error("Failed to handle session status change: sessionId={}", session.id, e)
-        }
-    }
-
-    /**
-     * Handles session template change event.
-     * Creates a new workspace with the updated template configuration.
-     */
-    suspend fun onSessionTemplateChanged(newSession: Session, oldSession: Session) {
-        logger.info("Handling session template change event: sessionId={}", newSession.id)
-
-        try {
-            // Get existing workspaces for this session
-            val existingWorkspaces = workspaceService.getWorkspacesBySessionId(newSession.id)
-
-            // Stop and mark old workspaces as archived
-            for (workspace in existingWorkspaces) {
-                logger.info(
-                    "Stopping and archiving old workspace due to template change: sessionId={} workspaceId={}",
-                    newSession.id,
-                    workspace.id,
-                )
-                try {
-                    // Stop the workspace gracefully
-                    workspaceService.stopWorkspace(workspace.id)
-                    // Mark it as archived so it won't be used anymore
-                    workspaceService.updateWorkspaceStatus(workspace.id, WorkspaceStatus.DELETED)
-                } catch (e: Exception) {
-                    logger.warn(
-                        "Failed to stop old workspace, continuing with new workspace creation: workspaceId={}",
-                        workspace.id,
-                        e,
-                    )
-                }
-            }
-
-            // Create new workspace with updated template configuration
-            val workspaceRequest = CreateWorkspaceRequest(
-                name = "${normalizeWorkspaceName(
-                    newSession.name,
-                )}-v${System.currentTimeMillis() / 1000}", // Add timestamp to ensure uniqueness
-                sessionId = newSession.id,
-                templateId = newSession.templateConfig?.templateId,
-                automaticUpdates = true,
-                ttlMs = 3600000, // 1 hour default TTL
-            )
-
-            val newWorkspace = workspaceService.createWorkspace(workspaceRequest)
-            logger.info(
-                "Successfully created new workspace for template change: sessionId={} oldWorkspaceCount={} newWorkspaceId={}",
-                newSession.id,
-                existingWorkspaces.size,
-                newWorkspace.id,
-            )
-
-            // If session is currently active, start the new workspace
-            if (newSession.status == SessionStatus.ACTIVE) {
-                logger.info("Starting new workspace as session is active: workspaceId={}", newWorkspace.id)
-                workspaceService.startWorkspace(newWorkspace.id)
-            }
-        } catch (e: Exception) {
-            logger.error("Failed to handle session template change: sessionId={}", newSession.id, e)
-            throw e
-        }
-    }
-
-    /**
-     * Handles session deletion event.
-     * Cleans up associated workspaces.
-     */
-    suspend fun onSessionDeleted(sessionId: String) {
-        logger.info("Handling session deletion event: sessionId={}", sessionId)
-
-        try {
-            // Delete all workspaces associated with this session
-            val deleted = workspaceService.deleteWorkspacesBySessionId(sessionId)
-            if (deleted) {
-                logger.info("Successfully initiated workspace deletion for session: sessionId={}", sessionId)
-            } else {
-                logger.info("No workspaces found to delete for session: sessionId={}", sessionId)
-            }
-        } catch (e: Exception) {
-            logger.error("Failed to delete workspaces for session: sessionId={}", sessionId, e)
-            // Don't rethrow the exception to avoid failing the session deletion process
-            // The session deletion should proceed even if workspace cleanup fails
-        }
-    }
-
-    /**
-     * Handles workspace status change event.
-     * Updates session status based on workspace state.
-     */
-    suspend fun onWorkspaceStatusChanged(workspace: Workspace, oldStatus: WorkspaceStatus) {
-        logger.info(
-            "Handling workspace status change: workspaceId={} sessionId={} oldStatus={} newStatus={}",
-            workspace.id,
-            workspace.sessionId,
-            oldStatus,
-            workspace.status,
-        )
-
-        try {
-            val newSessionStatus = mapWorkspaceStatusToSessionStatus(workspace.status)
-            if (newSessionStatus != null) {
-                logger.info(
-                    "Updating session status based on workspace: sessionId={} newStatus={}",
-                    workspace.sessionId,
-                    newSessionStatus,
-                )
-                // Note: This would require a SessionService dependency to avoid circular dependencies
-                // We'll implement this through a separate service
-            }
-        } catch (e: Exception) {
-            logger.error(
-                "Failed to handle workspace status change: workspaceId={} sessionId={}",
-                workspace.id,
-                workspace.sessionId,
-                e,
-            )
-        }
-    }
-
-    /**
-     * Maps workspace status to corresponding session status.
-     */
-    private fun mapWorkspaceStatusToSessionStatus(workspaceStatus: WorkspaceStatus): SessionStatus? {
-        return when (workspaceStatus) {
-            WorkspaceStatus.RUNNING -> SessionStatus.ACTIVE
-            WorkspaceStatus.STOPPED -> SessionStatus.INACTIVE
-            WorkspaceStatus.FAILED -> SessionStatus.INACTIVE
-            WorkspaceStatus.DELETED -> SessionStatus.ARCHIVED
-            else -> null // No session status change needed for PENDING, STARTING, STOPPING, DELETING, CANCELED
-        }
-    }
-
-    /**
-     * Normalizes session name to be compatible with Coder workspace naming rules.
-     * Coder workspace names must:
-     * - Start with a-z, A-Z, or 0-9
-     * - Contain only a-z, A-Z, 0-9, and hyphens (-)
-     * - Be 32 characters or less
-     * - Not end with a hyphen
-     */
-    private fun normalizeWorkspaceName(sessionName: String): String {
-        // Replace non-alphanumeric characters with hyphens
-        var normalized = sessionName
-            .replace(Regex("[^a-zA-Z0-9-]"), "-")
-            .lowercase()
-
-        // Ensure it starts with alphanumeric character
-        if (normalized.isNotEmpty() && !normalized[0].isLetterOrDigit()) {
-            normalized = "workspace-$normalized"
-        }
-
-        // Remove consecutive hyphens
-        normalized = normalized.replace(Regex("-+"), "-")
-
-        // Remove leading and trailing hyphens
-        normalized = normalized.trim('-')
-
-        // If empty or only non-alphanumeric, use default name
-        if (normalized.isEmpty() || normalized.all { !it.isLetterOrDigit() }) {
-            normalized = "workspace"
-        }
-
-        // Truncate to 32 characters
-        if (normalized.length > 32) {
-            normalized = normalized.substring(0, 32).trimEnd('-')
-        }
-
-        // Ensure it doesn't end with hyphen
-        normalized = normalized.trimEnd('-')
-
-        // Final fallback if somehow we end up with empty string
-        if (normalized.isEmpty()) {
-            normalized = "workspace"
-        }
-
-        return normalized
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceTemplateInitializer.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceTemplateInitializer.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceTemplateInitializer.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/workspace/WorkspaceTemplateInitializer.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,39 +0,0 @@
-package net.kigawa.keruta.core.usecase.workspace
-
-import kotlinx.coroutines.runBlocking
-import net.kigawa.keruta.core.usecase.repository.WorkspaceTemplateRepository
-import org.slf4j.LoggerFactory
-import org.springframework.boot.CommandLineRunner
-import org.springframework.stereotype.Component
-
-/**
- * Initializes workspace templates on application startup.
- * Validates workspace template configuration.
- */
-@Component
-@org.springframework.core.annotation.Order(2) // Run after DatabaseInitializer
-class WorkspaceTemplateInitializer(
-    private val workspaceTemplateRepository: WorkspaceTemplateRepository,
-) : CommandLineRunner {
-
-    private val logger = LoggerFactory.getLogger(WorkspaceTemplateInitializer::class.java)
-
-    override fun run(vararg args: String?) {
-        runBlocking {
-            try {
-                logger.info("Validating workspace template configuration...")
-
-                val defaultTemplate = workspaceTemplateRepository.findDefaultTemplate()
-                if (defaultTemplate != null) {
-                    logger.info("Default template is properly configured: {}", defaultTemplate.id)
-                } else {
-                    logger.info("No default template found, one will be created when needed")
-                }
-
-                logger.info("Workspace template validation completed")
-            } catch (e: Exception) {
-                logger.error("Failed to validate workspace templates", e)
-            }
-        }
-    }
-}
Index: keruta-api/infra/security/src/test/kotlin/net/kigawa/keruta/infra/security/config/GlobalExceptionHandlerTest.kt
===================================================================
diff --git a/keruta-api/infra/security/src/test/kotlin/net/kigawa/keruta/infra/security/config/GlobalExceptionHandlerTest.kt b/keruta-api/infra/security/src/test/kotlin/net/kigawa/keruta/infra/security/config/GlobalExceptionHandlerTest.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/test/kotlin/net/kigawa/keruta/infra/security/config/GlobalExceptionHandlerTest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,104 +0,0 @@
-package net.kigawa.keruta.infra.security.config
-
-import org.junit.jupiter.api.Assertions.assertEquals
-import org.junit.jupiter.api.Assertions.assertNotNull
-import org.junit.jupiter.api.Assertions.assertTrue
-import org.junit.jupiter.api.Test
-import org.junit.jupiter.api.extension.ExtendWith
-import org.mockito.InjectMocks
-import org.mockito.Mock
-import org.mockito.junit.jupiter.MockitoExtension
-import org.springframework.http.HttpStatus
-import org.springframework.web.context.request.WebRequest
-import java.util.NoSuchElementException
-
-@ExtendWith(MockitoExtension::class)
-class GlobalExceptionHandlerTest {
-
-    @InjectMocks
-    private lateinit var exceptionHandler: GlobalExceptionHandler
-
-    @Mock
-    private lateinit var webRequest: WebRequest
-
-    @Test
-    fun `handleNoSuchElementException should return 404 with polite error message`() {
-        // Given
-        val exception = NoSuchElementException("Task not found with id: 123")
-
-        // When
-        val response = exceptionHandler.handleNoSuchElementException(exception, webRequest)
-
-        // Then
-        assertEquals(HttpStatus.NOT_FOUND.value(), response.statusCode.value())
-
-        val body = response.body
-        assertNotNull(body)
-        assertTrue(body!!.containsKey("error"))
-        assertTrue(body.containsKey("meta"))
-
-        val error = body["error"] as Map<*, *>
-        assertEquals("RESOURCE_NOT_FOUND", error["code"])
-        assertEquals("Task not found with id: 123", error["message"])
-        assertEquals(HttpStatus.NOT_FOUND.value(), error["status"])
-
-        val meta = body["meta"] as Map<*, *>
-        assertTrue(meta.containsKey("timestamp"))
-        assertEquals("1.0.0", meta["version"])
-    }
-
-    @Test
-    fun `handleIllegalArgumentException should return 400 with polite error message`() {
-        // Given
-        val exception = IllegalArgumentException("Invalid task status: UNKNOWN")
-
-        // When
-        val response = exceptionHandler.handleIllegalArgumentException(exception, webRequest)
-
-        // Then
-        assertEquals(HttpStatus.BAD_REQUEST.value(), response.statusCode.value())
-
-        val body = response.body
-        assertNotNull(body)
-        assertTrue(body!!.containsKey("error"))
-        assertTrue(body.containsKey("meta"))
-
-        val error = body["error"] as Map<*, *>
-        assertEquals("INVALID_INPUT", error["code"])
-        assertEquals("Invalid task status: UNKNOWN", error["message"])
-        assertEquals(HttpStatus.BAD_REQUEST.value(), error["status"])
-
-        val meta = body["meta"] as Map<*, *>
-        assertTrue(meta.containsKey("timestamp"))
-        assertEquals("1.0.0", meta["version"])
-    }
-
-    @Test
-    fun `handleGenericException should return 500 with polite error message`() {
-        // Given
-        val exception = RuntimeException("Something went wrong")
-
-        // When
-        val response = exceptionHandler.handleGenericException(exception, webRequest)
-
-        // Then
-        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR.value(), response.statusCode.value())
-
-        val body = response.body
-        assertNotNull(body)
-        assertTrue(body!!.containsKey("error"))
-        assertTrue(body.containsKey("meta"))
-
-        val error = body["error"] as Map<*, *>
-        assertEquals("INTERNAL_SERVER_ERROR", error["code"])
-        assertEquals(
-            "An unexpected error occurred. Our team has been notified and is working to resolve the issue. Please try again later.",
-            error["message"],
-        )
-        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR.value(), error["status"])
-
-        val meta = body["meta"] as Map<*, *>
-        assertTrue(meta.containsKey("timestamp"))
-        assertEquals("1.0.0", meta["version"])
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/config/DatabaseInitializer.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/config/DatabaseInitializer.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/config/DatabaseInitializer.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/config/DatabaseInitializer.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,54 +0,0 @@
-package net.kigawa.keruta.infra.persistence.config
-
-import kotlinx.coroutines.runBlocking
-import net.kigawa.keruta.infra.persistence.repository.WorkspaceTemplateRepositoryImpl
-import org.slf4j.LoggerFactory
-import org.springframework.boot.CommandLineRunner
-import org.springframework.core.annotation.Order
-import org.springframework.stereotype.Component
-
-/**
- * Database initializer that runs on application startup.
- * Fixes database inconsistencies and performs cleanup tasks.
- */
-@Component
-@Order(1) // Run before other initializers
-class DatabaseInitializer(
-    private val workspaceTemplateRepositoryImpl: WorkspaceTemplateRepositoryImpl,
-) : CommandLineRunner {
-
-    private val logger = LoggerFactory.getLogger(DatabaseInitializer::class.java)
-
-    override fun run(vararg args: String?) {
-        runBlocking {
-            try {
-                logger.info("Starting database initialization...")
-
-                // Fix duplicate default templates
-                fixDuplicateDefaultTemplates()
-
-                logger.info("Database initialization completed")
-            } catch (e: Exception) {
-                logger.error("Database initialization failed", e)
-            }
-        }
-    }
-
-    private suspend fun fixDuplicateDefaultTemplates() {
-        try {
-            logger.info("Checking for duplicate default templates...")
-
-            val defaultTemplates = workspaceTemplateRepositoryImpl.findAllDefaultTemplates()
-
-            if (defaultTemplates.size > 1) {
-                logger.warn("Found {} default templates, fixing duplicates...", defaultTemplates.size)
-                val fixed = workspaceTemplateRepositoryImpl.fixDuplicateDefaultTemplates()
-                logger.info("Fixed {} duplicate default templates", fixed)
-            } else {
-                logger.info("Default templates are properly configured (count: {})", defaultTemplates.size)
-            }
-        } catch (e: Exception) {
-            logger.error("Failed to fix duplicate default templates", e)
-        }
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/UpdateTaskRequest.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/UpdateTaskRequest.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/UpdateTaskRequest.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/task/dto/UpdateTaskRequest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,32 +0,0 @@
-package net.kigawa.keruta.api.task.dto
-
-import net.kigawa.keruta.core.domain.model.Task
-import net.kigawa.keruta.core.domain.model.TaskStatus
-
-data class UpdateTaskRequest(
-    val name: String? = null,
-    val description: String? = null,
-    val script: String? = null,
-    val status: String? = null,
-    val priority: Int? = null,
-    val parameters: Map<String, String>? = null,
-    val tags: List<String>? = null,
-    val metadata: Map<String, String>? = null,
-    val maxRetries: Int? = null,
-    val dependsOn: List<String>? = null,
-) {
-    fun toDomain(existingTask: Task): Task {
-        return existingTask.copy(
-            name = name ?: existingTask.name,
-            description = description ?: existingTask.description,
-            script = script ?: existingTask.script,
-            status = status?.let { TaskStatus.valueOf(it) } ?: existingTask.status,
-            priority = priority ?: existingTask.priority,
-            parameters = parameters ?: existingTask.parameters,
-            tags = tags ?: existingTask.tags,
-            metadata = metadata ?: existingTask.metadata,
-            maxRetries = maxRetries ?: existingTask.maxRetries,
-            dependsOn = dependsOn ?: existingTask.dependsOn,
-        )
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/document/DocumentServiceImpl.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/document/DocumentServiceImpl.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/document/DocumentServiceImpl.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/document/DocumentServiceImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,49 +0,0 @@
-/**
- * Implementation of the DocumentService interface.
- */
-package net.kigawa.keruta.core.usecase.document
-
-import net.kigawa.keruta.core.domain.model.Document
-import net.kigawa.keruta.core.usecase.repository.DocumentRepository
-import org.springframework.stereotype.Service
-import java.time.LocalDateTime
-
-@Service
-open class DocumentServiceImpl(private val documentRepository: DocumentRepository) : DocumentService {
-
-    override fun getAllDocuments(): List<Document> {
-        return documentRepository.findAll()
-    }
-
-    override fun getDocumentById(id: String): Document {
-        return documentRepository.findById(id) ?: throw NoSuchElementException("Document not found with id: $id")
-    }
-
-    override fun createDocument(document: Document): Document {
-        return documentRepository.save(document)
-    }
-
-    override fun updateDocument(id: String, document: Document): Document {
-        val existingDocument = getDocumentById(id)
-        val updatedDocument = document.copy(
-            id = existingDocument.id,
-            createdAt = existingDocument.createdAt,
-            updatedAt = LocalDateTime.now(),
-        )
-        return documentRepository.save(updatedDocument)
-    }
-
-    override fun deleteDocument(id: String) {
-        if (!documentRepository.deleteById(id)) {
-            throw NoSuchElementException("Document not found with id: $id")
-        }
-    }
-
-    override fun searchDocuments(query: String): List<Document> {
-        return documentRepository.search(query)
-    }
-
-    override fun getDocumentsByTag(tag: String): List<Document> {
-        return documentRepository.findByTag(tag)
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/SessionRepositoryImpl.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/SessionRepositoryImpl.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/SessionRepositoryImpl.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/SessionRepositoryImpl.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,111 +0,0 @@
-/**
- * Implementation of the SessionRepository interface using MongoDB.
- */
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionStatus
-import net.kigawa.keruta.core.usecase.repository.SessionRepository
-import net.kigawa.keruta.infra.persistence.entity.SessionEntity
-import org.slf4j.LoggerFactory
-import org.springframework.stereotype.Component
-
-@Component
-class SessionRepositoryImpl(private val mongoSessionRepository: MongoSessionRepository) : SessionRepository {
-    private val logger = LoggerFactory.getLogger(SessionRepositoryImpl::class.java)
-
-    override suspend fun findAll(): List<Session> {
-        logger.debug("Finding all sessions")
-        try {
-            val entities = mongoSessionRepository.findAll()
-            logger.debug("Found {} session entities", entities.size)
-
-            val sessions = entities.mapNotNull { entity ->
-                try {
-                    entity.toDomain()
-                } catch (e: Exception) {
-                    logger.error("Failed to convert session entity to domain object: {}", entity.id, e)
-                    null
-                }
-            }
-
-            logger.debug("Successfully converted {} session entities to domain objects", sessions.size)
-            return sessions
-        } catch (e: Exception) {
-            logger.error("Failed to find all sessions", e)
-            throw e
-        }
-    }
-
-    override suspend fun findById(id: String): Session? {
-        logger.debug("Finding session by id: {}", id)
-        try {
-            val entity = mongoSessionRepository.findById(id).orElse(null)
-            if (entity == null) {
-                logger.debug("No session found with id: {}", id)
-                return null
-            }
-
-            try {
-                val session = entity.toDomain()
-                logger.debug("Successfully found and converted session with id: {}", id)
-                return session
-            } catch (e: Exception) {
-                logger.error("Failed to convert session entity to domain object: {}", id, e)
-                return null
-            }
-        } catch (e: Exception) {
-            logger.error("Failed to find session by id: {}", id, e)
-            throw e
-        }
-    }
-
-    override suspend fun save(session: Session): Session {
-        logger.debug("Saving session: {}", session.id)
-        try {
-            val entity = SessionEntity.fromDomain(session)
-            logger.debug("Converted session to entity: {}", entity.id)
-
-            try {
-                val savedEntity = mongoSessionRepository.save(entity)
-                logger.debug("Successfully saved session entity: {}", savedEntity.id)
-
-                try {
-                    val savedSession = savedEntity.toDomain()
-                    logger.debug("Successfully converted saved entity to domain object: {}", savedSession.id)
-                    return savedSession
-                } catch (e: Exception) {
-                    logger.error("Failed to convert saved entity to domain object: {}", savedEntity.id, e)
-                    throw e
-                }
-            } catch (e: Exception) {
-                logger.error("Failed to save session entity: {}", entity.id, e)
-                throw e
-            }
-        } catch (e: Exception) {
-            logger.error("Failed to convert session to entity: {}", session.id, e)
-            throw e
-        }
-    }
-
-    override suspend fun deleteById(id: String): Boolean {
-        return if (mongoSessionRepository.existsById(id)) {
-            mongoSessionRepository.deleteById(id)
-            true
-        } else {
-            false
-        }
-    }
-
-    override suspend fun findByStatus(status: SessionStatus): List<Session> {
-        return mongoSessionRepository.findByStatus(status.name).map { it.toDomain() }
-    }
-
-    override suspend fun findByNameContaining(name: String): List<Session> {
-        return mongoSessionRepository.findByNameContainingIgnoreCase(name).map { it.toDomain() }
-    }
-
-    override suspend fun findByTag(tag: String): List<Session> {
-        return mongoSessionRepository.findByTagsContaining(tag).map { it.toDomain() }
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/UpdateSessionRequest.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/UpdateSessionRequest.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/UpdateSessionRequest.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/session/dto/UpdateSessionRequest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,33 +0,0 @@
-package net.kigawa.keruta.api.session.dto
-
-import net.kigawa.keruta.core.domain.model.Session
-import net.kigawa.keruta.core.domain.model.SessionStatus
-import java.time.LocalDateTime
-
-data class UpdateSessionRequest(
-    val name: String,
-    val description: String? = null,
-    val status: String = SessionStatus.ACTIVE.name,
-    val tags: List<String> = emptyList(),
-    val metadata: Map<String, String> = emptyMap(),
-    val templateConfig: SessionTemplateConfigRequest? = null,
-) {
-    fun toDomain(id: String): Session {
-        val sessionStatus = try {
-            SessionStatus.valueOf(status.uppercase())
-        } catch (e: IllegalArgumentException) {
-            SessionStatus.ACTIVE
-        }
-
-        return Session(
-            id = id,
-            name = name,
-            description = description,
-            status = sessionStatus,
-            tags = tags,
-            metadata = metadata,
-            templateConfig = templateConfig?.toDomain(),
-            updatedAt = LocalDateTime.now(),
-        )
-    }
-}
Index: keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/CoroutineService.kt
===================================================================
diff --git a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/CoroutineService.kt b/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/CoroutineService.kt
deleted file mode 100644
--- a/keruta-api/core/usecase/src/main/kotlin/net/kigawa/keruta/core/usecase/CoroutineService.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,29 +0,0 @@
-package net.kigawa.keruta.core.usecase
-
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Job
-
-/**
- * Service for managing coroutines in the application.
- */
-interface CoroutineService {
-    /**
-     * Launches a coroutine that executes the given block.
-     *
-     * @param block The suspend function to execute.
-     * @return A Job that can be used to cancel the coroutine.
-     */
-    fun launch(block: suspend CoroutineScope.() -> Unit): Job
-
-    /**
-     * Launches a coroutine that executes the given block and handles any exceptions.
-     *
-     * @param block The suspend function to execute.
-     * @param onError The function to call if an exception is thrown.
-     * @return A Job that can be used to cancel the coroutine.
-     */
-    fun launchWithErrorHandling(
-        block: suspend CoroutineScope.() -> Unit,
-        onError: (Throwable) -> Unit,
-    ): Job
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/GlobalExceptionHandler.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/GlobalExceptionHandler.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/GlobalExceptionHandler.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/config/GlobalExceptionHandler.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,135 +0,0 @@
-package net.kigawa.keruta.infra.security.config
-
-import org.slf4j.LoggerFactory
-import org.springframework.http.HttpStatus
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.ControllerAdvice
-import org.springframework.web.bind.annotation.ExceptionHandler
-import org.springframework.web.context.request.ServletWebRequest
-import org.springframework.web.context.request.WebRequest
-import java.time.ZonedDateTime
-import java.time.format.DateTimeFormatter
-import java.util.NoSuchElementException
-
-/**
- * Global exception handler for the application.
- * Provides standardized error responses for different types of exceptions.
- */
-@ControllerAdvice
-class GlobalExceptionHandler {
-
-    private val logger = LoggerFactory.getLogger(GlobalExceptionHandler::class.java)
-
-    /**
-     * Handles NoSuchElementException which occurs when a requested resource is not found.
-     * Returns a 404 Not Found response with a detailed error message.
-     */
-    @ExceptionHandler(NoSuchElementException::class)
-    fun handleNoSuchElementException(
-        ex: NoSuchElementException,
-        request: WebRequest,
-    ): ResponseEntity<Map<String, Any>> {
-        val errorMessage = ex.message ?: "The requested resource could not be found. Please check your input and try again."
-        val path = getRequestPath(request)
-
-        logger.error("404 Not Found: {} - Path: {}", errorMessage, path)
-
-        return createErrorResponse(
-            HttpStatus.NOT_FOUND,
-            "RESOURCE_NOT_FOUND",
-            errorMessage,
-        )
-    }
-
-    /**
-     * Handles IllegalArgumentException which occurs when invalid input is provided.
-     * Returns a 400 Bad Request response with a detailed error message.
-     */
-    @ExceptionHandler(IllegalArgumentException::class)
-    fun handleIllegalArgumentException(
-        ex: IllegalArgumentException,
-        request: WebRequest,
-    ): ResponseEntity<Map<String, Any>> {
-        val errorMessage = ex.message ?: "Invalid input provided. Please check your request parameters and try again."
-        val path = getRequestPath(request)
-
-        logger.error("400 Bad Request: {} - Path: {}", errorMessage, path)
-
-        return createErrorResponse(
-            HttpStatus.BAD_REQUEST,
-            "INVALID_INPUT",
-            errorMessage,
-        )
-    }
-
-    /**
-     * Handles all other exceptions that are not specifically handled.
-     * Returns a 500 Internal Server Error response with a generic error message.
-     */
-    @ExceptionHandler(Exception::class)
-    fun handleGenericException(
-        ex: Exception,
-        request: WebRequest,
-    ): ResponseEntity<Map<String, Any>> {
-        val errorMessage = "An unexpected error occurred. Our team has been notified and is working to resolve the issue. Please try again later."
-        val path = getRequestPath(request)
-
-        // Log the 500 error to the console with the request path
-        logger.error("500 Internal Server Error: {} - Path: {}", ex.message, path, ex)
-
-        return createErrorResponse(
-            HttpStatus.INTERNAL_SERVER_ERROR,
-            "INTERNAL_SERVER_ERROR",
-            errorMessage,
-        )
-    }
-
-    /**
-     * Creates a standardized error response with the given status, code, and message.
-     */
-    private fun createErrorResponse(
-        status: HttpStatus,
-        code: String,
-        message: String,
-    ): ResponseEntity<Map<String, Any>> {
-        val errorResponse = mapOf(
-            "error" to mapOf(
-                "code" to code,
-                "message" to message,
-                "status" to status.value(),
-            ),
-            "meta" to mapOf(
-                "timestamp" to ZonedDateTime.now().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME),
-                "version" to "1.0.0",
-            ),
-        )
-
-        return ResponseEntity.status(status).body(errorResponse)
-    }
-
-    /**
-     * Extracts the request path from the WebRequest object.
-     * If the WebRequest is a ServletWebRequest, it gets the path from the HttpServletRequest.
-     * Otherwise, it returns a placeholder.
-     */
-    private fun getRequestPath(request: WebRequest): String {
-        return try {
-            if (request is ServletWebRequest) {
-                val servletRequest = request.request
-                val queryString = servletRequest.queryString
-                val path = servletRequest.requestURI
-
-                if (queryString != null && queryString.isNotEmpty()) {
-                    "$path?$queryString"
-                } else {
-                    path
-                }
-            } else {
-                "Unknown path"
-            }
-        } catch (e: Exception) {
-            logger.warn("Failed to extract request path", e)
-            "Unknown path"
-        }
-    }
-}
Index: keruta-api/infra/persistence/build.gradle.kts
===================================================================
diff --git a/keruta-api/infra/persistence/build.gradle.kts b/keruta-api/infra/persistence/build.gradle.kts
deleted file mode 100644
--- a/keruta-api/infra/persistence/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,18 +0,0 @@
-plugins {
-    kotlin("jvm")
-    kotlin("plugin.spring")
-}
-
-dependencies {
-    implementation(project(":core:domain"))
-    implementation(project(":core:usecase"))
-
-    implementation(Dependencies.kotlinStdlib)
-    implementation(Dependencies.kotlinReflect)
-    implementation(Dependencies.kotlinxCoroutinesCore)
-    implementation(Dependencies.springBootStarter)
-    implementation(Dependencies.springBootStarterData)
-    implementation(Dependencies.mongodbDriver)
-
-    testImplementation(Dependencies.springBootStarterTest)
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/document/controller/DocumentController.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/document/controller/DocumentController.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/document/controller/DocumentController.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/document/controller/DocumentController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,92 +0,0 @@
-package net.kigawa.keruta.api.document.controller
-
-import io.swagger.v3.oas.annotations.Operation
-import io.swagger.v3.oas.annotations.tags.Tag
-import net.kigawa.keruta.core.domain.model.Document
-import org.springframework.http.ResponseEntity
-import org.springframework.web.bind.annotation.*
-import java.time.LocalDateTime
-import java.util.*
-
-@RestController
-@RequestMapping("/api/v1/documents")
-@Tag(name = "Document", description = "Document management API")
-class DocumentController {
-
-    private val documents = mutableListOf<Document>()
-
-    @GetMapping
-    @Operation(summary = "Get all documents", description = "Retrieves a list of all documents")
-    fun getAllDocuments(): List<Document> {
-        return documents
-    }
-
-    @PostMapping
-    @Operation(summary = "Create a document", description = "Creates a new document")
-    fun createDocument(@RequestBody document: Document): Document {
-        val newDocument = document.copy(
-            id = UUID.randomUUID().toString(),
-            createdAt = LocalDateTime.now(),
-            updatedAt = LocalDateTime.now(),
-        )
-        documents.add(newDocument)
-        return newDocument
-    }
-
-    @GetMapping("/{id}")
-    @Operation(summary = "Get document by ID", description = "Retrieves a specific document by its ID")
-    fun getDocumentById(@PathVariable id: String): ResponseEntity<Document> {
-        val document = documents.find { it.id == id }
-        return if (document != null) {
-            ResponseEntity.ok(document)
-        } else {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @PutMapping("/{id}")
-    @Operation(summary = "Update document", description = "Updates an existing document")
-    fun updateDocument(@PathVariable id: String, @RequestBody document: Document): ResponseEntity<Document> {
-        val index = documents.indexOfFirst { it.id == id }
-        if (index == -1) {
-            return ResponseEntity.notFound().build()
-        }
-
-        val updatedDocument = document.copy(
-            id = id,
-            updatedAt = LocalDateTime.now(),
-        )
-        documents[index] = updatedDocument
-        return ResponseEntity.ok(updatedDocument)
-    }
-
-    @DeleteMapping("/{id}")
-    @Operation(summary = "Delete document", description = "Deletes a document by its ID")
-    fun deleteDocument(@PathVariable id: String): ResponseEntity<Void> {
-        val removed = documents.removeIf { it.id == id }
-        return if (removed) {
-            ResponseEntity.noContent().build()
-        } else {
-            ResponseEntity.notFound().build()
-        }
-    }
-
-    @GetMapping("/search")
-    @Operation(summary = "Search documents", description = "Searches for documents based on query parameters")
-    fun searchDocuments(
-        @RequestParam(required = false) title: String?,
-        @RequestParam(required = false) tag: String?,
-    ): List<Document> {
-        var filteredDocuments: List<Document> = documents
-
-        if (!title.isNullOrBlank()) {
-            filteredDocuments = filteredDocuments.filter { it.title.contains(title, ignoreCase = true) }
-        }
-
-        if (!tag.isNullOrBlank()) {
-            filteredDocuments = filteredDocuments.filter { it.tags.contains(tag) }
-        }
-
-        return filteredDocuments
-    }
-}
Index: keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/config/MongoTestConfig.kt
===================================================================
diff --git a/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/config/MongoTestConfig.kt b/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/config/MongoTestConfig.kt
deleted file mode 100644
--- a/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/config/MongoTestConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,36 +0,0 @@
-package net.kigawa.keruta.api.config
-
-import com.mongodb.ConnectionString
-import com.mongodb.MongoClientSettings
-import com.mongodb.client.MongoClient
-import com.mongodb.client.MongoClients
-import org.springframework.beans.factory.annotation.Value
-import org.springframework.context.annotation.Bean
-import org.springframework.context.annotation.Configuration
-import org.springframework.context.annotation.Primary
-import org.springframework.context.annotation.Profile
-import org.springframework.data.mongodb.core.MongoTemplate
-
-@Configuration
-@Profile("test")
-class MongoTestConfig {
-
-    @Value("\${spring.data.mongodb.uri}")
-    private lateinit var mongoUri: String
-
-    @Bean
-    @Primary
-    fun mongoClient(): MongoClient {
-        val connectionString = ConnectionString(mongoUri)
-        val clientSettings = MongoClientSettings.builder()
-            .applyConnectionString(connectionString)
-            .build()
-        return MongoClients.create(clientSettings)
-    }
-
-    @Bean
-    @Primary
-    fun mongoTemplate(mongoClient: MongoClient): MongoTemplate {
-        return MongoTemplate(mongoClient, "test")
-    }
-}
Index: keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/v1/HealthController.kt
===================================================================
diff --git a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/v1/HealthController.kt b/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/v1/HealthController.kt
deleted file mode 100644
--- a/keruta-api/api/src/main/kotlin/net/kigawa/keruta/api/v1/HealthController.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,20 +0,0 @@
-package net.kigawa.keruta.api.v1
-
-import org.springframework.web.bind.annotation.GetMapping
-import org.springframework.web.bind.annotation.RequestMapping
-import org.springframework.web.bind.annotation.RestController
-import java.time.LocalDateTime
-
-@RestController
-@RequestMapping("/api/v1/health")
-class HealthController {
-
-    @GetMapping
-    fun health(): Map<String, Any> {
-        return mapOf(
-            "status" to "UP",
-            "timestamp" to LocalDateTime.now().toString(),
-            "message" to "Keruta API is running",
-        )
-    }
-}
Index: keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/model/User.kt
===================================================================
diff --git a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/model/User.kt b/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/model/User.kt
deleted file mode 100644
--- a/keruta-api/infra/security/src/main/kotlin/net/kigawa/keruta/infra/security/model/User.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,43 +0,0 @@
-package net.kigawa.keruta.infra.security.model
-
-import org.springframework.security.core.GrantedAuthority
-import org.springframework.security.core.authority.SimpleGrantedAuthority
-import org.springframework.security.core.userdetails.UserDetails
-
-/**
- * User model for authentication.
- */
-data class User(
-    private val username: String,
-    private val password: String,
-    private val authorities: Collection<GrantedAuthority> = listOf(),
-    private val accountNonExpired: Boolean = true,
-    private val accountNonLocked: Boolean = true,
-    private val credentialsNonExpired: Boolean = true,
-    private val enabled: Boolean = true,
-) : UserDetails {
-
-    override fun getUsername(): String = username
-
-    override fun getPassword(): String = password
-
-    override fun getAuthorities(): Collection<GrantedAuthority> = authorities
-
-    override fun isAccountNonExpired(): Boolean = accountNonExpired
-
-    override fun isAccountNonLocked(): Boolean = accountNonLocked
-
-    override fun isCredentialsNonExpired(): Boolean = credentialsNonExpired
-
-    override fun isEnabled(): Boolean = enabled
-
-    companion object {
-        /**
-         * Creates a user with the given username, password, and roles.
-         */
-        fun create(username: String, password: String, roles: List<String> = listOf("USER")): User {
-            val authorities = roles.map { SimpleGrantedAuthority("ROLE_$it") }
-            return User(username, password, authorities)
-        }
-    }
-}
Index: keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/KerutaApplicationTest.kt
===================================================================
diff --git a/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/KerutaApplicationTest.kt b/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/KerutaApplicationTest.kt
deleted file mode 100644
--- a/keruta-api/api/src/test/kotlin/net/kigawa/keruta/api/KerutaApplicationTest.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,72 +0,0 @@
-package net.kigawa.keruta.api
-
-import org.junit.jupiter.api.Assertions.assertNotNull
-import org.junit.jupiter.api.Assertions.assertTrue
-import org.junit.jupiter.api.Test
-import org.springframework.beans.factory.annotation.Autowired
-import org.springframework.boot.test.context.SpringBootTest
-import org.springframework.context.ApplicationContext
-import org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor
-
-// @Testcontainers - Temporarily disabled due to container startup issues
-@SpringBootTest(
-    properties = [
-        "spring.data.mongodb.host=localhost",
-        "spring.data.mongodb.port=27017",
-        "spring.data.mongodb.database=keruta-test",
-        "spring.security.oauth2.client.provider.keycloak.issuer-uri=http://localhost:8080/realms/keruta",
-        "keycloak.auth-server-url=http://localhost:8080",
-        "keruta.kubernetes.enabled=false",
-    ],
-)
-class KerutaApplicationTest {
-
-    @Autowired
-    private lateinit var applicationContext: ApplicationContext
-
-    @Test
-    fun `context loads`() {
-        // This test will fail if the application context cannot be loaded
-        assertNotNull(applicationContext, "Application context should not be null")
-    }
-
-    @Test
-    fun `application has all required beans`() {
-        // Verify that key beans are available in the application context
-        assertNotNull(
-            applicationContext.getBean(KerutaApplication::class.java),
-            "KerutaApplication bean should be available",
-        )
-    }
-
-    @Test
-    fun `scheduling is enabled`() {
-        // Verify that scheduling is enabled by checking for the presence of scheduling-related beans
-        assertNotNull(
-            applicationContext.getBean(ScheduledAnnotationBeanPostProcessor::class.java),
-            "ScheduledAnnotationBeanPostProcessor bean should be available when scheduling is enabled",
-        )
-    }
-
-    @Test
-    fun `configuration properties scanning is enabled`() {
-        // Verify that configuration properties scanning is enabled
-        // This is a bit harder to test directly, but we can check that the application starts successfully,
-        // which it wouldn't if @ConfigurationPropertiesScan was not working correctly
-        assertNotNull(applicationContext, "Application context should be available")
-        // The fact that the test is running means that the application context was created successfully,
-        // which indirectly verifies that configuration properties scanning is working
-    }
-
-    @Test
-    fun `component scanning includes all required packages`() {
-        // Verify that component scanning includes all required packages
-        // This is indirectly tested by the application starting successfully,
-        // but we can also check for the presence of beans from different packages
-        val beanDefinitionNames = applicationContext.beanDefinitionNames
-        assertTrue(
-            beanDefinitionNames.any { it.contains("keruta") },
-            "Bean definitions should include beans from the keruta package",
-        )
-    }
-}
Index: keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/config/AsyncConfig.kt
===================================================================
diff --git a/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/config/AsyncConfig.kt b/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/config/AsyncConfig.kt
deleted file mode 100644
--- a/keruta-api/infra/app/src/main/kotlin/net/kigawa/keruta/infra/app/config/AsyncConfig.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,54 +0,0 @@
-package net.kigawa.keruta.infra.app.config
-
-import org.springframework.context.annotation.Bean
-import org.springframework.context.annotation.Configuration
-import org.springframework.scheduling.annotation.EnableAsync
-import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor
-import org.springframework.web.client.RestTemplate
-import java.util.concurrent.Executor
-
-/**
- * Configuration class for asynchronous task execution.
- * Defines a custom thread pool for handling asynchronous tasks with increased thread counts.
- */
-@Configuration(value = "infraAsyncConfig")
-@EnableAsync
-class AsyncConfig {
-
-    /**
-     * Creates a custom thread pool task executor with increased thread counts.
-     *
-     * @return A configured ThreadPoolTaskExecutor
-     */
-    @Bean(name = ["infraTaskExecutor"])
-    fun taskExecutor(): Executor {
-        val executor = ThreadPoolTaskExecutor()
-
-        // Set core pool size (number of threads to keep in the pool, even if they are idle)
-        executor.corePoolSize = 10
-
-        // Set max pool size (maximum number of threads to allow in the pool)
-        executor.maxPoolSize = 50
-
-        // Set queue capacity (size of the queue used for holding tasks before they are executed)
-        executor.queueCapacity = 100
-
-        // Set thread name prefix for better identification in logs and monitoring
-        executor.setThreadNamePrefix("AsyncTask-")
-
-        // Initialize the executor
-        executor.initialize()
-
-        return executor
-    }
-
-    /**
-     * Creates a RestTemplate bean for HTTP communication.
-     *
-     * @return A configured RestTemplate
-     */
-    @Bean
-    fun restTemplate(): RestTemplate {
-        return RestTemplate()
-    }
-}
Index: keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoWorkspaceRepository.kt
===================================================================
diff --git a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoWorkspaceRepository.kt b/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoWorkspaceRepository.kt
deleted file mode 100644
--- a/keruta-api/infra/persistence/src/main/kotlin/net/kigawa/keruta/infra/persistence/repository/MongoWorkspaceRepository.kt	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ /dev/null	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
@@ -1,44 +0,0 @@
-package net.kigawa.keruta.infra.persistence.repository
-
-import net.kigawa.keruta.core.domain.model.WorkspaceStatus
-import net.kigawa.keruta.infra.persistence.entity.WorkspaceEntity
-import org.springframework.data.mongodb.repository.MongoRepository
-import org.springframework.data.mongodb.repository.Query
-import org.springframework.stereotype.Repository
-
-/**
- * MongoDB repository for workspace entities.
- */
-@Repository
-interface MongoWorkspaceRepository : MongoRepository<WorkspaceEntity, String> {
-
-    fun findBySessionId(sessionId: String): List<WorkspaceEntity>
-
-    fun findByStatus(status: WorkspaceStatus): List<WorkspaceEntity>
-
-    fun findByNameContainingIgnoreCase(name: String): List<WorkspaceEntity>
-
-    fun findBySessionIdAndName(sessionId: String, name: String): WorkspaceEntity?
-
-    fun existsBySessionIdAndName(sessionId: String, name: String): Boolean
-
-    fun existsBySessionId(sessionId: String): Boolean
-
-    fun deleteBySessionId(sessionId: String): Long
-
-    fun countByStatus(status: WorkspaceStatus): Long
-
-    fun countBySessionId(sessionId: String): Long
-
-    @Query("{ 'sessionId': ?0, 'status': { \$in: ?1 } }")
-    fun findBySessionIdAndStatusIn(sessionId: String, statuses: List<WorkspaceStatus>): List<WorkspaceEntity>
-
-    @Query("{ 'templateId': ?0 }")
-    fun findByTemplateId(templateId: String): List<WorkspaceEntity>
-
-    @Query("{ 'deletedAt': { \$exists: false } }")
-    fun findAllActive(): List<WorkspaceEntity>
-
-    @Query("{ 'sessionId': ?0, 'deletedAt': { \$exists: false } }")
-    fun findActiveBySessionId(sessionId: String): List<WorkspaceEntity>
-}
Index: keruta-api/Dockerfile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Build stage\nFROM gradle:jdk21 AS builder\nWORKDIR /app\n\n# Copy gradle files first for better layer caching\nCOPY ./gradlew .\nCOPY ./gradle gradle\nCOPY ./build.gradle.kts .\nCOPY ./settings.gradle.kts .\nCOPY ./buildSrc buildSrc\n\n# Download dependencies\nRUN gradle dependencies --no-daemon\n\n# Copy source code\nCOPY ./api api\nCOPY ./core core\nCOPY ./infra infra\n\n# Build the application\nRUN gradle bootJar --no-daemon\n\n# Runtime stage\nFROM eclipse-temurin:21-jre\nWORKDIR /app\n\n# Copy the built jar file from the builder stage\nCOPY --from=builder /app/api/build/libs/*.jar app.jar\n\n# Copy terraform templates\nCOPY ./terraform-templates ./terraform-templates\n\n# Set environment variables\nENV SPRING_PROFILES_ACTIVE=prod\n\n# Expose the application port\nEXPOSE 8080\n\n# Run the application\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/keruta-api/Dockerfile b/keruta-api/Dockerfile
--- a/keruta-api/Dockerfile	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ b/keruta-api/Dockerfile	(date 1753975279117)
@@ -4,37 +4,51 @@
 
 # Copy gradle files first for better layer caching
 COPY ./gradlew .
+COPY ./gradlew.bat .
 COPY ./gradle gradle
 COPY ./build.gradle.kts .
 COPY ./settings.gradle.kts .
-COPY ./buildSrc buildSrc
+
+# Make gradlew executable
+RUN chmod +x ./gradlew
 
 # Download dependencies
-RUN gradle dependencies --no-daemon
+RUN ./gradlew dependencies --no-daemon
 
 # Copy source code
-COPY ./api api
-COPY ./core core
-COPY ./infra infra
+COPY ./src src
 
 # Build the application
-RUN gradle bootJar --no-daemon
+RUN ./gradlew bootJar --no-daemon
 
 # Runtime stage
 FROM eclipse-temurin:21-jre
 WORKDIR /app
 
+# Create non-root user
+RUN groupadd -r keruta && useradd -r -g keruta keruta
+
 # Copy the built jar file from the builder stage
-COPY --from=builder /app/api/build/libs/*.jar app.jar
+COPY --from=builder /app/build/libs/*.jar app.jar
 
 # Copy terraform templates
 COPY ./terraform-templates ./terraform-templates
 
+# Set file ownership
+RUN chown -R keruta:keruta /app
+
 # Set environment variables
 ENV SPRING_PROFILES_ACTIVE=prod
 
+# Switch to non-root user
+USER keruta
+
 # Expose the application port
 EXPOSE 8080
 
+# Add health check
+HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
+  CMD curl -f http://localhost:8080/api/health || exit 1
+
 # Run the application
-ENTRYPOINT ["java", "-jar", "app.jar"]
+ENTRYPOINT ["java", "-jar", "app.jar"]
\ No newline at end of file
Index: keruta-api/settings.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>rootProject.name = \"keruta-api\"\n\n// Core modules\ninclude(\"core:domain\")\ninclude(\"core:usecase\")\n\n// Infrastructure modules\ninclude(\"infra:core\")\ninclude(\"infra:persistence\")\ninclude(\"infra:security\")\ninclude(\"infra:app\")\n\n// API modules\ninclude(\"api\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/keruta-api/settings.gradle.kts b/keruta-api/settings.gradle.kts
--- a/keruta-api/settings.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ b/keruta-api/settings.gradle.kts	(date 1753975279117)
@@ -1,14 +1,1 @@
 rootProject.name = "keruta-api"
-
-// Core modules
-include("core:domain")
-include("core:usecase")
-
-// Infrastructure modules
-include("infra:core")
-include("infra:persistence")
-include("infra:security")
-include("infra:app")
-
-// API modules
-include("api")
Index: keruta-api/.github/workflows/generate-openapi.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>name: Generate OpenAPI Specification\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - 'api/**'\n      - 'infra/**'\n      - '.github/workflows/generate-openapi.yml'\n\njobs:\n  generate-openapi:\n    runs-on: ubuntu-latest\n\n    services:\n      mongodb:\n        image: mongo:latest\n        ports:\n          - 27017:27017\n        env:\n          MONGO_INITDB_ROOT_USERNAME: admin\n          MONGO_INITDB_ROOT_PASSWORD: password\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Set up JDK 17\n        uses: actions/setup-java@v3\n        with:\n          java-version: '21'\n          distribution: 'temurin'\n          cache: gradle\n\n      - name: Build and run application\n        run: |\n          # set -e を追加してコマンド失敗時にスクリプトを終了\n          set -e\n          ./gradlew :api:bootRun --args='--spring.profiles.active=test' || { echo \"Gradleビルドに失敗しました\"; exit 1; } &\n          echo \"Waiting for application to start...\"\n\n          # Health check instead of sleep\n          MAX_RETRIES=60\n          RETRY_INTERVAL=5\n          RETRY_COUNT=0\n\n          echo \"Checking health endpoint at /api/v1/health...\"\n          until curl -s -f http://localhost:8080/api/v1/health > /dev/null || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do\n            echo \"Health check attempt $((RETRY_COUNT+1))/$MAX_RETRIES failed, retrying in ${RETRY_INTERVAL}s...\"\n            sleep $RETRY_INTERVAL\n            RETRY_COUNT=$((RETRY_COUNT+1))\n          done\n\n          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then\n            echo \"Health check failed after $MAX_RETRIES attempts. Exiting.\"\n            exit 1\n          fi\n\n          echo \"Application is healthy! Proceeding with OpenAPI generation.\"\n          mkdir -p /tmp\n          curl -s -f http://localhost:8080/api-docs > /tmp/openapi.json || { echo \"OpenAPI JSONの取得に失敗しました\"; exit 1; }\n          curl -s -f http://localhost:8080/api-docs.yaml > /tmp/openapi.yaml || { echo \"OpenAPI YAMLの取得に失敗しました\"; exit 1; }\n          echo \"OpenAPI specification generated\"\n\n\n      - name: Clone keruta-doc repository\n        run: |\n          set -e\n          git clone https://${{ secrets.GIT_TOKEN }}@github.com/kigawa-net/keruta-doc.git /tmp/keruta-doc || { echo \"リポジトリのクローンに失敗しました\"; exit 1; }\n          mkdir -p /tmp/keruta-doc/common/apiSpec\n          cp /tmp/openapi.json /tmp/keruta-doc/common/apiSpec/ || { echo \"OpenAPI JSONのコピーに失敗しました\"; exit 1; }\n          cp /tmp/openapi.yaml /tmp/keruta-doc/common/apiSpec/ || { echo \"OpenAPI YAMLのコピーに失敗しました\"; exit 1; }\n\n      - name: Commit and push to keruta-doc repository\n        run: |\n          cd /tmp/keruta-doc\n          git config --local user.email \"action@github.com\"\n          git config --local user.name \"GitHub Action\"\n          git add common/apiSpec/openapi.json common/apiSpec/openapi.yaml\n          git add README.md structure.md todo.md\n          git commit -m \"Update documentation and OpenAPI specification\" || echo \"No changes to commit\"\n          git push\n        env:\n          GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/keruta-api/.github/workflows/generate-openapi.yml b/keruta-api/.github/workflows/generate-openapi.yml
--- a/keruta-api/.github/workflows/generate-openapi.yml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ b/keruta-api/.github/workflows/generate-openapi.yml	(date 1753975279116)
@@ -37,7 +37,7 @@
         run: |
           # set -e を追加してコマンド失敗時にスクリプトを終了
           set -e
-          ./gradlew :api:bootRun --args='--spring.profiles.active=test' || { echo "Gradleビルドに失敗しました"; exit 1; } &
+          ./gradlew :bootRun --args='--spring.profiles.active=test' || { echo "Gradleビルドに失敗しました"; exit 1; } &
           echo "Waiting for application to start..."
 
           # Health check instead of sleep
Index: keruta-api/build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>plugins {\n    id(\"org.springframework.boot\") version \"3.2.0\" apply false\n    id(\"io.spring.dependency-management\") version \"1.1.4\" apply false\n    kotlin(\"jvm\") version \"1.9.20\" apply false\n    kotlin(\"plugin.spring\") version \"1.9.20\" apply false\n    id(\"org.jlleitschuh.gradle.ktlint\") version \"11.6.1\"\n}\n\nallprojects {\n    group = \"net.kigawa\"\n    version = \"0.0.1-SNAPSHOT\"\n\n    repositories {\n        mavenCentral()\n    }\n\n    apply(plugin = \"org.jlleitschuh.gradle.ktlint\")\n\n    configure<org.jlleitschuh.gradle.ktlint.KtlintExtension> {\n        version.set(\"0.50.0\")\n        verbose.set(true)\n        android.set(false)\n        outputToConsole.set(true)\n        outputColorName.set(\"RED\")\n        ignoreFailures.set(false)\n        enableExperimentalRules.set(true)\n        filter {\n            exclude(\"**/generated/**\")\n            include(\"**/kotlin/**\")\n        }\n    }\n}\n\n// Custom tasks for ktlint\ntasks.register(\"ktlintCheckAll\") {\n    group = \"verification\"\n    description = \"Run ktlint check on all modules\"\n    dependsOn(subprojects.map { it.tasks.named(\"ktlintCheck\") })\n}\n\ntasks.register(\"ktlintFormatAll\") {\n    group = \"formatting\"\n    description = \"Run ktlint format on all modules\"\n    dependsOn(subprojects.map { it.tasks.named(\"ktlintFormat\") })\n}\n\nsubprojects {\n    apply {\n        plugin(\"io.spring.dependency-management\")\n        plugin(\"java\")\n    }\n\n    the<io.spring.gradle.dependencymanagement.dsl.DependencyManagementExtension>().apply {\n        imports {\n            mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)\n        }\n    }\n\n    tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {\n        kotlinOptions {\n            jvmTarget = \"21\"\n        }\n    }\n\n    tasks.withType<JavaCompile> {\n        sourceCompatibility = \"21\"\n        targetCompatibility = \"21\"\n    }\n\n    tasks.withType<Test> {\n        useJUnitPlatform()\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/keruta-api/build.gradle.kts b/keruta-api/build.gradle.kts
--- a/keruta-api/build.gradle.kts	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ b/keruta-api/build.gradle.kts	(date 1753975279117)
@@ -1,73 +1,85 @@
 plugins {
-    id("org.springframework.boot") version "3.2.0" apply false
-    id("io.spring.dependency-management") version "1.1.4" apply false
-    kotlin("jvm") version "1.9.20" apply false
-    kotlin("plugin.spring") version "1.9.20" apply false
+    kotlin("jvm") version "1.9.20"
+    kotlin("plugin.spring") version "1.9.20"
+    id("org.springframework.boot") version "3.2.0"
+    id("io.spring.dependency-management") version "1.1.4"
     id("org.jlleitschuh.gradle.ktlint") version "11.6.1"
 }
 
-allprojects {
-    group = "net.kigawa"
-    version = "0.0.1-SNAPSHOT"
+group = "net.kigawa"
+version = "0.0.1-SNAPSHOT"
+java.sourceCompatibility = JavaVersion.VERSION_21
 
-    repositories {
-        mavenCentral()
-    }
+repositories {
+    mavenCentral()
+}
 
-    apply(plugin = "org.jlleitschuh.gradle.ktlint")
+dependencies {
+    // Kotlin
+    implementation("org.jetbrains.kotlin:kotlin-reflect")
+    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
+
+    // Spring Boot
+    implementation("org.springframework.boot:spring-boot-starter")
+    implementation("org.springframework.boot:spring-boot-starter-web")
+    implementation("org.springframework.boot:spring-boot-starter-security")
+    implementation("org.springframework.boot:spring-boot-starter-data-mongodb")
+    implementation("org.springframework.boot:spring-boot-starter-webflux")
+
+    // Coroutines
+    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core")
+    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
+
+    // MongoDB
+    implementation("org.mongodb:mongodb-driver-kotlin-coroutine:4.11.1")
+
+    // JWT
+    implementation("io.jsonwebtoken:jjwt-api:0.11.5")
+    implementation("io.jsonwebtoken:jjwt-impl:0.11.5")
+    implementation("io.jsonwebtoken:jjwt-jackson:0.11.5")
+
+    // Jackson
+    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
+    implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310")
+
+    // Swagger/OpenAPI
+    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.1.0")
+
+    // Logging
+    implementation("net.logstash.logback:logstash-logback-encoder:7.3")
+
+    // Testing
+    testImplementation("org.springframework.boot:spring-boot-starter-test") {
+        exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
+    }
+    testImplementation("org.junit.jupiter:junit-jupiter:5.9.3")
+    testImplementation("org.springframework.security:spring-security-test")
+    testImplementation("org.testcontainers:junit-jupiter")
+    testImplementation("org.testcontainers:testcontainers")
+    testImplementation("org.testcontainers:mongodb")
+    testImplementation("org.mockito.kotlin:mockito-kotlin:4.1.0")
+}
 
-    configure<org.jlleitschuh.gradle.ktlint.KtlintExtension> {
-        version.set("0.50.0")
-        verbose.set(true)
-        android.set(false)
-        outputToConsole.set(true)
-        outputColorName.set("RED")
-        ignoreFailures.set(false)
-        enableExperimentalRules.set(true)
-        filter {
-            exclude("**/generated/**")
-            include("**/kotlin/**")
-        }
+configure<org.jlleitschuh.gradle.ktlint.KtlintExtension> {
+    version.set("0.50.0")
+    verbose.set(true)
+    android.set(false)
+    outputToConsole.set(true)
+    outputColorName.set("RED")
+    ignoreFailures.set(false)
+    enableExperimentalRules.set(true)
+    filter {
+        exclude("**/generated/**")
+        include("**/kotlin/**")
     }
 }
-
-// Custom tasks for ktlint
-tasks.register("ktlintCheckAll") {
-    group = "verification"
-    description = "Run ktlint check on all modules"
-    dependsOn(subprojects.map { it.tasks.named("ktlintCheck") })
-}
-
-tasks.register("ktlintFormatAll") {
-    group = "formatting"
-    description = "Run ktlint format on all modules"
-    dependsOn(subprojects.map { it.tasks.named("ktlintFormat") })
-}
-
-subprojects {
-    apply {
-        plugin("io.spring.dependency-management")
-        plugin("java")
-    }
-
-    the<io.spring.gradle.dependencymanagement.dsl.DependencyManagementExtension>().apply {
-        imports {
-            mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
-        }
-    }
 
-    tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
-        kotlinOptions {
-            jvmTarget = "21"
-        }
-    }
+tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
+    kotlinOptions {
+        jvmTarget = "21"
+    }
+}
 
-    tasks.withType<JavaCompile> {
-        sourceCompatibility = "21"
-        targetCompatibility = "21"
-    }
-
-    tasks.withType<Test> {
-        useJUnitPlatform()
-    }
+tasks.withType<Test> {
+    useJUnitPlatform()
 }
Index: keruta-api/.github/workflows/test.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>name: test\n\non:\n  workflow_call:\n\njobs: {}\n#  back:\n#    runs-on: ubuntu-latest\n#    steps:\n#      - uses: actions/checkout@v4\n#\n#      - run:\n#          mkdir -p temp/test/app-data\n#      - run: |\n#          docker compose -f docker-compose.test.yml up backend-test --exit-code-from backend-test\n#      - run: docker compose -f docker-compose.test.yml logs\n#        if: always()\n#\n#      # キャッシュがない場合は Docker イメージをビルド後、tar アーカイブをキャッシュ先に保存\n#      - name: Build Docker image and save\n#        if: steps.cache.outputs.cache-hit != 'true'\n#        run: |\n#          # キャッシュディレクトリを作成\n#          mkdir -p ./temp\n#          # イメージのキャッシュ（tar をキャッシュ・ディレクトリに出力）\n#          docker save --output ./temp/postgres.tar postgres\n#          docker save --output ./temp/python.tar python\n#          docker save --output ./temp/rsync.tar secoresearch/rsync\n#\n#\n#  migration:\n#    runs-on: ubuntu-latest\n#    steps:\n#      - uses: actions/checkout@v4\n#\n#      - run:\n#          mkdir -p temp/test/app-data-test-migration\n#      - run: |\n#          docker compose -f docker-compose.test-migration.yml up test-migration --exit-code-from test-migration\n#      - run: docker compose -f docker-compose.test-migration.yml logs\n#        if: always()\n#\n#      # キャッシュがない場合は Docker イメージをビルド後、tar アーカイブをキャッシュ先に保存\n#      - name: Build Docker image and save\n#        if: steps.cache.outputs.cache-hit != 'true'\n#        run: |\n#          # キャッシュディレクトリを作成\n#          mkdir -p ./temp\n#          # イメージのキャッシュ（tar をキャッシュ・ディレクトリに出力）\n#          docker save --output ./temp/postgres.tar postgres\n#          docker save --output ./temp/python.tar python\n#          docker save --output ./temp/rsync.tar secoresearch/rsync\n#\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/keruta-api/.github/workflows/test.yml b/keruta-api/.github/workflows/test.yml
--- a/keruta-api/.github/workflows/test.yml	(revision f61c9ef51d4dfc6339f2a7df0f3629743aa3f32e)
+++ b/keruta-api/.github/workflows/test.yml	(date 1753975279116)
@@ -3,7 +3,11 @@
 on:
   workflow_call:
 
-jobs: {}
+jobs:
+  test:
+    runs-on: ubuntu-latest
+    steps:
+      - run: echo no content
 #  back:
 #    runs-on: ubuntu-latest
 #    steps:
